;
(function () {
  System.register(['./assets/utilities-legacy-Dzd-Bk5k.js'], function (exports, module) {
    'use strict';

    var safelyParseJSON;
    return {
      setters: [module => {
        safelyParseJSON = module.s;
      }],
      execute: function () {
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = ".wp-admin.post-type-petitioner-petition {\n  --ptr-admin-color-primary: #e01a2b;\n  --ptr-admin-color-dark: #000000;\n  --ptr-admin-color-grey: #efefef;\n  --ptr-admin-color-light: #f7f7f7;\n  --ptr-admin-fs-sm: 14px;\n  --ptr-admin-fs-md: 18px;\n  --ptr-admin-spacing-xs: 4px;\n  --ptr-admin-spacing-sm: 8px;\n  --ptr-admin-spacing-md: 16px;\n  --ptr-admin-spacing-lg: 24px;\n  --ptr-admin-spacing-xl: 32px;\n  --ptr-admin-spacing-x: 16px;\n  --ptr-admin-spacing-y: 16px;\n  --ptr-admin-wrapper-bg: white;\n  --ptr-admin-wrapper-radius: 16px;\n  --ptr-admin-input-border-width: 1px;\n  --ptr-admin-input-border-color: #a1a1a1;\n  --ptr-admin-input-border-color-active: #00000;\n  --ptr-admin-input-border-radius: 8px;\n  --ptr-admin-input-spacing-y: 0.7rem;\n  --ptr-admin-input-spacing-x: 16px;\n  --ptr-admin-label-font-size: var(--ptr-admin-fs-sm);\n  --ptr-admin-btn-font-size: var(--ptr-admin-fs-md);\n  --ptr-admin-btn-bg: var(--ptr-admin-color-primary);\n  --ptr-admin-btn-bg-hover: var(--ptr-admin-color-dark);\n  --ptr-admin-button-border-width: var(--ptr-admin-input-border-width);\n  --ptr-admin-button-border-color: transparent;\n  --ptr-admin-button-border-color-active: var(--ptr-admin-color-dark);\n  --ptr-admin-button-border-radius: 8px;\n  --ptr-admin-progress-height: 8px;\n  --ptr-admin-progress-bg: var(--ptr-admin-color-grey);\n  --ptr-admin-progress-radius: 4px;\n  --ptr-admin-progress-inner-bg: var(--ptr-admin-color-primary);\n}\n.wp-admin.post-type-petitioner-petition #edit-slug-box,\n.wp-admin.post-type-petitioner-petition #wp-admin-bar-view {\n  display: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-is-loading {\n  opacity: 0;\n  visibility: hidden;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-rich-text {\n  display: flex;\n  flex-direction: column;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-rich-text h4 {\n  margin-bottom: 4px !important;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-rich-text .help {\n  font-size: 12px;\n  color: #666;\n  margin-top: 0px;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-rich-text textarea {\n  display: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-code-snippets {\n  display: flex;\n  gap: 8px;\n  margin-bottom: 12px;\n  margin-top: 4px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-code-snippets input {\n  font-size: 12px;\n  font-weight: bold;\n  border: 1px solid #efefef;\n  background: #fbf0f0;\n  color: black;\n  outline: none;\n  text-align: center;\n  padding: 4px;\n  border-radius: 4px;\n  max-width: 120px;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-callout-box {\n  margin-top: 16px;\n  padding: 16px;\n  border-radius: 8px;\n  background: #f4f6fc;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-callout-box h2 {\n  font-weight: bold;\n  padding-left: 0 !important;\n  margin-left: 0 !important;\n  text-transform: uppercase;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-settings-box {\n  padding: 16px 16px 32px 16px;\n  border-radius: 8px;\n  background: #fff;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-settings-box .components-tab-panel__tabs {\n  margin-bottom: 32px;\n}\n@media (max-width: 1200px) {\n  .wp-admin.post-type-petitioner-petition .petitioner-settings-box .components-grid {\n    grid-template-columns: repeat(2, 1fr);\n  }\n}\n@media (max-width: 992px) {\n  .wp-admin.post-type-petitioner-petition .petitioner-settings-box .components-grid {\n    grid-template-columns: 1fr;\n  }\n}\n.wp-admin.post-type-petitioner-petition .text-ptr-red {\n  color: #e71845;\n}\n.wp-admin.post-type-petitioner-petition .ptr-action-buttons {\n  display: flex;\n  gap: 4px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-field-wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-field-panel {\n  width: 100%;\n  display: flex;\n  gap: 64px;\n  flex-wrap: wrap;\n  padding: 16px 0px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-field-panel label {\n  font-weight: bold;\n  display: block;\n  min-width: 100px;\n}\n.wp-admin.post-type-petitioner-petition .petition-tablink.components-tab-panel__tabs-item {\n  display: flex;\n  gap: 4px;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-tab {\n  display: none;\n}\n.wp-admin.post-type-petitioner-petition .petitioner-tab.active {\n  display: block;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field {\n  position: relative;\n  padding: var(--ptr-admin-spacing-md, 8px);\n  border-radius: 4px;\n  border: 1px dashed transparent;\n  transition: 0.15s;\n  transition-delay: 0;\n  background: white;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field--input, .wp-admin.post-type-petitioner-petition .ptr-fake-field--checkbox, .wp-admin.post-type-petitioner-petition .ptr-fake-field--content {\n  border: 1px solid transparent;\n  border-radius: 4px;\n  background-color: #fff;\n  font-size: 14px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field--checkbox {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  cursor: pointer;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field--checkbox input[type=checkbox] {\n  width: 16px;\n  height: 16px;\n  pointer-events: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field--checkbox label {\n  font-size: 14px;\n  margin-bottom: 0px;\n  pointer-events: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field--submit > button {\n  border-radius: var(--ptr-admin-input-border-radius, 4px);\n  background-color: var(--ptr-admin-color-primary, #000);\n  border-color: var(--ptr-admin-color-primary, #000);\n  color: white;\n  width: 100%;\n  min-height: 37px;\n  pointer-events: none;\n  outline: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field:hover {\n  cursor: pointer;\n}\n.wp-admin.post-type-petitioner-petition .ptr-fake-field:hover .ptr-actions, .wp-admin.post-type-petitioner-petition .ptr-fake-field--active .ptr-actions {\n  display: flex;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder .components-button {\n  width: 100%;\n  text-align: center;\n  justify-content: center;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form {\n  width: 70%;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form .ptr-visual-position {\n  width: 100%;\n  opacity: 0 !important;\n  height: 5px;\n  display: block;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form .ptr-visual-position.active {\n  background: var(--ptr-admin-color-primary, #000);\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form.is-dragging {\n  cursor: grabbing;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form.is-dragging .ptr-fake-field:hover {\n  border: 0px solid transparent;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form.is-dragging .ptr-actions {\n  display: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form.is-dragging .ptr-visual-position {\n  opacity: 1;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form-header {\n  padding: 16px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form-header h3,\n.wp-admin.post-type-petitioner-petition .ptr-form-builder__form-header p {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.wp-admin.post-type-petitioner-petition .ptr-actions {\n  position: absolute;\n  right: 4px;\n  display: none;\n  gap: 4px;\n  top: 2px;\n}\n.wp-admin.post-type-petitioner-petition .ptr-draggable {\n  opacity: 1;\n  position: relative;\n}\n.wp-admin.post-type-petitioner-petition .ptr-draggable:after {\n  position: absolute;\n  content: \"\";\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--ptr-admin-color-primary, #000);\n  border: 1px dashed var(--ptr-admin-color-primary, #000);\n  border-radius: var(--ptr-admin-input-border-radius, 4px);\n  opacity: 0;\n  transition: opacity 0.15s ease-in-out;\n  pointer-events: none;\n}\n.wp-admin.post-type-petitioner-petition .ptr-draggable--selected {\n  overflow: hidden;\n}\n.wp-admin.post-type-petitioner-petition .ptr-draggable--selected:after {\n  opacity: 0.05;\n}\n\n.ptr-color-picker__overlay {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  z-index: 1;\n}\n\n.ptr-hidden-fields {\n  display: none;\n}/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        function _mergeNamespaces(n, m) {
          for (var i = 0; i < m.length; i++) {
            const e = m[i];
            if (typeof e !== 'string' && !Array.isArray(e)) {
              for (const k in e) {
                if (k !== 'default' && !(k in n)) {
                  const d = Object.getOwnPropertyDescriptor(e, k);
                  if (d) {
                    Object.defineProperty(n, k, d.get ? d : {
                      enumerable: true,
                      get: () => e[k]
                    });
                  }
                }
              }
            }
          }
          return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, {
            value: 'Module'
          }));
        }
        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
        function getDefaultExportFromCjs(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }
        var jsxRuntime = {
          exports: {}
        };
        var reactJsxRuntime_production_min = {};
        var react = {
          exports: {}
        };
        var react_production_min = {};

        /**
         * @license React
         * react.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var l$3 = Symbol.for("react.element"),
          n$3 = Symbol.for("react.portal"),
          p$5 = Symbol.for("react.fragment"),
          q$4 = Symbol.for("react.strict_mode"),
          r$3 = Symbol.for("react.profiler"),
          t$2 = Symbol.for("react.provider"),
          u$2 = Symbol.for("react.context"),
          v$5 = Symbol.for("react.forward_ref"),
          w$3 = Symbol.for("react.suspense"),
          x$3 = Symbol.for("react.memo"),
          y$4 = Symbol.for("react.lazy"),
          z$4 = Symbol.iterator;
        function A$3(a) {
          if (null === a || "object" !== typeof a) return null;
          a = z$4 && a[z$4] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var B$3 = {
            isMounted: function () {
              return false;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {}
          },
          C$2 = Object.assign,
          D$2 = {};
        function E$1(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$2;
          this.updater = e || B$3;
        }
        E$1.prototype.isReactComponent = {};
        E$1.prototype.setState = function (a, b) {
          if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          this.updater.enqueueSetState(this, a, b, "setState");
        };
        E$1.prototype.forceUpdate = function (a) {
          this.updater.enqueueForceUpdate(this, a, "forceUpdate");
        };
        function F$2() {}
        F$2.prototype = E$1.prototype;
        function G$2(a, b, e) {
          this.props = a;
          this.context = b;
          this.refs = D$2;
          this.updater = e || B$3;
        }
        var H$3 = G$2.prototype = new F$2();
        H$3.constructor = G$2;
        C$2(H$3, E$1.prototype);
        H$3.isPureReactComponent = true;
        var I$3 = Array.isArray,
          J$2 = Object.prototype.hasOwnProperty,
          K$2 = {
            current: null
          },
          L$3 = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
        function M$3(a, b, e) {
          var d,
            c = {},
            k = null,
            h = null;
          if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J$2.call(b, d) && !L$3.hasOwnProperty(d) && (c[d] = b[d]);
          var g = arguments.length - 2;
          if (1 === g) c.children = e;else if (1 < g) {
            for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
            c.children = f;
          }
          if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
          return {
            $$typeof: l$3,
            type: a,
            key: k,
            ref: h,
            props: c,
            _owner: K$2.current
          };
        }
        function N$2(a, b) {
          return {
            $$typeof: l$3,
            type: a.type,
            key: b,
            ref: a.ref,
            props: a.props,
            _owner: a._owner
          };
        }
        function O$2(a) {
          return "object" === typeof a && null !== a && a.$$typeof === l$3;
        }
        function escape(a) {
          var b = {
            "=": "=0",
            ":": "=2"
          };
          return "$" + a.replace(/[=:]/g, function (a) {
            return b[a];
          });
        }
        var P$2 = /\/+/g;
        function Q$3(a, b) {
          return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
        }
        function R$2(a, b, e, d, c) {
          var k = typeof a;
          if ("undefined" === k || "boolean" === k) a = null;
          var h = false;
          if (null === a) h = true;else switch (k) {
            case "string":
            case "number":
              h = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case l$3:
                case n$3:
                  h = true;
              }
          }
          if (h) return h = a, c = c(h), a = "" === d ? "." + Q$3(h, 0) : d, I$3(c) ? (e = "", null != a && (e = a.replace(P$2, "$&/") + "/"), R$2(c, b, e, "", function (a) {
            return a;
          })) : null != c && (O$2(c) && (c = N$2(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$2, "$&/") + "/") + a)), b.push(c)), 1;
          h = 0;
          d = "" === d ? "." : d + ":";
          if (I$3(a)) for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = d + Q$3(k, g);
            h += R$2(k, b, e, f, c);
          } else if (f = A$3(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q$3(k, g++), h += R$2(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
          return h;
        }
        function S$4(a, b, e) {
          if (null == a) return a;
          var d = [],
            c = 0;
          R$2(a, d, "", "", function (a) {
            return b.call(e, a, c++);
          });
          return d;
        }
        function T$3(a) {
          if (-1 === a._status) {
            var b = a._result;
            b = b();
            b.then(function (b) {
              if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
            }, function (b) {
              if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
            });
            -1 === a._status && (a._status = 0, a._result = b);
          }
          if (1 === a._status) return a._result.default;
          throw a._result;
        }
        var U$3 = {
            current: null
          },
          V$4 = {
            transition: null
          },
          W$2 = {
            ReactCurrentDispatcher: U$3,
            ReactCurrentBatchConfig: V$4,
            ReactCurrentOwner: K$2
          };
        function X$2() {
          throw Error("act(...) is not supported in production builds of React.");
        }
        react_production_min.Children = {
          map: S$4,
          forEach: function (a, b, e) {
            S$4(a, function () {
              b.apply(this, arguments);
            }, e);
          },
          count: function (a) {
            var b = 0;
            S$4(a, function () {
              b++;
            });
            return b;
          },
          toArray: function (a) {
            return S$4(a, function (a) {
              return a;
            }) || [];
          },
          only: function (a) {
            if (!O$2(a)) throw Error("React.Children.only expected to receive a single React element child.");
            return a;
          }
        };
        react_production_min.Component = E$1;
        react_production_min.Fragment = p$5;
        react_production_min.Profiler = r$3;
        react_production_min.PureComponent = G$2;
        react_production_min.StrictMode = q$4;
        react_production_min.Suspense = w$3;
        react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
        react_production_min.act = X$2;
        react_production_min.cloneElement = function (a, b, e) {
          if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
          var d = C$2({}, a.props),
            c = a.key,
            k = a.ref,
            h = a._owner;
          if (null != b) {
            void 0 !== b.ref && (k = b.ref, h = K$2.current);
            void 0 !== b.key && (c = "" + b.key);
            if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
            for (f in b) J$2.call(b, f) && !L$3.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
          }
          var f = arguments.length - 2;
          if (1 === f) d.children = e;else if (1 < f) {
            g = Array(f);
            for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
            d.children = g;
          }
          return {
            $$typeof: l$3,
            type: a.type,
            key: c,
            ref: k,
            props: d,
            _owner: h
          };
        };
        react_production_min.createContext = function (a) {
          a = {
            $$typeof: u$2,
            _currentValue: a,
            _currentValue2: a,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          a.Provider = {
            $$typeof: t$2,
            _context: a
          };
          return a.Consumer = a;
        };
        react_production_min.createElement = M$3;
        react_production_min.createFactory = function (a) {
          var b = M$3.bind(null, a);
          b.type = a;
          return b;
        };
        react_production_min.createRef = function () {
          return {
            current: null
          };
        };
        react_production_min.forwardRef = function (a) {
          return {
            $$typeof: v$5,
            render: a
          };
        };
        react_production_min.isValidElement = O$2;
        react_production_min.lazy = function (a) {
          return {
            $$typeof: y$4,
            _payload: {
              _status: -1,
              _result: a
            },
            _init: T$3
          };
        };
        react_production_min.memo = function (a, b) {
          return {
            $$typeof: x$3,
            type: a,
            compare: void 0 === b ? null : b
          };
        };
        react_production_min.startTransition = function (a) {
          var b = V$4.transition;
          V$4.transition = {};
          try {
            a();
          } finally {
            V$4.transition = b;
          }
        };
        react_production_min.unstable_act = X$2;
        react_production_min.useCallback = function (a, b) {
          return U$3.current.useCallback(a, b);
        };
        react_production_min.useContext = function (a) {
          return U$3.current.useContext(a);
        };
        react_production_min.useDebugValue = function () {};
        react_production_min.useDeferredValue = function (a) {
          return U$3.current.useDeferredValue(a);
        };
        react_production_min.useEffect = function (a, b) {
          return U$3.current.useEffect(a, b);
        };
        react_production_min.useId = function () {
          return U$3.current.useId();
        };
        react_production_min.useImperativeHandle = function (a, b, e) {
          return U$3.current.useImperativeHandle(a, b, e);
        };
        react_production_min.useInsertionEffect = function (a, b) {
          return U$3.current.useInsertionEffect(a, b);
        };
        react_production_min.useLayoutEffect = function (a, b) {
          return U$3.current.useLayoutEffect(a, b);
        };
        react_production_min.useMemo = function (a, b) {
          return U$3.current.useMemo(a, b);
        };
        react_production_min.useReducer = function (a, b, e) {
          return U$3.current.useReducer(a, b, e);
        };
        react_production_min.useRef = function (a) {
          return U$3.current.useRef(a);
        };
        react_production_min.useState = function (a) {
          return U$3.current.useState(a);
        };
        react_production_min.useSyncExternalStore = function (a, b, e) {
          return U$3.current.useSyncExternalStore(a, b, e);
        };
        react_production_min.useTransition = function () {
          return U$3.current.useTransition();
        };
        react_production_min.version = "18.3.1";
        {
          react.exports = react_production_min;
        }
        var reactExports = react.exports;
        const React$1 = /*@__PURE__*/getDefaultExportFromCjs(reactExports);
        const React$2 = /*#__PURE__*/_mergeNamespaces({
          __proto__: null,
          default: React$1
        }, [reactExports]);

        /**
         * @license React
         * react-jsx-runtime.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var f$4 = reactExports,
          k$4 = Symbol.for("react.element"),
          l$2 = Symbol.for("react.fragment"),
          m$5 = Object.prototype.hasOwnProperty,
          n$2 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
          p$4 = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
        function q$3(c, a, g) {
          var b,
            d = {},
            e = null,
            h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m$5.call(a, b) && !p$4.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return {
            $$typeof: k$4,
            type: c,
            key: e,
            ref: h,
            props: d,
            _owner: n$2.current
          };
        }
        reactJsxRuntime_production_min.Fragment = l$2;
        reactJsxRuntime_production_min.jsx = q$3;
        reactJsxRuntime_production_min.jsxs = q$3;
        {
          jsxRuntime.exports = reactJsxRuntime_production_min;
        }
        var jsxRuntimeExports = jsxRuntime.exports;
        var reactDom = {
          exports: {}
        };
        var reactDom_production_min = {};
        var scheduler = {
          exports: {}
        };
        var scheduler_production_min = {};

        /**
         * @license React
         * scheduler.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        (function (exports) {
          function f(a, b) {
            var c = a.length;
            a.push(b);
            a: for (; 0 < c;) {
              var d = c - 1 >>> 1,
                e = a[d];
              if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;else break a;
            }
          }
          function h(a) {
            return 0 === a.length ? null : a[0];
          }
          function k(a) {
            if (0 === a.length) return null;
            var b = a[0],
              c = a.pop();
            if (c !== b) {
              a[0] = c;
              a: for (var d = 0, e = a.length, w = e >>> 1; d < w;) {
                var m = 2 * (d + 1) - 1,
                  C = a[m],
                  n = m + 1,
                  x = a[n];
                if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;else break a;
              }
            }
            return b;
          }
          function g(a, b) {
            var c = a.sortIndex - b.sortIndex;
            return 0 !== c ? c : a.id - b.id;
          }
          if ("object" === typeof performance && "function" === typeof performance.now) {
            var l = performance;
            exports.unstable_now = function () {
              return l.now();
            };
          } else {
            var p = Date,
              q = p.now();
            exports.unstable_now = function () {
              return p.now() - q;
            };
          }
          var r = [],
            t = [],
            u = 1,
            v = null,
            y = 3,
            z = false,
            A = false,
            B = false,
            D = "function" === typeof setTimeout ? setTimeout : null,
            E = "function" === typeof clearTimeout ? clearTimeout : null,
            F = "undefined" !== typeof setImmediate ? setImmediate : null;
          "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
          function G(a) {
            for (var b = h(t); null !== b;) {
              if (null === b.callback) k(t);else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);else break;
              b = h(t);
            }
          }
          function H(a) {
            B = false;
            G(a);
            if (!A) if (null !== h(r)) A = true, I(J);else {
              var b = h(t);
              null !== b && K(H, b.startTime - a);
            }
          }
          function J(a, b) {
            A = false;
            B && (B = false, E(L), L = -1);
            z = true;
            var c = y;
            try {
              G(b);
              for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M());) {
                var d = v.callback;
                if ("function" === typeof d) {
                  v.callback = null;
                  y = v.priorityLevel;
                  var e = d(v.expirationTime <= b);
                  b = exports.unstable_now();
                  "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                  G(b);
                } else k(r);
                v = h(r);
              }
              if (null !== v) var w = !0;else {
                var m = h(t);
                null !== m && K(H, m.startTime - b);
                w = !1;
              }
              return w;
            } finally {
              v = null, y = c, z = false;
            }
          }
          var N = false,
            O = null,
            L = -1,
            P = 5,
            Q = -1;
          function M() {
            return exports.unstable_now() - Q < P ? false : true;
          }
          function R() {
            if (null !== O) {
              var a = exports.unstable_now();
              Q = a;
              var b = true;
              try {
                b = O(!0, a);
              } finally {
                b ? S() : (N = false, O = null);
              }
            } else N = false;
          }
          var S;
          if ("function" === typeof F) S = function () {
            F(R);
          };else if ("undefined" !== typeof MessageChannel) {
            var T = new MessageChannel(),
              U = T.port2;
            T.port1.onmessage = R;
            S = function () {
              U.postMessage(null);
            };
          } else S = function () {
            D(R, 0);
          };
          function I(a) {
            O = a;
            N || (N = true, S());
          }
          function K(a, b) {
            L = D(function () {
              a(exports.unstable_now());
            }, b);
          }
          exports.unstable_IdlePriority = 5;
          exports.unstable_ImmediatePriority = 1;
          exports.unstable_LowPriority = 4;
          exports.unstable_NormalPriority = 3;
          exports.unstable_Profiling = null;
          exports.unstable_UserBlockingPriority = 2;
          exports.unstable_cancelCallback = function (a) {
            a.callback = null;
          };
          exports.unstable_continueExecution = function () {
            A || z || (A = true, I(J));
          };
          exports.unstable_forceFrameRate = function (a) {
            0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1E3 / a) : 5;
          };
          exports.unstable_getCurrentPriorityLevel = function () {
            return y;
          };
          exports.unstable_getFirstCallbackNode = function () {
            return h(r);
          };
          exports.unstable_next = function (a) {
            switch (y) {
              case 1:
              case 2:
              case 3:
                var b = 3;
                break;
              default:
                b = y;
            }
            var c = y;
            y = b;
            try {
              return a();
            } finally {
              y = c;
            }
          };
          exports.unstable_pauseExecution = function () {};
          exports.unstable_requestPaint = function () {};
          exports.unstable_runWithPriority = function (a, b) {
            switch (a) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                a = 3;
            }
            var c = y;
            y = a;
            try {
              return b();
            } finally {
              y = c;
            }
          };
          exports.unstable_scheduleCallback = function (a, b, c) {
            var d = exports.unstable_now();
            "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
            switch (a) {
              case 1:
                var e = -1;
                break;
              case 2:
                e = 250;
                break;
              case 5:
                e = 1073741823;
                break;
              case 4:
                e = 1E4;
                break;
              default:
                e = 5E3;
            }
            e = c + e;
            a = {
              id: u++,
              callback: b,
              priorityLevel: a,
              startTime: c,
              expirationTime: e,
              sortIndex: -1
            };
            c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
            return a;
          };
          exports.unstable_shouldYield = M;
          exports.unstable_wrapCallback = function (a) {
            var b = y;
            return function () {
              var c = y;
              y = b;
              try {
                return a.apply(this, arguments);
              } finally {
                y = c;
              }
            };
          };
        })(scheduler_production_min);
        {
          scheduler.exports = scheduler_production_min;
        }
        var schedulerExports = scheduler.exports;

        /**
         * @license React
         * react-dom.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var aa = reactExports,
          ca = schedulerExports;
        function p$3(a) {
          for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
          return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var da = new Set(),
          ea = {};
        function fa(a, b) {
          ha(a, b);
          ha(a + "Capture", b);
        }
        function ha(a, b) {
          ea[a] = b;
          for (a = 0; a < b.length; a++) da.add(b[a]);
        }
        var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
          ja = Object.prototype.hasOwnProperty,
          ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
          la = {},
          ma = {};
        function oa(a) {
          if (ja.call(ma, a)) return true;
          if (ja.call(la, a)) return false;
          if (ka.test(a)) return ma[a] = true;
          la[a] = true;
          return false;
        }
        function pa(a, b, c, d) {
          if (null !== c && 0 === c.type) return false;
          switch (typeof b) {
            case "function":
            case "symbol":
              return true;
            case "boolean":
              if (d) return false;
              if (null !== c) return !c.acceptsBooleans;
              a = a.toLowerCase().slice(0, 5);
              return "data-" !== a && "aria-" !== a;
            default:
              return false;
          }
        }
        function qa(a, b, c, d) {
          if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
          if (d) return false;
          if (null !== c) switch (c.type) {
            case 3:
              return !b;
            case 4:
              return false === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
          return false;
        }
        function v$4(a, b, c, d, e, f, g) {
          this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
          this.attributeName = d;
          this.attributeNamespace = e;
          this.mustUseProperty = c;
          this.propertyName = a;
          this.type = b;
          this.sanitizeURL = f;
          this.removeEmptyString = g;
        }
        var z$3 = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
          z$3[a] = new v$4(a, 0, false, a, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
          var b = a[0];
          z$3[b] = new v$4(b, 1, false, a[1], null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
          z$3[a] = new v$4(a, 2, false, a.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
          z$3[a] = new v$4(a, 2, false, a, null, false, false);
        });
        "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
          z$3[a] = new v$4(a, 3, false, a.toLowerCase(), null, false, false);
        });
        ["checked", "multiple", "muted", "selected"].forEach(function (a) {
          z$3[a] = new v$4(a, 3, true, a, null, false, false);
        });
        ["capture", "download"].forEach(function (a) {
          z$3[a] = new v$4(a, 4, false, a, null, false, false);
        });
        ["cols", "rows", "size", "span"].forEach(function (a) {
          z$3[a] = new v$4(a, 6, false, a, null, false, false);
        });
        ["rowSpan", "start"].forEach(function (a) {
          z$3[a] = new v$4(a, 5, false, a.toLowerCase(), null, false, false);
        });
        var ra = /[\-:]([a-z])/g;
        function sa(a) {
          return a[1].toUpperCase();
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$4(b, 1, false, a, null, false, false);
        });
        "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$4(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
        });
        ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
          var b = a.replace(ra, sa);
          z$3[b] = new v$4(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function (a) {
          z$3[a] = new v$4(a, 1, false, a.toLowerCase(), null, false, false);
        });
        z$3.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function (a) {
          z$3[a] = new v$4(a, 1, false, a.toLowerCase(), null, true, true);
        });
        function ta(a, b, c, d) {
          var e = z$3.hasOwnProperty(b) ? z$3[b] : null;
          if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
        }
        var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          va = Symbol.for("react.element"),
          wa = Symbol.for("react.portal"),
          ya = Symbol.for("react.fragment"),
          za = Symbol.for("react.strict_mode"),
          Aa = Symbol.for("react.profiler"),
          Ba = Symbol.for("react.provider"),
          Ca = Symbol.for("react.context"),
          Da = Symbol.for("react.forward_ref"),
          Ea = Symbol.for("react.suspense"),
          Fa = Symbol.for("react.suspense_list"),
          Ga = Symbol.for("react.memo"),
          Ha = Symbol.for("react.lazy");
        var Ia = Symbol.for("react.offscreen");
        var Ja = Symbol.iterator;
        function Ka(a) {
          if (null === a || "object" !== typeof a) return null;
          a = Ja && a[Ja] || a["@@iterator"];
          return "function" === typeof a ? a : null;
        }
        var A$2 = Object.assign,
          La;
        function Ma(a) {
          if (void 0 === La) try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            La = b && b[1] || "";
          }
          return "\n" + La + a;
        }
        var Na = false;
        function Oa(a, b) {
          if (!a || Na) return "";
          Na = true;
          var c = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (b) {
              if (b = function () {
                throw Error();
              }, Object.defineProperty(b.prototype, "props", {
                set: function () {
                  throw Error();
                }
              }), "object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(b, []);
                } catch (l) {
                  var d = l;
                }
                Reflect.construct(a, [], b);
              } else {
                try {
                  b.call();
                } catch (l) {
                  d = l;
                }
                a.call(b.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (l) {
                d = l;
              }
              a();
            }
          } catch (l) {
            if (l && d && "string" === typeof l.stack) {
              for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;
              for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  } while (1 <= g && 0 <= h);
                }
                break;
              }
            }
          } finally {
            Na = false, Error.prepareStackTrace = c;
          }
          return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
        }
        function Pa(a) {
          switch (a.tag) {
            case 5:
              return Ma(a.type);
            case 16:
              return Ma("Lazy");
            case 13:
              return Ma("Suspense");
            case 19:
              return Ma("SuspenseList");
            case 0:
            case 2:
            case 15:
              return a = Oa(a.type, false), a;
            case 11:
              return a = Oa(a.type.render, false), a;
            case 1:
              return a = Oa(a.type, true), a;
            default:
              return "";
          }
        }
        function Qa(a) {
          if (null == a) return null;
          if ("function" === typeof a) return a.displayName || a.name || null;
          if ("string" === typeof a) return a;
          switch (a) {
            case ya:
              return "Fragment";
            case wa:
              return "Portal";
            case Aa:
              return "Profiler";
            case za:
              return "StrictMode";
            case Ea:
              return "Suspense";
            case Fa:
              return "SuspenseList";
          }
          if ("object" === typeof a) switch (a.$$typeof) {
            case Ca:
              return (a.displayName || "Context") + ".Consumer";
            case Ba:
              return (a._context.displayName || "Context") + ".Provider";
            case Da:
              var b = a.render;
              a = a.displayName;
              a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
              return a;
            case Ga:
              return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
            case Ha:
              b = a._payload;
              a = a._init;
              try {
                return Qa(a(b));
              } catch (c) {}
          }
          return null;
        }
        function Ra(a) {
          var b = a.type;
          switch (a.tag) {
            case 24:
              return "Cache";
            case 9:
              return (b.displayName || "Context") + ".Consumer";
            case 10:
              return (b._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 5:
              return b;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return Qa(b);
            case 8:
              return b === za ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if ("function" === typeof b) return b.displayName || b.name || null;
              if ("string" === typeof b) return b;
          }
          return null;
        }
        function Sa(a) {
          switch (typeof a) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return a;
            case "object":
              return a;
            default:
              return "";
          }
        }
        function Ta(a) {
          var b = a.type;
          return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
        }
        function Ua(a) {
          var b = Ta(a) ? "checked" : "value",
            c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
            d = "" + a[b];
          if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
            var e = c.get,
              f = c.set;
            Object.defineProperty(a, b, {
              configurable: true,
              get: function () {
                return e.call(this);
              },
              set: function (a) {
                d = "" + a;
                f.call(this, a);
              }
            });
            Object.defineProperty(a, b, {
              enumerable: c.enumerable
            });
            return {
              getValue: function () {
                return d;
              },
              setValue: function (a) {
                d = "" + a;
              },
              stopTracking: function () {
                a._valueTracker = null;
                delete a[b];
              }
            };
          }
        }
        function Va(a) {
          a._valueTracker || (a._valueTracker = Ua(a));
        }
        function Wa(a) {
          if (!a) return false;
          var b = a._valueTracker;
          if (!b) return true;
          var c = b.getValue();
          var d = "";
          a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
          a = d;
          return a !== c ? (b.setValue(a), true) : false;
        }
        function Xa(a) {
          a = a || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof a) return null;
          try {
            return a.activeElement || a.body;
          } catch (b) {
            return a.body;
          }
        }
        function Ya(a, b) {
          var c = b.checked;
          return A$2({}, b, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != c ? c : a._wrapperState.initialChecked
          });
        }
        function Za(a, b) {
          var c = null == b.defaultValue ? "" : b.defaultValue,
            d = null != b.checked ? b.checked : b.defaultChecked;
          c = Sa(null != b.value ? b.value : c);
          a._wrapperState = {
            initialChecked: d,
            initialValue: c,
            controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
          };
        }
        function ab(a, b) {
          b = b.checked;
          null != b && ta(a, "checked", b, false);
        }
        function bb(a, b) {
          ab(a, b);
          var c = Sa(b.value),
            d = b.type;
          if (null != c) {
            if ("number" === d) {
              if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
            } else a.value !== "" + c && (a.value = "" + c);
          } else if ("submit" === d || "reset" === d) {
            a.removeAttribute("value");
            return;
          }
          b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
          null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
        }
        function db(a, b, c) {
          if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
            var d = b.type;
            if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
            b = "" + a._wrapperState.initialValue;
            c || b === a.value || (a.value = b);
            a.defaultValue = b;
          }
          c = a.name;
          "" !== c && (a.name = "");
          a.defaultChecked = !!a._wrapperState.initialChecked;
          "" !== c && (a.name = c);
        }
        function cb(a, b, c) {
          if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
        }
        var eb = Array.isArray;
        function fb(a, b, c, d) {
          a = a.options;
          if (b) {
            b = {};
            for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
            for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
          } else {
            c = "" + Sa(c);
            b = null;
            for (e = 0; e < a.length; e++) {
              if (a[e].value === c) {
                a[e].selected = true;
                d && (a[e].defaultSelected = true);
                return;
              }
              null !== b || a[e].disabled || (b = a[e]);
            }
            null !== b && (b.selected = true);
          }
        }
        function gb(a, b) {
          if (null != b.dangerouslySetInnerHTML) throw Error(p$3(91));
          return A$2({}, b, {
            value: void 0,
            defaultValue: void 0,
            children: "" + a._wrapperState.initialValue
          });
        }
        function hb(a, b) {
          var c = b.value;
          if (null == c) {
            c = b.children;
            b = b.defaultValue;
            if (null != c) {
              if (null != b) throw Error(p$3(92));
              if (eb(c)) {
                if (1 < c.length) throw Error(p$3(93));
                c = c[0];
              }
              b = c;
            }
            null == b && (b = "");
            c = b;
          }
          a._wrapperState = {
            initialValue: Sa(c)
          };
        }
        function ib(a, b) {
          var c = Sa(b.value),
            d = Sa(b.defaultValue);
          null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
          null != d && (a.defaultValue = "" + d);
        }
        function jb(a) {
          var b = a.textContent;
          b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
        }
        function kb(a) {
          switch (a) {
            case "svg":
              return "http://www.w3.org/2000/svg";
            case "math":
              return "http://www.w3.org/1998/Math/MathML";
            default:
              return "http://www.w3.org/1999/xhtml";
          }
        }
        function lb(a, b) {
          return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
        }
        var mb,
          nb = function (a) {
            return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
              MSApp.execUnsafeLocalFunction(function () {
                return a(b, c, d, e);
              });
            } : a;
          }(function (a, b) {
            if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;else {
              mb = mb || document.createElement("div");
              mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
              for (b = mb.firstChild; a.firstChild;) a.removeChild(a.firstChild);
              for (; b.firstChild;) a.appendChild(b.firstChild);
            }
          });
        function ob(a, b) {
          if (b) {
            var c = a.firstChild;
            if (c && c === a.lastChild && 3 === c.nodeType) {
              c.nodeValue = b;
              return;
            }
          }
          a.textContent = b;
        }
        var pb = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          },
          qb = ["Webkit", "ms", "Moz", "O"];
        Object.keys(pb).forEach(function (a) {
          qb.forEach(function (b) {
            b = b + a.charAt(0).toUpperCase() + a.substring(1);
            pb[b] = pb[a];
          });
        });
        function rb(a, b, c) {
          return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
        }
        function sb(a, b) {
          a = a.style;
          for (var c in b) if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"),
              e = rb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
          }
        }
        var tb = A$2({
          menuitem: true
        }, {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        });
        function ub(a, b) {
          if (b) {
            if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p$3(137, a));
            if (null != b.dangerouslySetInnerHTML) {
              if (null != b.children) throw Error(p$3(60));
              if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p$3(61));
            }
            if (null != b.style && "object" !== typeof b.style) throw Error(p$3(62));
          }
        }
        function vb(a, b) {
          if (-1 === a.indexOf("-")) return "string" === typeof b.is;
          switch (a) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var wb = null;
        function xb(a) {
          a = a.target || a.srcElement || window;
          a.correspondingUseElement && (a = a.correspondingUseElement);
          return 3 === a.nodeType ? a.parentNode : a;
        }
        var yb = null,
          zb = null,
          Ab = null;
        function Bb(a) {
          if (a = Cb(a)) {
            if ("function" !== typeof yb) throw Error(p$3(280));
            var b = a.stateNode;
            b && (b = Db(b), yb(a.stateNode, a.type, b));
          }
        }
        function Eb(a) {
          zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
        }
        function Fb() {
          if (zb) {
            var a = zb,
              b = Ab;
            Ab = zb = null;
            Bb(a);
            if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
          }
        }
        function Gb(a, b) {
          return a(b);
        }
        function Hb() {}
        var Ib = false;
        function Jb(a, b, c) {
          if (Ib) return a(b, c);
          Ib = true;
          try {
            return Gb(a, b, c);
          } finally {
            if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
          }
        }
        function Kb(a, b) {
          var c = a.stateNode;
          if (null === c) return null;
          var d = Db(c);
          if (null === d) return null;
          c = d[b];
          a: switch (b) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
              a = !d;
              break a;
            default:
              a = false;
          }
          if (a) return null;
          if (c && "function" !== typeof c) throw Error(p$3(231, b, typeof c));
          return c;
        }
        var Lb = false;
        if (ia) try {
          var Mb = {};
          Object.defineProperty(Mb, "passive", {
            get: function () {
              Lb = !0;
            }
          });
          window.addEventListener("test", Mb, Mb);
          window.removeEventListener("test", Mb, Mb);
        } catch (a) {
          Lb = false;
        }
        function Nb(a, b, c, d, e, f, g, h, k) {
          var l = Array.prototype.slice.call(arguments, 3);
          try {
            b.apply(c, l);
          } catch (m) {
            this.onError(m);
          }
        }
        var Ob = false,
          Pb = null,
          Qb = false,
          Rb = null,
          Sb = {
            onError: function (a) {
              Ob = true;
              Pb = a;
            }
          };
        function Tb(a, b, c, d, e, f, g, h, k) {
          Ob = false;
          Pb = null;
          Nb.apply(Sb, arguments);
        }
        function Ub(a, b, c, d, e, f, g, h, k) {
          Tb.apply(this, arguments);
          if (Ob) {
            if (Ob) {
              var l = Pb;
              Ob = false;
              Pb = null;
            } else throw Error(p$3(198));
            Qb || (Qb = true, Rb = l);
          }
        }
        function Vb(a) {
          var b = a,
            c = a;
          if (a.alternate) for (; b.return;) b = b.return;else {
            a = b;
            do b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return; while (a);
          }
          return 3 === b.tag ? c : null;
        }
        function Wb(a) {
          if (13 === a.tag) {
            var b = a.memoizedState;
            null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
            if (null !== b) return b.dehydrated;
          }
          return null;
        }
        function Xb(a) {
          if (Vb(a) !== a) throw Error(p$3(188));
        }
        function Yb(a) {
          var b = a.alternate;
          if (!b) {
            b = Vb(a);
            if (null === b) throw Error(p$3(188));
            return b !== a ? null : a;
          }
          for (var c = a, d = b;;) {
            var e = c.return;
            if (null === e) break;
            var f = e.alternate;
            if (null === f) {
              d = e.return;
              if (null !== d) {
                c = d;
                continue;
              }
              break;
            }
            if (e.child === f.child) {
              for (f = e.child; f;) {
                if (f === c) return Xb(e), a;
                if (f === d) return Xb(e), b;
                f = f.sibling;
              }
              throw Error(p$3(188));
            }
            if (c.return !== d.return) c = e, d = f;else {
              for (var g = false, h = e.child; h;) {
                if (h === c) {
                  g = true;
                  c = e;
                  d = f;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = e;
                  c = f;
                  break;
                }
                h = h.sibling;
              }
              if (!g) {
                for (h = f.child; h;) {
                  if (h === c) {
                    g = true;
                    c = f;
                    d = e;
                    break;
                  }
                  if (h === d) {
                    g = true;
                    d = f;
                    c = e;
                    break;
                  }
                  h = h.sibling;
                }
                if (!g) throw Error(p$3(189));
              }
            }
            if (c.alternate !== d) throw Error(p$3(190));
          }
          if (3 !== c.tag) throw Error(p$3(188));
          return c.stateNode.current === c ? a : b;
        }
        function Zb(a) {
          a = Yb(a);
          return null !== a ? $b(a) : null;
        }
        function $b(a) {
          if (5 === a.tag || 6 === a.tag) return a;
          for (a = a.child; null !== a;) {
            var b = $b(a);
            if (null !== b) return b;
            a = a.sibling;
          }
          return null;
        }
        var ac = ca.unstable_scheduleCallback,
          bc = ca.unstable_cancelCallback,
          cc = ca.unstable_shouldYield,
          dc = ca.unstable_requestPaint,
          B$2 = ca.unstable_now,
          ec = ca.unstable_getCurrentPriorityLevel,
          fc = ca.unstable_ImmediatePriority,
          gc = ca.unstable_UserBlockingPriority,
          hc = ca.unstable_NormalPriority,
          ic = ca.unstable_LowPriority,
          jc = ca.unstable_IdlePriority,
          kc = null,
          lc = null;
        function mc(a) {
          if (lc && "function" === typeof lc.onCommitFiberRoot) try {
            lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
          } catch (b) {}
        }
        var oc = Math.clz32 ? Math.clz32 : nc,
          pc = Math.log,
          qc = Math.LN2;
        function nc(a) {
          a >>>= 0;
          return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
        }
        var rc = 64,
          sc = 4194304;
        function tc(a) {
          switch (a & -a) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return a & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return a & 130023424;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return a;
          }
        }
        function uc(a, b) {
          var c = a.pendingLanes;
          if (0 === c) return 0;
          var d = 0,
            e = a.suspendedLanes,
            f = a.pingedLanes,
            g = c & 268435455;
          if (0 !== g) {
            var h = g & ~e;
            0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
          } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
          if (0 === d) return 0;
          if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
          0 !== (d & 4) && (d |= c & 16);
          b = a.entangledLanes;
          if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
          return d;
        }
        function vc(a, b) {
          switch (a) {
            case 1:
            case 2:
            case 4:
              return b + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return b + 5E3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return -1;
          }
        }
        function wc(a, b) {
          for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f;) {
            var g = 31 - oc(f),
              h = 1 << g,
              k = e[g];
            if (-1 === k) {
              if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
            } else k <= b && (a.expiredLanes |= h);
            f &= ~h;
          }
        }
        function xc(a) {
          a = a.pendingLanes & -1073741825;
          return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
        }
        function yc() {
          var a = rc;
          rc <<= 1;
          0 === (rc & 4194240) && (rc = 64);
          return a;
        }
        function zc(a) {
          for (var b = [], c = 0; 31 > c; c++) b.push(a);
          return b;
        }
        function Ac(a, b, c) {
          a.pendingLanes |= b;
          536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
          a = a.eventTimes;
          b = 31 - oc(b);
          a[b] = c;
        }
        function Bc(a, b) {
          var c = a.pendingLanes & ~b;
          a.pendingLanes = b;
          a.suspendedLanes = 0;
          a.pingedLanes = 0;
          a.expiredLanes &= b;
          a.mutableReadLanes &= b;
          a.entangledLanes &= b;
          b = a.entanglements;
          var d = a.eventTimes;
          for (a = a.expirationTimes; 0 < c;) {
            var e = 31 - oc(c),
              f = 1 << e;
            b[e] = 0;
            d[e] = -1;
            a[e] = -1;
            c &= ~f;
          }
        }
        function Cc(a, b) {
          var c = a.entangledLanes |= b;
          for (a = a.entanglements; c;) {
            var d = 31 - oc(c),
              e = 1 << d;
            e & b | a[d] & b && (a[d] |= b);
            c &= ~e;
          }
        }
        var C$1 = 0;
        function Dc(a) {
          a &= -a;
          return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
        }
        var Ec,
          Fc,
          Gc,
          Hc,
          Ic,
          Jc = false,
          Kc = [],
          Lc = null,
          Mc = null,
          Nc = null,
          Oc = new Map(),
          Pc = new Map(),
          Qc = [],
          Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
        function Sc(a, b) {
          switch (a) {
            case "focusin":
            case "focusout":
              Lc = null;
              break;
            case "dragenter":
            case "dragleave":
              Mc = null;
              break;
            case "mouseover":
            case "mouseout":
              Nc = null;
              break;
            case "pointerover":
            case "pointerout":
              Oc.delete(b.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              Pc.delete(b.pointerId);
          }
        }
        function Tc(a, b, c, d, e, f) {
          if (null === a || a.nativeEvent !== f) return a = {
            blockedOn: b,
            domEventName: c,
            eventSystemFlags: d,
            nativeEvent: f,
            targetContainers: [e]
          }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
          a.eventSystemFlags |= d;
          b = a.targetContainers;
          null !== e && -1 === b.indexOf(e) && b.push(e);
          return a;
        }
        function Uc(a, b, c, d, e) {
          switch (b) {
            case "focusin":
              return Lc = Tc(Lc, a, b, c, d, e), true;
            case "dragenter":
              return Mc = Tc(Mc, a, b, c, d, e), true;
            case "mouseover":
              return Nc = Tc(Nc, a, b, c, d, e), true;
            case "pointerover":
              var f = e.pointerId;
              Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
              return true;
            case "gotpointercapture":
              return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
          }
          return false;
        }
        function Vc(a) {
          var b = Wc(a.target);
          if (null !== b) {
            var c = Vb(b);
            if (null !== c) if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function () {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
          a.blockedOn = null;
        }
        function Xc(a) {
          if (null !== a.blockedOn) return false;
          for (var b = a.targetContainers; 0 < b.length;) {
            var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null === c) {
              c = a.nativeEvent;
              var d = new c.constructor(c.type, c);
              wb = d;
              c.target.dispatchEvent(d);
              wb = null;
            } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
            b.shift();
          }
          return true;
        }
        function Zc(a, b, c) {
          Xc(a) && c.delete(b);
        }
        function $c() {
          Jc = false;
          null !== Lc && Xc(Lc) && (Lc = null);
          null !== Mc && Xc(Mc) && (Mc = null);
          null !== Nc && Xc(Nc) && (Nc = null);
          Oc.forEach(Zc);
          Pc.forEach(Zc);
        }
        function ad(a, b) {
          a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
        }
        function bd(a) {
          function b(b) {
            return ad(b, a);
          }
          if (0 < Kc.length) {
            ad(Kc[0], a);
            for (var c = 1; c < Kc.length; c++) {
              var d = Kc[c];
              d.blockedOn === a && (d.blockedOn = null);
            }
          }
          null !== Lc && ad(Lc, a);
          null !== Mc && ad(Mc, a);
          null !== Nc && ad(Nc, a);
          Oc.forEach(b);
          Pc.forEach(b);
          for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
          for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn);) Vc(c), null === c.blockedOn && Qc.shift();
        }
        var cd = ua.ReactCurrentBatchConfig,
          dd = true;
        function ed(a, b, c, d) {
          var e = C$1,
            f = cd.transition;
          cd.transition = null;
          try {
            C$1 = 1, fd(a, b, c, d);
          } finally {
            C$1 = e, cd.transition = f;
          }
        }
        function gd(a, b, c, d) {
          var e = C$1,
            f = cd.transition;
          cd.transition = null;
          try {
            C$1 = 4, fd(a, b, c, d);
          } finally {
            C$1 = e, cd.transition = f;
          }
        }
        function fd(a, b, c, d) {
          if (dd) {
            var e = Yc(a, b, c, d);
            if (null === e) hd(a, b, d, id, c), Sc(a, d);else if (Uc(e, a, b, c, d)) d.stopPropagation();else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
              for (; null !== e;) {
                var f = Cb(e);
                null !== f && Ec(f);
                f = Yc(a, b, c, d);
                null === f && hd(a, b, d, id, c);
                if (f === e) break;
                e = f;
              }
              null !== e && d.stopPropagation();
            } else hd(a, b, d, null, c);
          }
        }
        var id = null;
        function Yc(a, b, c, d) {
          id = null;
          a = xb(d);
          a = Wc(a);
          if (null !== a) if (b = Vb(a), null === b) a = null;else if (c = b.tag, 13 === c) {
            a = Wb(b);
            if (null !== a) return a;
            a = null;
          } else if (3 === c) {
            if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
            a = null;
          } else b !== a && (a = null);
          id = a;
          return null;
        }
        function jd(a) {
          switch (a) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 4;
            case "message":
              switch (ec()) {
                case fc:
                  return 1;
                case gc:
                  return 4;
                case hc:
                case ic:
                  return 16;
                case jc:
                  return 536870912;
                default:
                  return 16;
              }
            default:
              return 16;
          }
        }
        var kd = null,
          ld = null,
          md = null;
        function nd() {
          if (md) return md;
          var a,
            b = ld,
            c = b.length,
            d,
            e = "value" in kd ? kd.value : kd.textContent,
            f = e.length;
          for (a = 0; a < c && b[a] === e[a]; a++);
          var g = c - a;
          for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
          return md = e.slice(a, 1 < d ? 1 - d : void 0);
        }
        function od(a) {
          var b = a.keyCode;
          "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
          10 === a && (a = 13);
          return 32 <= a || 13 === a ? a : 0;
        }
        function pd() {
          return true;
        }
        function qd() {
          return false;
        }
        function rd(a) {
          function b(b, d, e, f, g) {
            this._reactName = b;
            this._targetInst = e;
            this.type = d;
            this.nativeEvent = f;
            this.target = g;
            this.currentTarget = null;
            for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
            this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
            this.isPropagationStopped = qd;
            return this;
          }
          A$2(b.prototype, {
            preventDefault: function () {
              this.defaultPrevented = true;
              var a = this.nativeEvent;
              a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = false), this.isDefaultPrevented = pd);
            },
            stopPropagation: function () {
              var a = this.nativeEvent;
              a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = true), this.isPropagationStopped = pd);
            },
            persist: function () {},
            isPersistent: pd
          });
          return b;
        }
        var sd = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (a) {
              return a.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          },
          td = rd(sd),
          ud = A$2({}, sd, {
            view: 0,
            detail: 0
          }),
          vd = rd(ud),
          wd,
          xd,
          yd,
          Ad = A$2({}, ud, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: zd,
            button: 0,
            buttons: 0,
            relatedTarget: function (a) {
              return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
            },
            movementX: function (a) {
              if ("movementX" in a) return a.movementX;
              a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
              return wd;
            },
            movementY: function (a) {
              return "movementY" in a ? a.movementY : xd;
            }
          }),
          Bd = rd(Ad),
          Cd = A$2({}, Ad, {
            dataTransfer: 0
          }),
          Dd = rd(Cd),
          Ed = A$2({}, ud, {
            relatedTarget: 0
          }),
          Fd = rd(Ed),
          Gd = A$2({}, sd, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Hd = rd(Gd),
          Id = A$2({}, sd, {
            clipboardData: function (a) {
              return "clipboardData" in a ? a.clipboardData : window.clipboardData;
            }
          }),
          Jd = rd(Id),
          Kd = A$2({}, sd, {
            data: 0
          }),
          Ld = rd(Kd),
          Md = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          },
          Nd = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
          },
          Od = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
        function Pd(a) {
          var b = this.nativeEvent;
          return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
        }
        function zd() {
          return Pd;
        }
        var Qd = A$2({}, ud, {
            key: function (a) {
              if (a.key) {
                var b = Md[a.key] || a.key;
                if ("Unidentified" !== b) return b;
              }
              return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: zd,
            charCode: function (a) {
              return "keypress" === a.type ? od(a) : 0;
            },
            keyCode: function (a) {
              return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            },
            which: function (a) {
              return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            }
          }),
          Rd = rd(Qd),
          Sd = A$2({}, Ad, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          }),
          Td = rd(Sd),
          Ud = A$2({}, ud, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: zd
          }),
          Vd = rd(Ud),
          Wd = A$2({}, sd, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          }),
          Xd = rd(Wd),
          Yd = A$2({}, Ad, {
            deltaX: function (a) {
              return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
            },
            deltaY: function (a) {
              return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          }),
          Zd = rd(Yd),
          $d = [9, 13, 27, 32],
          ae$1 = ia && "CompositionEvent" in window,
          be$1 = null;
        ia && "documentMode" in document && (be$1 = document.documentMode);
        var ce$1 = ia && "TextEvent" in window && !be$1,
          de = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1),
          ee$2 = String.fromCharCode(32),
          fe$1 = false;
        function ge$1(a, b) {
          switch (a) {
            case "keyup":
              return -1 !== $d.indexOf(b.keyCode);
            case "keydown":
              return 229 !== b.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function he$1(a) {
          a = a.detail;
          return "object" === typeof a && "data" in a ? a.data : null;
        }
        var ie$1 = false;
        function je$1(a, b) {
          switch (a) {
            case "compositionend":
              return he$1(b);
            case "keypress":
              if (32 !== b.which) return null;
              fe$1 = true;
              return ee$2;
            case "textInput":
              return a = b.data, a === ee$2 && fe$1 ? null : a;
            default:
              return null;
          }
        }
        function ke$1(a, b) {
          if (ie$1) return "compositionend" === a || !ae$1 && ge$1(a, b) ? (a = nd(), md = ld = kd = null, ie$1 = false, a) : null;
          switch (a) {
            case "paste":
              return null;
            case "keypress":
              if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                if (b.char && 1 < b.char.length) return b.char;
                if (b.which) return String.fromCharCode(b.which);
              }
              return null;
            case "compositionend":
              return de && "ko" !== b.locale ? null : b.data;
            default:
              return null;
          }
        }
        var le$1 = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function me(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return "input" === b ? !!le$1[a.type] : "textarea" === b ? true : false;
        }
        function ne$1(a, b, c, d) {
          Eb(d);
          b = oe$1(b, "onChange");
          0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
            event: c,
            listeners: b
          }));
        }
        var pe = null,
          qe$1 = null;
        function re$2(a) {
          se$1(a, 0);
        }
        function te$1(a) {
          var b = ue$1(a);
          if (Wa(b)) return a;
        }
        function ve$1(a, b) {
          if ("change" === a) return b;
        }
        var we$2 = false;
        if (ia) {
          var xe$1;
          if (ia) {
            var ye$2 = "oninput" in document;
            if (!ye$2) {
              var ze$1 = document.createElement("div");
              ze$1.setAttribute("oninput", "return;");
              ye$2 = "function" === typeof ze$1.oninput;
            }
            xe$1 = ye$2;
          } else xe$1 = false;
          we$2 = xe$1 && (!document.documentMode || 9 < document.documentMode);
        }
        function Ae$1() {
          pe && (pe.detachEvent("onpropertychange", Be), qe$1 = pe = null);
        }
        function Be(a) {
          if ("value" === a.propertyName && te$1(qe$1)) {
            var b = [];
            ne$1(b, qe$1, a, xb(a));
            Jb(re$2, b);
          }
        }
        function Ce$1(a, b, c) {
          "focusin" === a ? (Ae$1(), pe = b, qe$1 = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae$1();
        }
        function De$1(a) {
          if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te$1(qe$1);
        }
        function Ee$2(a, b) {
          if ("click" === a) return te$1(b);
        }
        function Fe$1(a, b) {
          if ("input" === a || "change" === a) return te$1(b);
        }
        function Ge$1(a, b) {
          return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
        }
        var He$2 = "function" === typeof Object.is ? Object.is : Ge$1;
        function Ie$1(a, b) {
          if (He$2(a, b)) return true;
          if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
          var c = Object.keys(a),
            d = Object.keys(b);
          if (c.length !== d.length) return false;
          for (d = 0; d < c.length; d++) {
            var e = c[d];
            if (!ja.call(b, e) || !He$2(a[e], b[e])) return false;
          }
          return true;
        }
        function Je$1(a) {
          for (; a && a.firstChild;) a = a.firstChild;
          return a;
        }
        function Ke$1(a, b) {
          var c = Je$1(a);
          a = 0;
          for (var d; c;) {
            if (3 === c.nodeType) {
              d = a + c.textContent.length;
              if (a <= b && d >= b) return {
                node: c,
                offset: b - a
              };
              a = d;
            }
            a: {
              for (; c;) {
                if (c.nextSibling) {
                  c = c.nextSibling;
                  break a;
                }
                c = c.parentNode;
              }
              c = void 0;
            }
            c = Je$1(c);
          }
        }
        function Le(a, b) {
          return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
        }
        function Me$1() {
          for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
            try {
              var c = "string" === typeof b.contentWindow.location.href;
            } catch (d) {
              c = false;
            }
            if (c) a = b.contentWindow;else break;
            b = Xa(a.document);
          }
          return b;
        }
        function Ne$1(a) {
          var b = a && a.nodeName && a.nodeName.toLowerCase();
          return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
        }
        function Oe$1(a) {
          var b = Me$1(),
            c = a.focusedElem,
            d = a.selectionRange;
          if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
            if (null !== d && Ne$1(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length,
                f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke$1(c, f);
              var g = Ke$1(c, d);
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
            b = [];
            for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
              element: a,
              left: a.scrollLeft,
              top: a.scrollTop
            });
            "function" === typeof c.focus && c.focus();
            for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
          }
        }
        var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode,
          Qe$1 = null,
          Re$1 = null,
          Se$1 = null,
          Te$1 = false;
        function Ue$1(a, b, c) {
          var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
          Te$1 || null == Qe$1 || Qe$1 !== Xa(d) || (d = Qe$1, "selectionStart" in d && Ne$1(d) ? d = {
            start: d.selectionStart,
            end: d.selectionEnd
          } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
            anchorNode: d.anchorNode,
            anchorOffset: d.anchorOffset,
            focusNode: d.focusNode,
            focusOffset: d.focusOffset
          }), Se$1 && Ie$1(Se$1, d) || (Se$1 = d, d = oe$1(Re$1, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
            event: b,
            listeners: d
          }), b.target = Qe$1)));
        }
        function Ve$1(a, b) {
          var c = {};
          c[a.toLowerCase()] = b.toLowerCase();
          c["Webkit" + a] = "webkit" + b;
          c["Moz" + a] = "moz" + b;
          return c;
        }
        var We$1 = {
            animationend: Ve$1("Animation", "AnimationEnd"),
            animationiteration: Ve$1("Animation", "AnimationIteration"),
            animationstart: Ve$1("Animation", "AnimationStart"),
            transitionend: Ve$1("Transition", "TransitionEnd")
          },
          Xe$1 = {},
          Ye = {};
        ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
        function Ze$1(a) {
          if (Xe$1[a]) return Xe$1[a];
          if (!We$1[a]) return a;
          var b = We$1[a],
            c;
          for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe$1[a] = b[c];
          return a;
        }
        var $e$1 = Ze$1("animationend"),
          af = Ze$1("animationiteration"),
          bf = Ze$1("animationstart"),
          cf = Ze$1("transitionend"),
          df = new Map(),
          ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        function ff(a, b) {
          df.set(a, b);
          fa(b, [a]);
        }
        for (var gf = 0; gf < ef.length; gf++) {
          var hf = ef[gf],
            jf = hf.toLowerCase(),
            kf = hf[0].toUpperCase() + hf.slice(1);
          ff(jf, "on" + kf);
        }
        ff($e$1, "onAnimationEnd");
        ff(af, "onAnimationIteration");
        ff(bf, "onAnimationStart");
        ff("dblclick", "onDoubleClick");
        ff("focusin", "onFocus");
        ff("focusout", "onBlur");
        ff(cf, "onTransitionEnd");
        ha("onMouseEnter", ["mouseout", "mouseover"]);
        ha("onMouseLeave", ["mouseout", "mouseover"]);
        ha("onPointerEnter", ["pointerout", "pointerover"]);
        ha("onPointerLeave", ["pointerout", "pointerover"]);
        fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
        fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
        fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
        fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
          mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
        function nf(a, b, c) {
          var d = a.type || "unknown-event";
          a.currentTarget = c;
          Ub(d, b, void 0, a);
          a.currentTarget = null;
        }
        function se$1(a, b) {
          b = 0 !== (b & 4);
          for (var c = 0; c < a.length; c++) {
            var d = a[c],
              e = d.event;
            d = d.listeners;
            a: {
              var f = void 0;
              if (b) for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g],
                  k = h.instance,
                  l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              } else for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              }
            }
          }
          if (Qb) throw a = Rb, Qb = false, Rb = null, a;
        }
        function D$1(a, b) {
          var c = b[of];
          void 0 === c && (c = b[of] = new Set());
          var d = a + "__bubble";
          c.has(d) || (pf(b, a, 2, false), c.add(d));
        }
        function qf(a, b, c) {
          var d = 0;
          b && (d |= 4);
          pf(c, a, d, b);
        }
        var rf = "_reactListening" + Math.random().toString(36).slice(2);
        function sf(a) {
          if (!a[rf]) {
            a[rf] = true;
            da.forEach(function (b) {
              "selectionchange" !== b && (mf.has(b) || qf(b, false, a), qf(b, true, a));
            });
            var b = 9 === a.nodeType ? a : a.ownerDocument;
            null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
          }
        }
        function pf(a, b, c, d) {
          switch (jd(b)) {
            case 1:
              var e = ed;
              break;
            case 4:
              e = gd;
              break;
            default:
              e = fd;
          }
          c = e.bind(null, b, c, a);
          e = void 0;
          !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
          d ? void 0 !== e ? a.addEventListener(b, c, {
            capture: true,
            passive: e
          }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, {
            passive: e
          }) : a.addEventListener(b, c, false);
        }
        function hd(a, b, c, d, e) {
          var f = d;
          if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
            if (null === d) return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || 8 === h.nodeType && h.parentNode === e) break;
              if (4 === g) for (g = d.return; null !== g;) {
                var k = g.tag;
                if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                g = g.return;
              }
              for (; null !== h;) {
                g = Wc(h);
                if (null === g) return;
                k = g.tag;
                if (5 === k || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
          Jb(function () {
            var d = f,
              e = xb(c),
              g = [];
            a: {
              var h = df.get(a);
              if (void 0 !== h) {
                var k = td,
                  n = a;
                switch (a) {
                  case "keypress":
                    if (0 === od(c)) break a;
                  case "keydown":
                  case "keyup":
                    k = Rd;
                    break;
                  case "focusin":
                    n = "focus";
                    k = Fd;
                    break;
                  case "focusout":
                    n = "blur";
                    k = Fd;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    k = Fd;
                    break;
                  case "click":
                    if (2 === c.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    k = Bd;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    k = Dd;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    k = Vd;
                    break;
                  case $e$1:
                  case af:
                  case bf:
                    k = Hd;
                    break;
                  case cf:
                    k = Xd;
                    break;
                  case "scroll":
                    k = vd;
                    break;
                  case "wheel":
                    k = Zd;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    k = Jd;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    k = Td;
                }
                var t = 0 !== (b & 4),
                  J = !t && "scroll" === a,
                  x = t ? null !== h ? h + "Capture" : null : h;
                t = [];
                for (var w = d, u; null !== w;) {
                  u = w;
                  var F = u.stateNode;
                  5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                  if (J) break;
                  w = w.return;
                }
                0 < t.length && (h = new k(h, n, null, c, e), g.push({
                  event: h,
                  listeners: t
                }));
              }
            }
            if (0 === (b & 7)) {
              a: {
                h = "mouseover" === a || "pointerover" === a;
                k = "mouseout" === a || "pointerout" === a;
                if (h && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
                if (k || h) {
                  h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;
                  if (k) {
                    if (n = c.relatedTarget || c.toElement, k = d, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                  } else k = null, n = d;
                  if (k !== n) {
                    t = Bd;
                    F = "onMouseLeave";
                    x = "onMouseEnter";
                    w = "mouse";
                    if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                    J = null == k ? h : ue$1(k);
                    u = null == n ? h : ue$1(n);
                    h = new t(F, w + "leave", k, c, e);
                    h.target = J;
                    h.relatedTarget = u;
                    F = null;
                    Wc(e) === d && (t = new t(x, w + "enter", n, c, e), t.target = u, t.relatedTarget = J, F = t);
                    J = F;
                    if (k && n) b: {
                      t = k;
                      x = n;
                      w = 0;
                      for (u = t; u; u = vf(u)) w++;
                      u = 0;
                      for (F = x; F; F = vf(F)) u++;
                      for (; 0 < w - u;) t = vf(t), w--;
                      for (; 0 < u - w;) x = vf(x), u--;
                      for (; w--;) {
                        if (t === x || null !== x && t === x.alternate) break b;
                        t = vf(t);
                        x = vf(x);
                      }
                      t = null;
                    } else t = null;
                    null !== k && wf(g, h, k, t, false);
                    null !== n && null !== J && wf(g, J, n, t, true);
                  }
                }
              }
              a: {
                h = d ? ue$1(d) : window;
                k = h.nodeName && h.nodeName.toLowerCase();
                if ("select" === k || "input" === k && "file" === h.type) var na = ve$1;else if (me(h)) {
                  if (we$2) na = Fe$1;else {
                    na = De$1;
                    var xa = Ce$1;
                  }
                } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (na = Ee$2);
                if (na && (na = na(a, d))) {
                  ne$1(g, na, c, e);
                  break a;
                }
                xa && xa(a, h, d);
                "focusout" === a && (xa = h._wrapperState) && xa.controlled && "number" === h.type && cb(h, "number", h.value);
              }
              xa = d ? ue$1(d) : window;
              switch (a) {
                case "focusin":
                  if (me(xa) || "true" === xa.contentEditable) Qe$1 = xa, Re$1 = d, Se$1 = null;
                  break;
                case "focusout":
                  Se$1 = Re$1 = Qe$1 = null;
                  break;
                case "mousedown":
                  Te$1 = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  Te$1 = false;
                  Ue$1(g, c, e);
                  break;
                case "selectionchange":
                  if (Pe$1) break;
                case "keydown":
                case "keyup":
                  Ue$1(g, c, e);
              }
              var $a;
              if (ae$1) b: {
                switch (a) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              } else ie$1 ? ge$1(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
              ba && (de && "ko" !== c.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e), g.push({
                event: ba,
                listeners: xa
              }), $a ? ba.data = $a : ($a = he$1(c), null !== $a && (ba.data = $a))));
              if ($a = ce$1 ? je$1(a, c) : ke$1(a, c)) d = oe$1(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
                event: e,
                listeners: d
              }), e.data = $a);
            }
            se$1(g, b);
          });
        }
        function tf(a, b, c) {
          return {
            instance: a,
            listener: b,
            currentTarget: c
          };
        }
        function oe$1(a, b) {
          for (var c = b + "Capture", d = []; null !== a;) {
            var e = a,
              f = e.stateNode;
            5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
            a = a.return;
          }
          return d;
        }
        function vf(a) {
          if (null === a) return null;
          do a = a.return; while (a && 5 !== a.tag);
          return a ? a : null;
        }
        function wf(a, b, c, d, e) {
          for (var f = b._reactName, g = []; null !== c && c !== d;) {
            var h = c,
              k = h.alternate,
              l = h.stateNode;
            if (null !== k && k === d) break;
            5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
            c = c.return;
          }
          0 !== g.length && a.push({
            event: b,
            listeners: g
          });
        }
        var xf = /\r\n?/g,
          yf = /\u0000|\uFFFD/g;
        function zf(a) {
          return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
        }
        function Af(a, b, c) {
          b = zf(b);
          if (zf(a) !== b && c) throw Error(p$3(425));
        }
        function Bf() {}
        var Cf = null,
          Df = null;
        function Ef(a, b) {
          return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
        }
        var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
          Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
          Hf = "function" === typeof Promise ? Promise : void 0,
          Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function (a) {
            return Hf.resolve(null).then(a).catch(If);
          } : Ff;
        function If(a) {
          setTimeout(function () {
            throw a;
          });
        }
        function Kf(a, b) {
          var c = b,
            d = 0;
          do {
            var e = c.nextSibling;
            a.removeChild(c);
            if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
              if (0 === d) {
                a.removeChild(e);
                bd(b);
                return;
              }
              d--;
            } else "$" !== c && "$?" !== c && "$!" !== c || d++;
            c = e;
          } while (c);
          bd(b);
        }
        function Lf(a) {
          for (; null != a; a = a.nextSibling) {
            var b = a.nodeType;
            if (1 === b || 3 === b) break;
            if (8 === b) {
              b = a.data;
              if ("$" === b || "$!" === b || "$?" === b) break;
              if ("/$" === b) return null;
            }
          }
          return a;
        }
        function Mf(a) {
          a = a.previousSibling;
          for (var b = 0; a;) {
            if (8 === a.nodeType) {
              var c = a.data;
              if ("$" === c || "$!" === c || "$?" === c) {
                if (0 === b) return a;
                b--;
              } else "/$" === c && b++;
            }
            a = a.previousSibling;
          }
          return null;
        }
        var Nf = Math.random().toString(36).slice(2),
          Of = "__reactFiber$" + Nf,
          Pf = "__reactProps$" + Nf,
          uf = "__reactContainer$" + Nf,
          of = "__reactEvents$" + Nf,
          Qf = "__reactListeners$" + Nf,
          Rf = "__reactHandles$" + Nf;
        function Wc(a) {
          var b = a[Of];
          if (b) return b;
          for (var c = a.parentNode; c;) {
            if (b = c[uf] || c[Of]) {
              c = b.alternate;
              if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a;) {
                if (c = a[Of]) return c;
                a = Mf(a);
              }
              return b;
            }
            a = c;
            c = a.parentNode;
          }
          return null;
        }
        function Cb(a) {
          a = a[Of] || a[uf];
          return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
        }
        function ue$1(a) {
          if (5 === a.tag || 6 === a.tag) return a.stateNode;
          throw Error(p$3(33));
        }
        function Db(a) {
          return a[Pf] || null;
        }
        var Sf = [],
          Tf = -1;
        function Uf(a) {
          return {
            current: a
          };
        }
        function E(a) {
          0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
        }
        function G$1(a, b) {
          Tf++;
          Sf[Tf] = a.current;
          a.current = b;
        }
        var Vf = {},
          H$2 = Uf(Vf),
          Wf = Uf(false),
          Xf = Vf;
        function Yf(a, b) {
          var c = a.type.contextTypes;
          if (!c) return Vf;
          var d = a.stateNode;
          if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
          var e = {},
            f;
          for (f in c) e[f] = b[f];
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
          return e;
        }
        function Zf(a) {
          a = a.childContextTypes;
          return null !== a && void 0 !== a;
        }
        function $f() {
          E(Wf);
          E(H$2);
        }
        function ag(a, b, c) {
          if (H$2.current !== Vf) throw Error(p$3(168));
          G$1(H$2, b);
          G$1(Wf, c);
        }
        function bg(a, b, c) {
          var d = a.stateNode;
          b = b.childContextTypes;
          if ("function" !== typeof d.getChildContext) return c;
          d = d.getChildContext();
          for (var e in d) if (!(e in b)) throw Error(p$3(108, Ra(a) || "Unknown", e));
          return A$2({}, c, d);
        }
        function cg(a) {
          a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
          Xf = H$2.current;
          G$1(H$2, a);
          G$1(Wf, Wf.current);
          return true;
        }
        function dg(a, b, c) {
          var d = a.stateNode;
          if (!d) throw Error(p$3(169));
          c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H$2), G$1(H$2, a)) : E(Wf);
          G$1(Wf, c);
        }
        var eg = null,
          fg = false,
          gg = false;
        function hg(a) {
          null === eg ? eg = [a] : eg.push(a);
        }
        function ig(a) {
          fg = true;
          hg(a);
        }
        function jg() {
          if (!gg && null !== eg) {
            gg = true;
            var a = 0,
              b = C$1;
            try {
              var c = eg;
              for (C$1 = 1; a < c.length; a++) {
                var d = c[a];
                do d = d(!0); while (null !== d);
              }
              eg = null;
              fg = !1;
            } catch (e) {
              throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
            } finally {
              C$1 = b, gg = false;
            }
          }
          return null;
        }
        var kg = [],
          lg = 0,
          mg = null,
          ng = 0,
          og = [],
          pg = 0,
          qg = null,
          rg = 1,
          sg = "";
        function tg(a, b) {
          kg[lg++] = ng;
          kg[lg++] = mg;
          mg = a;
          ng = b;
        }
        function ug(a, b, c) {
          og[pg++] = rg;
          og[pg++] = sg;
          og[pg++] = qg;
          qg = a;
          var d = rg;
          a = sg;
          var e = 32 - oc(d) - 1;
          d &= ~(1 << e);
          c += 1;
          var f = 32 - oc(b) + e;
          if (30 < f) {
            var g = e - e % 5;
            f = (d & (1 << g) - 1).toString(32);
            d >>= g;
            e -= g;
            rg = 1 << 32 - oc(b) + e | c << e | d;
            sg = f + a;
          } else rg = 1 << f | c << e | d, sg = a;
        }
        function vg(a) {
          null !== a.return && (tg(a, 1), ug(a, 1, 0));
        }
        function wg(a) {
          for (; a === mg;) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
          for (; a === qg;) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
        }
        var xg = null,
          yg = null,
          I$2 = false,
          zg = null;
        function Ag(a, b) {
          var c = Bg(5, null, null, 0);
          c.elementType = "DELETED";
          c.stateNode = b;
          c.return = a;
          b = a.deletions;
          null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
        }
        function Cg(a, b) {
          switch (a.tag) {
            case 5:
              var c = a.type;
              b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
              return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
            case 6:
              return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
            case 13:
              return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
                id: rg,
                overflow: sg
              } : null, a.memoizedState = {
                dehydrated: b,
                treeContext: c,
                retryLane: 1073741824
              }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
            default:
              return false;
          }
        }
        function Dg(a) {
          return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
        }
        function Eg(a) {
          if (I$2) {
            var b = yg;
            if (b) {
              var c = b;
              if (!Cg(a, b)) {
                if (Dg(a)) throw Error(p$3(418));
                b = Lf(c.nextSibling);
                var d = xg;
                b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I$2 = false, xg = a);
              }
            } else {
              if (Dg(a)) throw Error(p$3(418));
              a.flags = a.flags & -4097 | 2;
              I$2 = false;
              xg = a;
            }
          }
        }
        function Fg(a) {
          for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;
          xg = a;
        }
        function Gg(a) {
          if (a !== xg) return false;
          if (!I$2) return Fg(a), I$2 = true, false;
          var b;
          (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
          if (b && (b = yg)) {
            if (Dg(a)) throw Hg(), Error(p$3(418));
            for (; b;) Ag(a, b), b = Lf(b.nextSibling);
          }
          Fg(a);
          if (13 === a.tag) {
            a = a.memoizedState;
            a = null !== a ? a.dehydrated : null;
            if (!a) throw Error(p$3(317));
            a: {
              a = a.nextSibling;
              for (b = 0; a;) {
                if (8 === a.nodeType) {
                  var c = a.data;
                  if ("/$" === c) {
                    if (0 === b) {
                      yg = Lf(a.nextSibling);
                      break a;
                    }
                    b--;
                  } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                }
                a = a.nextSibling;
              }
              yg = null;
            }
          } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
          return true;
        }
        function Hg() {
          for (var a = yg; a;) a = Lf(a.nextSibling);
        }
        function Ig() {
          yg = xg = null;
          I$2 = false;
        }
        function Jg(a) {
          null === zg ? zg = [a] : zg.push(a);
        }
        var Kg = ua.ReactCurrentBatchConfig;
        function Lg(a, b, c) {
          a = c.ref;
          if (null !== a && "function" !== typeof a && "object" !== typeof a) {
            if (c._owner) {
              c = c._owner;
              if (c) {
                if (1 !== c.tag) throw Error(p$3(309));
                var d = c.stateNode;
              }
              if (!d) throw Error(p$3(147, a));
              var e = d,
                f = "" + a;
              if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
              b = function (a) {
                var b = e.refs;
                null === a ? delete b[f] : b[f] = a;
              };
              b._stringRef = f;
              return b;
            }
            if ("string" !== typeof a) throw Error(p$3(284));
            if (!c._owner) throw Error(p$3(290, a));
          }
          return a;
        }
        function Mg(a, b) {
          a = Object.prototype.toString.call(b);
          throw Error(p$3(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
        }
        function Ng(a) {
          var b = a._init;
          return b(a._payload);
        }
        function Og(a) {
          function b(b, c) {
            if (a) {
              var d = b.deletions;
              null === d ? (b.deletions = [c], b.flags |= 16) : d.push(c);
            }
          }
          function c(c, d) {
            if (!a) return null;
            for (; null !== d;) b(c, d), d = d.sibling;
            return null;
          }
          function d(a, b) {
            for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
            return a;
          }
          function e(a, b) {
            a = Pg(a, b);
            a.index = 0;
            a.sibling = null;
            return a;
          }
          function f(b, c, d) {
            b.index = d;
            if (!a) return b.flags |= 1048576, c;
            d = b.alternate;
            if (null !== d) return d = d.index, d < c ? (b.flags |= 2, c) : d;
            b.flags |= 2;
            return c;
          }
          function g(b) {
            a && null === b.alternate && (b.flags |= 2);
            return b;
          }
          function h(a, b, c, d) {
            if (null === b || 6 !== b.tag) return b = Qg(c, a.mode, d), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function k(a, b, c, d) {
            var f = c.type;
            if (f === ya) return m(a, b, c.props.children, d, c.key);
            if (null !== b && (b.elementType === f || "object" === typeof f && null !== f && f.$$typeof === Ha && Ng(f) === b.type)) return d = e(b, c.props), d.ref = Lg(a, b, c), d.return = a, d;
            d = Rg(c.type, c.key, c.props, null, a.mode, d);
            d.ref = Lg(a, b, c);
            d.return = a;
            return d;
          }
          function l(a, b, c, d) {
            if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Sg(c, a.mode, d), b.return = a, b;
            b = e(b, c.children || []);
            b.return = a;
            return b;
          }
          function m(a, b, c, d, f) {
            if (null === b || 7 !== b.tag) return b = Tg(c, a.mode, d, f), b.return = a, b;
            b = e(b, c);
            b.return = a;
            return b;
          }
          function q(a, b, c) {
            if ("string" === typeof b && "" !== b || "number" === typeof b) return b = Qg("" + b, a.mode, c), b.return = a, b;
            if ("object" === typeof b && null !== b) {
              switch (b.$$typeof) {
                case va:
                  return c = Rg(b.type, b.key, b.props, null, a.mode, c), c.ref = Lg(a, null, b), c.return = a, c;
                case wa:
                  return b = Sg(b, a.mode, c), b.return = a, b;
                case Ha:
                  var d = b._init;
                  return q(a, d(b._payload), c);
              }
              if (eb(b) || Ka(b)) return b = Tg(b, a.mode, c, null), b.return = a, b;
              Mg(a, b);
            }
            return null;
          }
          function r(a, b, c, d) {
            var e = null !== b ? b.key : null;
            if ("string" === typeof c && "" !== c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);
            if ("object" === typeof c && null !== c) {
              switch (c.$$typeof) {
                case va:
                  return c.key === e ? k(a, b, c, d) : null;
                case wa:
                  return c.key === e ? l(a, b, c, d) : null;
                case Ha:
                  return e = c._init, r(a, b, e(c._payload), d);
              }
              if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
              Mg(a, c);
            }
            return null;
          }
          function y(a, b, c, d, e) {
            if ("string" === typeof d && "" !== d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);
            if ("object" === typeof d && null !== d) {
              switch (d.$$typeof) {
                case va:
                  return a = a.get(null === d.key ? c : d.key) || null, k(b, a, d, e);
                case wa:
                  return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
                case Ha:
                  var f = d._init;
                  return y(a, b, c, f(d._payload), e);
              }
              if (eb(d) || Ka(d)) return a = a.get(c) || null, m(b, a, d, e, null);
              Mg(b, d);
            }
            return null;
          }
          function n(e, g, h, k) {
            for (var l = null, m = null, u = g, w = g = 0, x = null; null !== u && w < h.length; w++) {
              u.index > w ? (x = u, u = null) : x = u.sibling;
              var n = r(e, u, h[w], k);
              if (null === n) {
                null === u && (u = x);
                break;
              }
              a && u && null === n.alternate && b(e, u);
              g = f(n, g, w);
              null === m ? l = n : m.sibling = n;
              m = n;
              u = x;
            }
            if (w === h.length) return c(e, u), I$2 && tg(e, w), l;
            if (null === u) {
              for (; w < h.length; w++) u = q(e, h[w], k), null !== u && (g = f(u, g, w), null === m ? l = u : m.sibling = u, m = u);
              I$2 && tg(e, w);
              return l;
            }
            for (u = d(e, u); w < h.length; w++) x = y(u, e, w, h[w], k), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g = f(x, g, w), null === m ? l = x : m.sibling = x, m = x);
            a && u.forEach(function (a) {
              return b(e, a);
            });
            I$2 && tg(e, w);
            return l;
          }
          function t(e, g, h, k) {
            var l = Ka(h);
            if ("function" !== typeof l) throw Error(p$3(150));
            h = l.call(h);
            if (null == h) throw Error(p$3(151));
            for (var u = l = null, m = g, w = g = 0, x = null, n = h.next(); null !== m && !n.done; w++, n = h.next()) {
              m.index > w ? (x = m, m = null) : x = m.sibling;
              var t = r(e, m, n.value, k);
              if (null === t) {
                null === m && (m = x);
                break;
              }
              a && m && null === t.alternate && b(e, m);
              g = f(t, g, w);
              null === u ? l = t : u.sibling = t;
              u = t;
              m = x;
            }
            if (n.done) return c(e, m), I$2 && tg(e, w), l;
            if (null === m) {
              for (; !n.done; w++, n = h.next()) n = q(e, n.value, k), null !== n && (g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
              I$2 && tg(e, w);
              return l;
            }
            for (m = d(e, m); !n.done; w++, n = h.next()) n = y(m, e, w, n.value, k), null !== n && (a && null !== n.alternate && m.delete(null === n.key ? w : n.key), g = f(n, g, w), null === u ? l = n : u.sibling = n, u = n);
            a && m.forEach(function (a) {
              return b(e, a);
            });
            I$2 && tg(e, w);
            return l;
          }
          function J(a, d, f, h) {
            "object" === typeof f && null !== f && f.type === ya && null === f.key && (f = f.props.children);
            if ("object" === typeof f && null !== f) {
              switch (f.$$typeof) {
                case va:
                  a: {
                    for (var k = f.key, l = d; null !== l;) {
                      if (l.key === k) {
                        k = f.type;
                        if (k === ya) {
                          if (7 === l.tag) {
                            c(a, l.sibling);
                            d = e(l, f.props.children);
                            d.return = a;
                            a = d;
                            break a;
                          }
                        } else if (l.elementType === k || "object" === typeof k && null !== k && k.$$typeof === Ha && Ng(k) === l.type) {
                          c(a, l.sibling);
                          d = e(l, f.props);
                          d.ref = Lg(a, l, f);
                          d.return = a;
                          a = d;
                          break a;
                        }
                        c(a, l);
                        break;
                      } else b(a, l);
                      l = l.sibling;
                    }
                    f.type === ya ? (d = Tg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Rg(f.type, f.key, f.props, null, a.mode, h), h.ref = Lg(a, d, f), h.return = a, a = h);
                  }
                  return g(a);
                case wa:
                  a: {
                    for (l = f.key; null !== d;) {
                      if (d.key === l) {
                        if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                          c(a, d.sibling);
                          d = e(d, f.children || []);
                          d.return = a;
                          a = d;
                          break a;
                        } else {
                          c(a, d);
                          break;
                        }
                      } else b(a, d);
                      d = d.sibling;
                    }
                    d = Sg(f, a.mode, h);
                    d.return = a;
                    a = d;
                  }
                  return g(a);
                case Ha:
                  return l = f._init, J(a, d, l(f._payload), h);
              }
              if (eb(f)) return n(a, d, f, h);
              if (Ka(f)) return t(a, d, f, h);
              Mg(a, f);
            }
            return "string" === typeof f && "" !== f || "number" === typeof f ? (f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Qg(f, a.mode, h), d.return = a, a = d), g(a)) : c(a, d);
          }
          return J;
        }
        var Ug = Og(true),
          Vg = Og(false),
          Wg = Uf(null),
          Xg = null,
          Yg = null,
          Zg = null;
        function $g() {
          Zg = Yg = Xg = null;
        }
        function ah(a) {
          var b = Wg.current;
          E(Wg);
          a._currentValue = b;
        }
        function bh(a, b, c) {
          for (; null !== a;) {
            var d = a.alternate;
            (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
            if (a === c) break;
            a = a.return;
          }
        }
        function ch(a, b) {
          Xg = a;
          Zg = Yg = null;
          a = a.dependencies;
          null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
        }
        function eh(a) {
          var b = a._currentValue;
          if (Zg !== a) if (a = {
            context: a,
            memoizedValue: b,
            next: null
          }, null === Yg) {
            if (null === Xg) throw Error(p$3(308));
            Yg = a;
            Xg.dependencies = {
              lanes: 0,
              firstContext: a
            };
          } else Yg = Yg.next = a;
          return b;
        }
        var fh = null;
        function gh(a) {
          null === fh ? fh = [a] : fh.push(a);
        }
        function hh(a, b, c, d) {
          var e = b.interleaved;
          null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
          b.interleaved = c;
          return ih(a, d);
        }
        function ih(a, b) {
          a.lanes |= b;
          var c = a.alternate;
          null !== c && (c.lanes |= b);
          c = a;
          for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
          return 3 === c.tag ? c.stateNode : null;
        }
        var jh = false;
        function kh(a) {
          a.updateQueue = {
            baseState: a.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: 0
            },
            effects: null
          };
        }
        function lh(a, b) {
          a = a.updateQueue;
          b.updateQueue === a && (b.updateQueue = {
            baseState: a.baseState,
            firstBaseUpdate: a.firstBaseUpdate,
            lastBaseUpdate: a.lastBaseUpdate,
            shared: a.shared,
            effects: a.effects
          });
        }
        function mh(a, b) {
          return {
            eventTime: a,
            lane: b,
            tag: 0,
            payload: null,
            callback: null,
            next: null
          };
        }
        function nh(a, b, c) {
          var d = a.updateQueue;
          if (null === d) return null;
          d = d.shared;
          if (0 !== (K$1 & 2)) {
            var e = d.pending;
            null === e ? b.next = b : (b.next = e.next, e.next = b);
            d.pending = b;
            return ih(a, c);
          }
          e = d.interleaved;
          null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
          d.interleaved = b;
          return ih(a, c);
        }
        function oh(a, b, c) {
          b = b.updateQueue;
          if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        function ph(a, b) {
          var c = a.updateQueue,
            d = a.alternate;
          if (null !== d && (d = d.updateQueue, c === d)) {
            var e = null,
              f = null;
            c = c.firstBaseUpdate;
            if (null !== c) {
              do {
                var g = {
                  eventTime: c.eventTime,
                  lane: c.lane,
                  tag: c.tag,
                  payload: c.payload,
                  callback: c.callback,
                  next: null
                };
                null === f ? e = f = g : f = f.next = g;
                c = c.next;
              } while (null !== c);
              null === f ? e = f = b : f = f.next = b;
            } else e = f = b;
            c = {
              baseState: d.baseState,
              firstBaseUpdate: e,
              lastBaseUpdate: f,
              shared: d.shared,
              effects: d.effects
            };
            a.updateQueue = c;
            return;
          }
          a = c.lastBaseUpdate;
          null === a ? c.firstBaseUpdate = b : a.next = b;
          c.lastBaseUpdate = b;
        }
        function qh(a, b, c, d) {
          var e = a.updateQueue;
          jh = false;
          var f = e.firstBaseUpdate,
            g = e.lastBaseUpdate,
            h = e.shared.pending;
          if (null !== h) {
            e.shared.pending = null;
            var k = h,
              l = k.next;
            k.next = null;
            null === g ? f = l : g.next = l;
            g = k;
            var m = a.alternate;
            null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
          }
          if (null !== f) {
            var q = e.baseState;
            g = 0;
            m = l = k = null;
            h = f;
            do {
              var r = h.lane,
                y = h.eventTime;
              if ((d & r) === r) {
                null !== m && (m = m.next = {
                  eventTime: y,
                  lane: 0,
                  tag: h.tag,
                  payload: h.payload,
                  callback: h.callback,
                  next: null
                });
                a: {
                  var n = a,
                    t = h;
                  r = b;
                  y = c;
                  switch (t.tag) {
                    case 1:
                      n = t.payload;
                      if ("function" === typeof n) {
                        q = n.call(y, q, r);
                        break a;
                      }
                      q = n;
                      break a;
                    case 3:
                      n.flags = n.flags & -65537 | 128;
                    case 0:
                      n = t.payload;
                      r = "function" === typeof n ? n.call(y, q, r) : n;
                      if (null === r || void 0 === r) break a;
                      q = A$2({}, q, r);
                      break a;
                    case 2:
                      jh = true;
                  }
                }
                null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
              } else y = {
                eventTime: y,
                lane: r,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
              h = h.next;
              if (null === h) if (h = e.shared.pending, null === h) break;else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
            } while (1);
            null === m && (k = q);
            e.baseState = k;
            e.firstBaseUpdate = l;
            e.lastBaseUpdate = m;
            b = e.shared.interleaved;
            if (null !== b) {
              e = b;
              do g |= e.lane, e = e.next; while (e !== b);
            } else null === f && (e.shared.lanes = 0);
            rh |= g;
            a.lanes = g;
            a.memoizedState = q;
          }
        }
        function sh(a, b, c) {
          a = b.effects;
          b.effects = null;
          if (null !== a) for (b = 0; b < a.length; b++) {
            var d = a[b],
              e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e) throw Error(p$3(191, e));
              e.call(d);
            }
          }
        }
        var th = {},
          uh = Uf(th),
          vh = Uf(th),
          wh = Uf(th);
        function xh(a) {
          if (a === th) throw Error(p$3(174));
          return a;
        }
        function yh(a, b) {
          G$1(wh, b);
          G$1(vh, a);
          G$1(uh, th);
          a = b.nodeType;
          switch (a) {
            case 9:
            case 11:
              b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
              break;
            default:
              a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
          }
          E(uh);
          G$1(uh, b);
        }
        function zh() {
          E(uh);
          E(vh);
          E(wh);
        }
        function Ah(a) {
          xh(wh.current);
          var b = xh(uh.current);
          var c = lb(b, a.type);
          b !== c && (G$1(vh, a), G$1(uh, c));
        }
        function Bh(a) {
          vh.current === a && (E(uh), E(vh));
        }
        var L$2 = Uf(0);
        function Ch(a) {
          for (var b = a; null !== b;) {
            if (13 === b.tag) {
              var c = b.memoizedState;
              if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
            } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
              if (0 !== (b.flags & 128)) return b;
            } else if (null !== b.child) {
              b.child.return = b;
              b = b.child;
              continue;
            }
            if (b === a) break;
            for (; null === b.sibling;) {
              if (null === b.return || b.return === a) return null;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
          return null;
        }
        var Dh = [];
        function Eh() {
          for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
          Dh.length = 0;
        }
        var Fh = ua.ReactCurrentDispatcher,
          Gh = ua.ReactCurrentBatchConfig,
          Hh = 0,
          M$2 = null,
          N$1 = null,
          O$1 = null,
          Ih = false,
          Jh = false,
          Kh = 0,
          Lh = 0;
        function P$1() {
          throw Error(p$3(321));
        }
        function Mh(a, b) {
          if (null === b) return false;
          for (var c = 0; c < b.length && c < a.length; c++) if (!He$2(a[c], b[c])) return false;
          return true;
        }
        function Nh(a, b, c, d, e, f) {
          Hh = f;
          M$2 = b;
          b.memoizedState = null;
          b.updateQueue = null;
          b.lanes = 0;
          Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
          a = c(d, e);
          if (Jh) {
            f = 0;
            do {
              Jh = false;
              Kh = 0;
              if (25 <= f) throw Error(p$3(301));
              f += 1;
              O$1 = N$1 = null;
              b.updateQueue = null;
              Fh.current = Qh;
              a = c(d, e);
            } while (Jh);
          }
          Fh.current = Rh;
          b = null !== N$1 && null !== N$1.next;
          Hh = 0;
          O$1 = N$1 = M$2 = null;
          Ih = false;
          if (b) throw Error(p$3(300));
          return a;
        }
        function Sh() {
          var a = 0 !== Kh;
          Kh = 0;
          return a;
        }
        function Th() {
          var a = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === O$1 ? M$2.memoizedState = O$1 = a : O$1 = O$1.next = a;
          return O$1;
        }
        function Uh() {
          if (null === N$1) {
            var a = M$2.alternate;
            a = null !== a ? a.memoizedState : null;
          } else a = N$1.next;
          var b = null === O$1 ? M$2.memoizedState : O$1.next;
          if (null !== b) O$1 = b, N$1 = a;else {
            if (null === a) throw Error(p$3(310));
            N$1 = a;
            a = {
              memoizedState: N$1.memoizedState,
              baseState: N$1.baseState,
              baseQueue: N$1.baseQueue,
              queue: N$1.queue,
              next: null
            };
            null === O$1 ? M$2.memoizedState = O$1 = a : O$1 = O$1.next = a;
          }
          return O$1;
        }
        function Vh(a, b) {
          return "function" === typeof b ? b(a) : b;
        }
        function Wh(a) {
          var b = Uh(),
            c = b.queue;
          if (null === c) throw Error(p$3(311));
          c.lastRenderedReducer = a;
          var d = N$1,
            e = d.baseQueue,
            f = c.pending;
          if (null !== f) {
            if (null !== e) {
              var g = e.next;
              e.next = f.next;
              f.next = g;
            }
            d.baseQueue = e = f;
            c.pending = null;
          }
          if (null !== e) {
            f = e.next;
            d = d.baseState;
            var h = g = null,
              k = null,
              l = f;
            do {
              var m = l.lane;
              if ((Hh & m) === m) null !== k && (k = k.next = {
                lane: 0,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              }), d = l.hasEagerState ? l.eagerState : a(d, l.action);else {
                var q = {
                  lane: m,
                  action: l.action,
                  hasEagerState: l.hasEagerState,
                  eagerState: l.eagerState,
                  next: null
                };
                null === k ? (h = k = q, g = d) : k = k.next = q;
                M$2.lanes |= m;
                rh |= m;
              }
              l = l.next;
            } while (null !== l && l !== f);
            null === k ? g = d : k.next = h;
            He$2(d, b.memoizedState) || (dh = true);
            b.memoizedState = d;
            b.baseState = g;
            b.baseQueue = k;
            c.lastRenderedState = d;
          }
          a = c.interleaved;
          if (null !== a) {
            e = a;
            do f = e.lane, M$2.lanes |= f, rh |= f, e = e.next; while (e !== a);
          } else null === e && (c.lanes = 0);
          return [b.memoizedState, c.dispatch];
        }
        function Xh(a) {
          var b = Uh(),
            c = b.queue;
          if (null === c) throw Error(p$3(311));
          c.lastRenderedReducer = a;
          var d = c.dispatch,
            e = c.pending,
            f = b.memoizedState;
          if (null !== e) {
            c.pending = null;
            var g = e = e.next;
            do f = a(f, g.action), g = g.next; while (g !== e);
            He$2(f, b.memoizedState) || (dh = true);
            b.memoizedState = f;
            null === b.baseQueue && (b.baseState = f);
            c.lastRenderedState = f;
          }
          return [f, d];
        }
        function Yh() {}
        function Zh(a, b) {
          var c = M$2,
            d = Uh(),
            e = b(),
            f = !He$2(d.memoizedState, e);
          f && (d.memoizedState = e, dh = true);
          d = d.queue;
          $h(ai.bind(null, c, d, a), [a]);
          if (d.getSnapshot !== b || f || null !== O$1 && O$1.memoizedState.tag & 1) {
            c.flags |= 2048;
            bi(9, ci.bind(null, c, d, e, b), void 0, null);
            if (null === Q$2) throw Error(p$3(349));
            0 !== (Hh & 30) || di(c, b, e);
          }
          return e;
        }
        function di(a, b, c) {
          a.flags |= 16384;
          a = {
            getSnapshot: b,
            value: c
          };
          b = M$2.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, M$2.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
        }
        function ci(a, b, c, d) {
          b.value = c;
          b.getSnapshot = d;
          ei(b) && fi(a);
        }
        function ai(a, b, c) {
          return c(function () {
            ei(b) && fi(a);
          });
        }
        function ei(a) {
          var b = a.getSnapshot;
          a = a.value;
          try {
            var c = b();
            return !He$2(a, c);
          } catch (d) {
            return true;
          }
        }
        function fi(a) {
          var b = ih(a, 1);
          null !== b && gi(b, a, 1, -1);
        }
        function hi(a) {
          var b = Th();
          "function" === typeof a && (a = a());
          b.memoizedState = b.baseState = a;
          a = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Vh,
            lastRenderedState: a
          };
          b.queue = a;
          a = a.dispatch = ii.bind(null, M$2, a);
          return [b.memoizedState, a];
        }
        function bi(a, b, c, d) {
          a = {
            tag: a,
            create: b,
            destroy: c,
            deps: d,
            next: null
          };
          b = M$2.updateQueue;
          null === b ? (b = {
            lastEffect: null,
            stores: null
          }, M$2.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
          return a;
        }
        function ji() {
          return Uh().memoizedState;
        }
        function ki(a, b, c, d) {
          var e = Th();
          M$2.flags |= a;
          e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
        }
        function li(a, b, c, d) {
          var e = Uh();
          d = void 0 === d ? null : d;
          var f = void 0;
          if (null !== N$1) {
            var g = N$1.memoizedState;
            f = g.destroy;
            if (null !== d && Mh(d, g.deps)) {
              e.memoizedState = bi(b, c, f, d);
              return;
            }
          }
          M$2.flags |= a;
          e.memoizedState = bi(1 | b, c, f, d);
        }
        function mi(a, b) {
          return ki(8390656, 8, a, b);
        }
        function $h(a, b) {
          return li(2048, 8, a, b);
        }
        function ni(a, b) {
          return li(4, 2, a, b);
        }
        function oi(a, b) {
          return li(4, 4, a, b);
        }
        function pi(a, b) {
          if ("function" === typeof b) return a = a(), b(a), function () {
            b(null);
          };
          if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
            b.current = null;
          };
        }
        function qi(a, b, c) {
          c = null !== c && void 0 !== c ? c.concat([a]) : null;
          return li(4, 4, pi.bind(null, b, a), c);
        }
        function ri() {}
        function si(a, b) {
          var c = Uh();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Mh(b, d[1])) return d[0];
          c.memoizedState = [a, b];
          return a;
        }
        function ti(a, b) {
          var c = Uh();
          b = void 0 === b ? null : b;
          var d = c.memoizedState;
          if (null !== d && null !== b && Mh(b, d[1])) return d[0];
          a = a();
          c.memoizedState = [a, b];
          return a;
        }
        function ui(a, b, c) {
          if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
          He$2(c, b) || (c = yc(), M$2.lanes |= c, rh |= c, a.baseState = true);
          return b;
        }
        function vi(a, b) {
          var c = C$1;
          C$1 = 0 !== c && 4 > c ? c : 4;
          a(true);
          var d = Gh.transition;
          Gh.transition = {};
          try {
            a(!1), b();
          } finally {
            C$1 = c, Gh.transition = d;
          }
        }
        function wi() {
          return Uh().memoizedState;
        }
        function xi(a, b, c) {
          var d = yi(a);
          c = {
            lane: d,
            action: c,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (zi(a)) Ai(b, c);else if (c = hh(a, b, c, d), null !== c) {
            var e = R$1();
            gi(c, a, d, e);
            Bi(c, b, d);
          }
        }
        function ii(a, b, c) {
          var d = yi(a),
            e = {
              lane: d,
              action: c,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
          if (zi(a)) Ai(b, e);else {
            var f = a.alternate;
            if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
              var g = b.lastRenderedState,
                h = f(g, c);
              e.hasEagerState = !0;
              e.eagerState = h;
              if (He$2(h, g)) {
                var k = b.interleaved;
                null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
                b.interleaved = e;
                return;
              }
            } catch (l) {} finally {}
            c = hh(a, b, e, d);
            null !== c && (e = R$1(), gi(c, a, d, e), Bi(c, b, d));
          }
        }
        function zi(a) {
          var b = a.alternate;
          return a === M$2 || null !== b && b === M$2;
        }
        function Ai(a, b) {
          Jh = Ih = true;
          var c = a.pending;
          null === c ? b.next = b : (b.next = c.next, c.next = b);
          a.pending = b;
        }
        function Bi(a, b, c) {
          if (0 !== (c & 4194240)) {
            var d = b.lanes;
            d &= a.pendingLanes;
            c |= d;
            b.lanes = c;
            Cc(a, c);
          }
        }
        var Rh = {
            readContext: eh,
            useCallback: P$1,
            useContext: P$1,
            useEffect: P$1,
            useImperativeHandle: P$1,
            useInsertionEffect: P$1,
            useLayoutEffect: P$1,
            useMemo: P$1,
            useReducer: P$1,
            useRef: P$1,
            useState: P$1,
            useDebugValue: P$1,
            useDeferredValue: P$1,
            useTransition: P$1,
            useMutableSource: P$1,
            useSyncExternalStore: P$1,
            useId: P$1,
            unstable_isNewReconciler: false
          },
          Oh = {
            readContext: eh,
            useCallback: function (a, b) {
              Th().memoizedState = [a, void 0 === b ? null : b];
              return a;
            },
            useContext: eh,
            useEffect: mi,
            useImperativeHandle: function (a, b, c) {
              c = null !== c && void 0 !== c ? c.concat([a]) : null;
              return ki(4194308, 4, pi.bind(null, b, a), c);
            },
            useLayoutEffect: function (a, b) {
              return ki(4194308, 4, a, b);
            },
            useInsertionEffect: function (a, b) {
              return ki(4, 2, a, b);
            },
            useMemo: function (a, b) {
              var c = Th();
              b = void 0 === b ? null : b;
              a = a();
              c.memoizedState = [a, b];
              return a;
            },
            useReducer: function (a, b, c) {
              var d = Th();
              b = void 0 !== c ? c(b) : b;
              d.memoizedState = d.baseState = b;
              a = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: a,
                lastRenderedState: b
              };
              d.queue = a;
              a = a.dispatch = xi.bind(null, M$2, a);
              return [d.memoizedState, a];
            },
            useRef: function (a) {
              var b = Th();
              a = {
                current: a
              };
              return b.memoizedState = a;
            },
            useState: hi,
            useDebugValue: ri,
            useDeferredValue: function (a) {
              return Th().memoizedState = a;
            },
            useTransition: function () {
              var a = hi(false),
                b = a[0];
              a = vi.bind(null, a[1]);
              Th().memoizedState = a;
              return [b, a];
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (a, b, c) {
              var d = M$2,
                e = Th();
              if (I$2) {
                if (void 0 === c) throw Error(p$3(407));
                c = c();
              } else {
                c = b();
                if (null === Q$2) throw Error(p$3(349));
                0 !== (Hh & 30) || di(d, b, c);
              }
              e.memoizedState = c;
              var f = {
                value: c,
                getSnapshot: b
              };
              e.queue = f;
              mi(ai.bind(null, d, f, a), [a]);
              d.flags |= 2048;
              bi(9, ci.bind(null, d, f, c, b), void 0, null);
              return c;
            },
            useId: function () {
              var a = Th(),
                b = Q$2.identifierPrefix;
              if (I$2) {
                var c = sg;
                var d = rg;
                c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
                b = ":" + b + "R" + c;
                c = Kh++;
                0 < c && (b += "H" + c.toString(32));
                b += ":";
              } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
              return a.memoizedState = b;
            },
            unstable_isNewReconciler: false
          },
          Ph = {
            readContext: eh,
            useCallback: si,
            useContext: eh,
            useEffect: $h,
            useImperativeHandle: qi,
            useInsertionEffect: ni,
            useLayoutEffect: oi,
            useMemo: ti,
            useReducer: Wh,
            useRef: ji,
            useState: function () {
              return Wh(Vh);
            },
            useDebugValue: ri,
            useDeferredValue: function (a) {
              var b = Uh();
              return ui(b, N$1.memoizedState, a);
            },
            useTransition: function () {
              var a = Wh(Vh)[0],
                b = Uh().memoizedState;
              return [a, b];
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: wi,
            unstable_isNewReconciler: false
          },
          Qh = {
            readContext: eh,
            useCallback: si,
            useContext: eh,
            useEffect: $h,
            useImperativeHandle: qi,
            useInsertionEffect: ni,
            useLayoutEffect: oi,
            useMemo: ti,
            useReducer: Xh,
            useRef: ji,
            useState: function () {
              return Xh(Vh);
            },
            useDebugValue: ri,
            useDeferredValue: function (a) {
              var b = Uh();
              return null === N$1 ? b.memoizedState = a : ui(b, N$1.memoizedState, a);
            },
            useTransition: function () {
              var a = Xh(Vh)[0],
                b = Uh().memoizedState;
              return [a, b];
            },
            useMutableSource: Yh,
            useSyncExternalStore: Zh,
            useId: wi,
            unstable_isNewReconciler: false
          };
        function Ci(a, b) {
          if (a && a.defaultProps) {
            b = A$2({}, b);
            a = a.defaultProps;
            for (var c in a) void 0 === b[c] && (b[c] = a[c]);
            return b;
          }
          return b;
        }
        function Di(a, b, c, d) {
          b = a.memoizedState;
          c = c(d, b);
          c = null === c || void 0 === c ? b : A$2({}, b, c);
          a.memoizedState = c;
          0 === a.lanes && (a.updateQueue.baseState = c);
        }
        var Ei = {
          isMounted: function (a) {
            return (a = a._reactInternals) ? Vb(a) === a : false;
          },
          enqueueSetState: function (a, b, c) {
            a = a._reactInternals;
            var d = R$1(),
              e = yi(a),
              f = mh(d, e);
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = nh(a, f, e);
            null !== b && (gi(b, a, e, d), oh(b, a, e));
          },
          enqueueReplaceState: function (a, b, c) {
            a = a._reactInternals;
            var d = R$1(),
              e = yi(a),
              f = mh(d, e);
            f.tag = 1;
            f.payload = b;
            void 0 !== c && null !== c && (f.callback = c);
            b = nh(a, f, e);
            null !== b && (gi(b, a, e, d), oh(b, a, e));
          },
          enqueueForceUpdate: function (a, b) {
            a = a._reactInternals;
            var c = R$1(),
              d = yi(a),
              e = mh(c, d);
            e.tag = 2;
            void 0 !== b && null !== b && (e.callback = b);
            b = nh(a, e, d);
            null !== b && (gi(b, a, d, c), oh(b, a, d));
          }
        };
        function Fi(a, b, c, d, e, f, g) {
          a = a.stateNode;
          return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie$1(c, d) || !Ie$1(e, f) : true;
        }
        function Gi(a, b, c) {
          var d = false,
            e = Vf;
          var f = b.contextType;
          "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H$2.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
          b = new b(c, f);
          a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
          b.updater = Ei;
          a.stateNode = b;
          b._reactInternals = a;
          d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
          return b;
        }
        function Hi(a, b, c, d) {
          a = b.state;
          "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
          "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
          b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
        }
        function Ii(a, b, c, d) {
          var e = a.stateNode;
          e.props = c;
          e.state = a.memoizedState;
          e.refs = {};
          kh(a);
          var f = b.contextType;
          "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H$2.current, e.context = Yf(a, f));
          e.state = a.memoizedState;
          f = b.getDerivedStateFromProps;
          "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
          "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
          "function" === typeof e.componentDidMount && (a.flags |= 4194308);
        }
        function Ji(a, b) {
          try {
            var c = "",
              d = b;
            do c += Pa(d), d = d.return; while (d);
            var e = c;
          } catch (f) {
            e = "\nError generating stack: " + f.message + "\n" + f.stack;
          }
          return {
            value: a,
            source: b,
            stack: e,
            digest: null
          };
        }
        function Ki(a, b, c) {
          return {
            value: a,
            source: null,
            stack: null != c ? c : null,
            digest: null != b ? b : null
          };
        }
        function Li(a, b) {
          try {
            console.error(b.value);
          } catch (c) {
            setTimeout(function () {
              throw c;
            });
          }
        }
        var Mi = "function" === typeof WeakMap ? WeakMap : Map;
        function Ni(a, b, c) {
          c = mh(-1, c);
          c.tag = 3;
          c.payload = {
            element: null
          };
          var d = b.value;
          c.callback = function () {
            Oi || (Oi = true, Pi = d);
            Li(a, b);
          };
          return c;
        }
        function Qi(a, b, c) {
          c = mh(-1, c);
          c.tag = 3;
          var d = a.type.getDerivedStateFromError;
          if ("function" === typeof d) {
            var e = b.value;
            c.payload = function () {
              return d(e);
            };
            c.callback = function () {
              Li(a, b);
            };
          }
          var f = a.stateNode;
          null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
            Li(a, b);
            "function" !== typeof d && (null === Ri ? Ri = new Set([this]) : Ri.add(this));
            var c = b.stack;
            this.componentDidCatch(b.value, {
              componentStack: null !== c ? c : ""
            });
          });
          return c;
        }
        function Si(a, b, c) {
          var d = a.pingCache;
          if (null === d) {
            d = a.pingCache = new Mi();
            var e = new Set();
            d.set(b, e);
          } else e = d.get(b), void 0 === e && (e = new Set(), d.set(b, e));
          e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
        }
        function Ui(a) {
          do {
            var b;
            if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
            if (b) return a;
            a = a.return;
          } while (null !== a);
          return null;
        }
        function Vi(a, b, c, d, e) {
          if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
          a.flags |= 65536;
          a.lanes = e;
          return a;
        }
        var Wi = ua.ReactCurrentOwner,
          dh = false;
        function Xi(a, b, c, d) {
          b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
        }
        function Yi(a, b, c, d, e) {
          c = c.render;
          var f = b.ref;
          ch(b, e);
          d = Nh(a, b, c, d, f, e);
          c = Sh();
          if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
          I$2 && c && vg(b);
          b.flags |= 1;
          Xi(a, b, d, e);
          return b.child;
        }
        function $i(a, b, c, d, e) {
          if (null === a) {
            var f = c.type;
            if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
            a = Rg(c.type, null, d, b, b.mode, e);
            a.ref = b.ref;
            a.return = b;
            return b.child = a;
          }
          f = a.child;
          if (0 === (a.lanes & e)) {
            var g = f.memoizedProps;
            c = c.compare;
            c = null !== c ? c : Ie$1;
            if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
          }
          b.flags |= 1;
          a = Pg(f, d);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        function bj(a, b, c, d, e) {
          if (null !== a) {
            var f = a.memoizedProps;
            if (Ie$1(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);else return b.lanes = a.lanes, Zi(a, b, e);
          }
          return cj(a, b, c, d, e);
        }
        function dj(a, b, c) {
          var d = b.pendingProps,
            e = d.children,
            f = null !== a ? a.memoizedState : null;
          if ("hidden" === d.mode) {
            if (0 === (b.mode & 1)) b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null
            }, G$1(ej, fj), fj |= c;else {
              if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
                baseLanes: a,
                cachePool: null,
                transitions: null
              }, b.updateQueue = null, G$1(ej, fj), fj |= a, null;
              b.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
              };
              d = null !== f ? f.baseLanes : c;
              G$1(ej, fj);
              fj |= d;
            }
          } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G$1(ej, fj), fj |= d;
          Xi(a, b, e, c);
          return b.child;
        }
        function gj(a, b) {
          var c = b.ref;
          if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
        }
        function cj(a, b, c, d, e) {
          var f = Zf(c) ? Xf : H$2.current;
          f = Yf(b, f);
          ch(b, e);
          c = Nh(a, b, c, d, f, e);
          d = Sh();
          if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
          I$2 && d && vg(b);
          b.flags |= 1;
          Xi(a, b, c, e);
          return b.child;
        }
        function hj(a, b, c, d, e) {
          if (Zf(c)) {
            var f = true;
            cg(b);
          } else f = false;
          ch(b, e);
          if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;else if (null === a) {
            var g = b.stateNode,
              h = b.memoizedProps;
            g.props = h;
            var k = g.context,
              l = c.contextType;
            "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H$2.current, l = Yf(b, l));
            var m = c.getDerivedStateFromProps,
              q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
            q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
            jh = false;
            var r = b.memoizedState;
            g.state = r;
            qh(b, d, g, e);
            k = b.memoizedState;
            h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
          } else {
            g = b.stateNode;
            lh(a, b);
            h = b.memoizedProps;
            l = b.type === b.elementType ? h : Ci(b.type, h);
            g.props = l;
            q = b.pendingProps;
            r = g.context;
            k = c.contextType;
            "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H$2.current, k = Yf(b, k));
            var y = c.getDerivedStateFromProps;
            (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
            jh = false;
            r = b.memoizedState;
            g.state = r;
            qh(b, d, g, e);
            var n = b.memoizedState;
            h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
          }
          return jj(a, b, c, d, f, e);
        }
        function jj(a, b, c, d, e, f) {
          gj(a, b);
          var g = 0 !== (b.flags & 128);
          if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
          d = b.stateNode;
          Wi.current = b;
          var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
          b.flags |= 1;
          null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
          b.memoizedState = d.state;
          e && dg(b, c, true);
          return b.child;
        }
        function kj(a) {
          var b = a.stateNode;
          b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
          yh(a, b.containerInfo);
        }
        function lj(a, b, c, d, e) {
          Ig();
          Jg(e);
          b.flags |= 256;
          Xi(a, b, c, d);
          return b.child;
        }
        var mj = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0
        };
        function nj(a) {
          return {
            baseLanes: a,
            cachePool: null,
            transitions: null
          };
        }
        function oj(a, b, c) {
          var d = b.pendingProps,
            e = L$2.current,
            f = false,
            g = 0 !== (b.flags & 128),
            h;
          (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
          if (h) f = true, b.flags &= -129;else if (null === a || null !== a.memoizedState) e |= 1;
          G$1(L$2, e & 1);
          if (null === a) {
            Eg(b);
            a = b.memoizedState;
            if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
            g = d.children;
            a = d.fallback;
            return f ? (d = b.mode, f = b.child, g = {
              mode: "hidden",
              children: g
            }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
          }
          e = a.memoizedState;
          if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
          if (f) {
            f = d.fallback;
            g = b.mode;
            e = a.child;
            h = e.sibling;
            var k = {
              mode: "hidden",
              children: d.children
            };
            0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
            null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
            f.return = b;
            d.return = b;
            d.sibling = f;
            b.child = d;
            d = f;
            f = b.child;
            g = a.child.memoizedState;
            g = null === g ? nj(c) : {
              baseLanes: g.baseLanes | c,
              cachePool: null,
              transitions: g.transitions
            };
            f.memoizedState = g;
            f.childLanes = a.childLanes & ~c;
            b.memoizedState = mj;
            return d;
          }
          f = a.child;
          a = f.sibling;
          d = Pg(f, {
            mode: "visible",
            children: d.children
          });
          0 === (b.mode & 1) && (d.lanes = c);
          d.return = b;
          d.sibling = null;
          null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
          b.child = d;
          b.memoizedState = null;
          return d;
        }
        function qj(a, b) {
          b = pj({
            mode: "visible",
            children: b
          }, a.mode, 0, null);
          b.return = a;
          return a.child = b;
        }
        function sj(a, b, c, d) {
          null !== d && Jg(d);
          Ug(b, a.child, null, c);
          a = qj(b, b.pendingProps.children);
          a.flags |= 2;
          b.memoizedState = null;
          return a;
        }
        function rj(a, b, c, d, e, f, g) {
          if (c) {
            if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p$3(422))), sj(a, b, g, d);
            if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
            f = d.fallback;
            e = b.mode;
            d = pj({
              mode: "visible",
              children: d.children
            }, e, 0, null);
            f = Tg(f, e, g, null);
            f.flags |= 2;
            d.return = b;
            f.return = b;
            d.sibling = f;
            b.child = d;
            0 !== (b.mode & 1) && Ug(b, a.child, null, g);
            b.child.memoizedState = nj(g);
            b.memoizedState = mj;
            return f;
          }
          if (0 === (b.mode & 1)) return sj(a, b, g, null);
          if ("$!" === e.data) {
            d = e.nextSibling && e.nextSibling.dataset;
            if (d) var h = d.dgst;
            d = h;
            f = Error(p$3(419));
            d = Ki(f, d, void 0);
            return sj(a, b, g, d);
          }
          h = 0 !== (g & a.childLanes);
          if (dh || h) {
            d = Q$2;
            if (null !== d) {
              switch (g & -g) {
                case 4:
                  e = 2;
                  break;
                case 16:
                  e = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  e = 32;
                  break;
                case 536870912:
                  e = 268435456;
                  break;
                default:
                  e = 0;
              }
              e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
              0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
            }
            tj();
            d = Ki(Error(p$3(421)));
            return sj(a, b, g, d);
          }
          if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
          a = f.treeContext;
          yg = Lf(e.nextSibling);
          xg = b;
          I$2 = true;
          zg = null;
          null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
          b = qj(b, d.children);
          b.flags |= 4096;
          return b;
        }
        function vj(a, b, c) {
          a.lanes |= b;
          var d = a.alternate;
          null !== d && (d.lanes |= b);
          bh(a.return, b, c);
        }
        function wj(a, b, c, d, e) {
          var f = a.memoizedState;
          null === f ? a.memoizedState = {
            isBackwards: b,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: c,
            tailMode: e
          } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
        }
        function xj(a, b, c) {
          var d = b.pendingProps,
            e = d.revealOrder,
            f = d.tail;
          Xi(a, b, d.children, c);
          d = L$2.current;
          if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;else {
            if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a;) {
              if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);else if (19 === a.tag) vj(a, c, b);else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b) break a;
              for (; null === a.sibling;) {
                if (null === a.return || a.return === b) break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
            d &= 1;
          }
          G$1(L$2, d);
          if (0 === (b.mode & 1)) b.memoizedState = null;else switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c;) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
              c = e;
              null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
              wj(b, false, e, c, f);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e;) {
                a = e.alternate;
                if (null !== a && null === Ch(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              wj(b, true, c, null, f);
              break;
            case "together":
              wj(b, false, null, null, void 0);
              break;
            default:
              b.memoizedState = null;
          }
          return b.child;
        }
        function ij(a, b) {
          0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        }
        function Zi(a, b, c) {
          null !== a && (b.dependencies = a.dependencies);
          rh |= b.lanes;
          if (0 === (c & b.childLanes)) return null;
          if (null !== a && b.child !== a.child) throw Error(p$3(153));
          if (null !== b.child) {
            a = b.child;
            c = Pg(a, a.pendingProps);
            b.child = c;
            for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
            c.sibling = null;
          }
          return b.child;
        }
        function yj(a, b, c) {
          switch (b.tag) {
            case 3:
              kj(b);
              Ig();
              break;
            case 5:
              Ah(b);
              break;
            case 1:
              Zf(b.type) && cg(b);
              break;
            case 4:
              yh(b, b.stateNode.containerInfo);
              break;
            case 10:
              var d = b.type._context,
                e = b.memoizedProps.value;
              G$1(Wg, d._currentValue);
              d._currentValue = e;
              break;
            case 13:
              d = b.memoizedState;
              if (null !== d) {
                if (null !== d.dehydrated) return G$1(L$2, L$2.current & 1), b.flags |= 128, null;
                if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
                G$1(L$2, L$2.current & 1);
                a = Zi(a, b, c);
                return null !== a ? a.sibling : null;
              }
              G$1(L$2, L$2.current & 1);
              break;
            case 19:
              d = 0 !== (c & b.childLanes);
              if (0 !== (a.flags & 128)) {
                if (d) return xj(a, b, c);
                b.flags |= 128;
              }
              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
              G$1(L$2, L$2.current);
              if (d) break;else return null;
            case 22:
            case 23:
              return b.lanes = 0, dj(a, b, c);
          }
          return Zi(a, b, c);
        }
        var zj, Aj, Bj, Cj;
        zj = function (a, b) {
          for (var c = b.child; null !== c;) {
            if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
              c.child.return = c;
              c = c.child;
              continue;
            }
            if (c === b) break;
            for (; null === c.sibling;) {
              if (null === c.return || c.return === b) return;
              c = c.return;
            }
            c.sibling.return = c.return;
            c = c.sibling;
          }
        };
        Aj = function () {};
        Bj = function (a, b, c, d) {
          var e = a.memoizedProps;
          if (e !== d) {
            a = b.stateNode;
            xh(uh.current);
            var f = null;
            switch (c) {
              case "input":
                e = Ya(a, e);
                d = Ya(a, d);
                f = [];
                break;
              case "select":
                e = A$2({}, e, {
                  value: void 0
                });
                d = A$2({}, d, {
                  value: void 0
                });
                f = [];
                break;
              case "textarea":
                e = gb(a, e);
                d = gb(a, d);
                f = [];
                break;
              default:
                "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
            }
            ub(c, d);
            var g;
            c = null;
            for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
              var h = e[l];
              for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
            for (l in d) {
              var k = d[l];
              h = null != e ? e[l] : void 0;
              if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
                if (h) {
                  for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                  for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                } else c || (f || (f = []), f.push(l, c)), c = k;
              } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D$1("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
            }
            c && (f = f || []).push("style", c);
            var l = f;
            if (b.updateQueue = l) b.flags |= 4;
          }
        };
        Cj = function (a, b, c, d) {
          c !== d && (b.flags |= 4);
        };
        function Dj(a, b) {
          if (!I$2) switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;
              null === c ? a.tail = null : c.sibling = null;
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;
              null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
          }
        }
        function S$3(a) {
          var b = null !== a.alternate && a.alternate.child === a.child,
            c = 0,
            d = 0;
          if (b) for (var e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;else for (e = a.child; null !== e;) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
          a.subtreeFlags |= d;
          a.childLanes = c;
          return b;
        }
        function Ej(a, b, c) {
          var d = b.pendingProps;
          wg(b);
          switch (b.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return S$3(b), null;
            case 1:
              return Zf(b.type) && $f(), S$3(b), null;
            case 3:
              d = b.stateNode;
              zh();
              E(Wf);
              E(H$2);
              Eh();
              d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
              if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
              Aj(a, b);
              S$3(b);
              return null;
            case 5:
              Bh(b);
              var e = xh(wh.current);
              c = b.type;
              if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);else {
                if (!d) {
                  if (null === b.stateNode) throw Error(p$3(166));
                  S$3(b);
                  return null;
                }
                a = xh(uh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.type;
                  var f = b.memoizedProps;
                  d[Of] = b;
                  d[Pf] = f;
                  a = 0 !== (b.mode & 1);
                  switch (c) {
                    case "dialog":
                      D$1("cancel", d);
                      D$1("close", d);
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D$1("load", d);
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D$1(lf[e], d);
                      break;
                    case "source":
                      D$1("error", d);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D$1("error", d);
                      D$1("load", d);
                      break;
                    case "details":
                      D$1("toggle", d);
                      break;
                    case "input":
                      Za(d, f);
                      D$1("invalid", d);
                      break;
                    case "select":
                      d._wrapperState = {
                        wasMultiple: !!f.multiple
                      };
                      D$1("invalid", d);
                      break;
                    case "textarea":
                      hb(d, f), D$1("invalid", d);
                  }
                  ub(c, f);
                  e = null;
                  for (var g in f) if (f.hasOwnProperty(g)) {
                    var h = f[g];
                    "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D$1("scroll", d);
                  }
                  switch (c) {
                    case "input":
                      Va(d);
                      db(d, f, true);
                      break;
                    case "textarea":
                      Va(d);
                      jb(d);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" === typeof f.onClick && (d.onclick = Bf);
                  }
                  d = e;
                  b.updateQueue = d;
                  null !== d && (b.flags |= 4);
                } else {
                  g = 9 === e.nodeType ? e : e.ownerDocument;
                  "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                  "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
                    is: d.is
                  }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                  a[Of] = b;
                  a[Pf] = d;
                  zj(a, b, false, false);
                  b.stateNode = a;
                  a: {
                    g = vb(c, d);
                    switch (c) {
                      case "dialog":
                        D$1("cancel", a);
                        D$1("close", a);
                        e = d;
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        D$1("load", a);
                        e = d;
                        break;
                      case "video":
                      case "audio":
                        for (e = 0; e < lf.length; e++) D$1(lf[e], a);
                        e = d;
                        break;
                      case "source":
                        D$1("error", a);
                        e = d;
                        break;
                      case "img":
                      case "image":
                      case "link":
                        D$1("error", a);
                        D$1("load", a);
                        e = d;
                        break;
                      case "details":
                        D$1("toggle", a);
                        e = d;
                        break;
                      case "input":
                        Za(a, d);
                        e = Ya(a, d);
                        D$1("invalid", a);
                        break;
                      case "option":
                        e = d;
                        break;
                      case "select":
                        a._wrapperState = {
                          wasMultiple: !!d.multiple
                        };
                        e = A$2({}, d, {
                          value: void 0
                        });
                        D$1("invalid", a);
                        break;
                      case "textarea":
                        hb(a, d);
                        e = gb(a, d);
                        D$1("invalid", a);
                        break;
                      default:
                        e = d;
                    }
                    ub(c, e);
                    h = e;
                    for (f in h) if (h.hasOwnProperty(f)) {
                      var k = h[f];
                      "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D$1("scroll", a) : null != k && ta(a, f, k, g));
                    }
                    switch (c) {
                      case "input":
                        Va(a);
                        db(a, d, false);
                        break;
                      case "textarea":
                        Va(a);
                        jb(a);
                        break;
                      case "option":
                        null != d.value && a.setAttribute("value", "" + Sa(d.value));
                        break;
                      case "select":
                        a.multiple = !!d.multiple;
                        f = d.value;
                        null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                        break;
                      default:
                        "function" === typeof e.onClick && (a.onclick = Bf);
                    }
                    switch (c) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        d = !!d.autoFocus;
                        break a;
                      case "img":
                        d = true;
                        break a;
                      default:
                        d = false;
                    }
                  }
                  d && (b.flags |= 4);
                }
                null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
              }
              S$3(b);
              return null;
            case 6:
              if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);else {
                if ("string" !== typeof d && null === b.stateNode) throw Error(p$3(166));
                c = xh(wh.current);
                xh(uh.current);
                if (Gg(b)) {
                  d = b.stateNode;
                  c = b.memoizedProps;
                  d[Of] = b;
                  if (f = d.nodeValue !== c) if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                  f && (b.flags |= 4);
                } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
              }
              S$3(b);
              return null;
            case 13:
              E(L$2);
              d = b.memoizedState;
              if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
                if (I$2 && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                  if (null === a) {
                    if (!f) throw Error(p$3(318));
                    f = b.memoizedState;
                    f = null !== f ? f.dehydrated : null;
                    if (!f) throw Error(p$3(317));
                    f[Of] = b;
                  } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                  S$3(b);
                  f = false;
                } else null !== zg && (Fj(zg), zg = null), f = true;
                if (!f) return b.flags & 65536 ? b : null;
              }
              if (0 !== (b.flags & 128)) return b.lanes = c, b;
              d = null !== d;
              d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L$2.current & 1) ? 0 === T$2 && (T$2 = 3) : tj()));
              null !== b.updateQueue && (b.flags |= 4);
              S$3(b);
              return null;
            case 4:
              return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S$3(b), null;
            case 10:
              return ah(b.type._context), S$3(b), null;
            case 17:
              return Zf(b.type) && $f(), S$3(b), null;
            case 19:
              E(L$2);
              f = b.memoizedState;
              if (null === f) return S$3(b), null;
              d = 0 !== (b.flags & 128);
              g = f.rendering;
              if (null === g) {
                if (d) Dj(f, false);else {
                  if (0 !== T$2 || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a;) {
                    g = Ch(a);
                    if (null !== g) {
                      b.flags |= 128;
                      Dj(f, false);
                      d = g.updateQueue;
                      null !== d && (b.updateQueue = d, b.flags |= 4);
                      b.subtreeFlags = 0;
                      d = c;
                      for (c = b.child; null !== c;) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                        lanes: a.lanes,
                        firstContext: a.firstContext
                      }), c = c.sibling;
                      G$1(L$2, L$2.current & 1 | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                  null !== f.tail && B$2() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
                }
              } else {
                if (!d) if (a = Ch(g), null !== a) {
                  if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I$2) return S$3(b), null;
                } else 2 * B$2() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
                f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
              }
              if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B$2(), b.sibling = null, c = L$2.current, G$1(L$2, d ? c & 1 | 2 : c & 1), b;
              S$3(b);
              return null;
            case 22:
            case 23:
              return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S$3(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S$3(b), null;
            case 24:
              return null;
            case 25:
              return null;
          }
          throw Error(p$3(156, b.tag));
        }
        function Ij(a, b) {
          wg(b);
          switch (b.tag) {
            case 1:
              return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 3:
              return zh(), E(Wf), E(H$2), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
            case 5:
              return Bh(b), null;
            case 13:
              E(L$2);
              a = b.memoizedState;
              if (null !== a && null !== a.dehydrated) {
                if (null === b.alternate) throw Error(p$3(340));
                Ig();
              }
              a = b.flags;
              return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
            case 19:
              return E(L$2), null;
            case 4:
              return zh(), null;
            case 10:
              return ah(b.type._context), null;
            case 22:
            case 23:
              return Hj(), null;
            case 24:
              return null;
            default:
              return null;
          }
        }
        var Jj = false,
          U$2 = false,
          Kj = "function" === typeof WeakSet ? WeakSet : Set,
          V$3 = null;
        function Lj(a, b) {
          var c = a.ref;
          if (null !== c) if ("function" === typeof c) try {
            c(null);
          } catch (d) {
            W$1(a, b, d);
          } else c.current = null;
        }
        function Mj(a, b, c) {
          try {
            c();
          } catch (d) {
            W$1(a, b, d);
          }
        }
        var Nj = false;
        function Oj(a, b) {
          Cf = dd;
          a = Me$1();
          if (Ne$1(a)) {
            if ("selectionStart" in a) var c = {
              start: a.selectionStart,
              end: a.selectionEnd
            };else a: {
              c = (c = a.ownerDocument) && c.defaultView || window;
              var d = c.getSelection && c.getSelection();
              if (d && 0 !== d.rangeCount) {
                c = d.anchorNode;
                var e = d.anchorOffset,
                  f = d.focusNode;
                d = d.focusOffset;
                try {
                  c.nodeType, f.nodeType;
                } catch (F) {
                  c = null;
                  break a;
                }
                var g = 0,
                  h = -1,
                  k = -1,
                  l = 0,
                  m = 0,
                  q = a,
                  r = null;
                b: for (;;) {
                  for (var y;;) {
                    q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                    q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                    3 === q.nodeType && (g += q.nodeValue.length);
                    if (null === (y = q.firstChild)) break;
                    r = q;
                    q = y;
                  }
                  for (;;) {
                    if (q === a) break b;
                    r === c && ++l === e && (h = g);
                    r === f && ++m === d && (k = g);
                    if (null !== (y = q.nextSibling)) break;
                    q = r;
                    r = q.parentNode;
                  }
                  q = y;
                }
                c = -1 === h || -1 === k ? null : {
                  start: h,
                  end: k
                };
              } else c = null;
            }
            c = c || {
              start: 0,
              end: 0
            };
          } else c = null;
          Df = {
            focusedElem: a,
            selectionRange: c
          };
          dd = false;
          for (V$3 = b; null !== V$3;) if (b = V$3, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V$3 = a;else for (; null !== V$3;) {
            b = V$3;
            try {
              var n = b.alternate;
              if (0 !== (b.flags & 1024)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (null !== n) {
                    var t = n.memoizedProps,
                      J = n.memoizedState,
                      x = b.stateNode,
                      w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                    x.__reactInternalSnapshotBeforeUpdate = w;
                  }
                  break;
                case 3:
                  var u = b.stateNode.containerInfo;
                  1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(p$3(163));
              }
            } catch (F) {
              W$1(b, b.return, F);
            }
            a = b.sibling;
            if (null !== a) {
              a.return = b.return;
              V$3 = a;
              break;
            }
            V$3 = b.return;
          }
          n = Nj;
          Nj = false;
          return n;
        }
        function Pj(a, b, c) {
          var d = b.updateQueue;
          d = null !== d ? d.lastEffect : null;
          if (null !== d) {
            var e = d = d.next;
            do {
              if ((e.tag & a) === a) {
                var f = e.destroy;
                e.destroy = void 0;
                void 0 !== f && Mj(b, c, f);
              }
              e = e.next;
            } while (e !== d);
          }
        }
        function Qj(a, b) {
          b = b.updateQueue;
          b = null !== b ? b.lastEffect : null;
          if (null !== b) {
            var c = b = b.next;
            do {
              if ((c.tag & a) === a) {
                var d = c.create;
                c.destroy = d();
              }
              c = c.next;
            } while (c !== b);
          }
        }
        function Rj(a) {
          var b = a.ref;
          if (null !== b) {
            var c = a.stateNode;
            switch (a.tag) {
              case 5:
                a = c;
                break;
              default:
                a = c;
            }
            "function" === typeof b ? b(a) : b.current = a;
          }
        }
        function Sj(a) {
          var b = a.alternate;
          null !== b && (a.alternate = null, Sj(b));
          a.child = null;
          a.deletions = null;
          a.sibling = null;
          5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
          a.stateNode = null;
          a.return = null;
          a.dependencies = null;
          a.memoizedProps = null;
          a.memoizedState = null;
          a.pendingProps = null;
          a.stateNode = null;
          a.updateQueue = null;
        }
        function Tj(a) {
          return 5 === a.tag || 3 === a.tag || 4 === a.tag;
        }
        function Uj(a) {
          a: for (;;) {
            for (; null === a.sibling;) {
              if (null === a.return || Tj(a.return)) return null;
              a = a.return;
            }
            a.sibling.return = a.return;
            for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag;) {
              if (a.flags & 2) continue a;
              if (null === a.child || 4 === a.tag) continue a;else a.child.return = a, a = a.child;
            }
            if (!(a.flags & 2)) return a.stateNode;
          }
        }
        function Vj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a;) Vj(a, b, c), a = a.sibling;
        }
        function Wj(a, b, c) {
          var d = a.tag;
          if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a;) Wj(a, b, c), a = a.sibling;
        }
        var X$1 = null,
          Xj = false;
        function Yj(a, b, c) {
          for (c = c.child; null !== c;) Zj(a, b, c), c = c.sibling;
        }
        function Zj(a, b, c) {
          if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
            lc.onCommitFiberUnmount(kc, c);
          } catch (h) {}
          switch (c.tag) {
            case 5:
              U$2 || Lj(c, b);
            case 6:
              var d = X$1,
                e = Xj;
              X$1 = null;
              Yj(a, b, c);
              X$1 = d;
              Xj = e;
              null !== X$1 && (Xj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X$1.removeChild(c.stateNode));
              break;
            case 18:
              null !== X$1 && (Xj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X$1, c.stateNode));
              break;
            case 4:
              d = X$1;
              e = Xj;
              X$1 = c.stateNode.containerInfo;
              Xj = true;
              Yj(a, b, c);
              X$1 = d;
              Xj = e;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              if (!U$2 && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
                e = d = d.next;
                do {
                  var f = e,
                    g = f.destroy;
                  f = f.tag;
                  void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                  e = e.next;
                } while (e !== d);
              }
              Yj(a, b, c);
              break;
            case 1:
              if (!U$2 && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
                d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
              } catch (h) {
                W$1(c, b, h);
              }
              Yj(a, b, c);
              break;
            case 21:
              Yj(a, b, c);
              break;
            case 22:
              c.mode & 1 ? (U$2 = (d = U$2) || null !== c.memoizedState, Yj(a, b, c), U$2 = d) : Yj(a, b, c);
              break;
            default:
              Yj(a, b, c);
          }
        }
        function ak(a) {
          var b = a.updateQueue;
          if (null !== b) {
            a.updateQueue = null;
            var c = a.stateNode;
            null === c && (c = a.stateNode = new Kj());
            b.forEach(function (b) {
              var d = bk.bind(null, a, b);
              c.has(b) || (c.add(b), b.then(d, d));
            });
          }
        }
        function ck(a, b) {
          var c = b.deletions;
          if (null !== c) for (var d = 0; d < c.length; d++) {
            var e = c[d];
            try {
              var f = a,
                g = b,
                h = g;
              a: for (; null !== h;) {
                switch (h.tag) {
                  case 5:
                    X$1 = h.stateNode;
                    Xj = !1;
                    break a;
                  case 3:
                    X$1 = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                  case 4:
                    X$1 = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                }
                h = h.return;
              }
              if (null === X$1) throw Error(p$3(160));
              Zj(f, g, e);
              X$1 = null;
              Xj = !1;
              var k = e.alternate;
              null !== k && (k.return = null);
              e.return = null;
            } catch (l) {
              W$1(e, b, l);
            }
          }
          if (b.subtreeFlags & 12854) for (b = b.child; null !== b;) dk(b, a), b = b.sibling;
        }
        function dk(a, b) {
          var c = a.alternate,
            d = a.flags;
          switch (a.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              ck(b, a);
              ek(a);
              if (d & 4) {
                try {
                  Pj(3, a, a.return), Qj(3, a);
                } catch (t) {
                  W$1(a, a.return, t);
                }
                try {
                  Pj(5, a, a.return);
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 1:
              ck(b, a);
              ek(a);
              d & 512 && null !== c && Lj(c, c.return);
              break;
            case 5:
              ck(b, a);
              ek(a);
              d & 512 && null !== c && Lj(c, c.return);
              if (a.flags & 32) {
                var e = a.stateNode;
                try {
                  ob(e, "");
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              if (d & 4 && (e = a.stateNode, null != e)) {
                var f = a.memoizedProps,
                  g = null !== c ? c.memoizedProps : f,
                  h = a.type,
                  k = a.updateQueue;
                a.updateQueue = null;
                if (null !== k) try {
                  "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                  vb(h, g);
                  var l = vb(h, f);
                  for (g = 0; g < k.length; g += 2) {
                    var m = k[g],
                      q = k[g + 1];
                    "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                  }
                  switch (h) {
                    case "input":
                      bb(e, f);
                      break;
                    case "textarea":
                      ib(e, f);
                      break;
                    case "select":
                      var r = e._wrapperState.wasMultiple;
                      e._wrapperState.wasMultiple = !!f.multiple;
                      var y = f.value;
                      null != y ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (null != f.defaultValue ? fb(e, !!f.multiple, f.defaultValue, !0) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                  }
                  e[Pf] = f;
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 6:
              ck(b, a);
              ek(a);
              if (d & 4) {
                if (null === a.stateNode) throw Error(p$3(162));
                e = a.stateNode;
                f = a.memoizedProps;
                try {
                  e.nodeValue = f;
                } catch (t) {
                  W$1(a, a.return, t);
                }
              }
              break;
            case 3:
              ck(b, a);
              ek(a);
              if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
                bd(b.containerInfo);
              } catch (t) {
                W$1(a, a.return, t);
              }
              break;
            case 4:
              ck(b, a);
              ek(a);
              break;
            case 13:
              ck(b, a);
              ek(a);
              e = a.child;
              e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B$2()));
              d & 4 && ak(a);
              break;
            case 22:
              m = null !== c && null !== c.memoizedState;
              a.mode & 1 ? (U$2 = (l = U$2) || m, ck(b, a), U$2 = l) : ck(b, a);
              ek(a);
              if (d & 8192) {
                l = null !== a.memoizedState;
                if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V$3 = a, m = a.child; null !== m;) {
                  for (q = V$3 = m; null !== V$3;) {
                    r = V$3;
                    y = r.child;
                    switch (r.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Pj(4, r, r.return);
                        break;
                      case 1:
                        Lj(r, r.return);
                        var n = r.stateNode;
                        if ("function" === typeof n.componentWillUnmount) {
                          d = r;
                          c = r.return;
                          try {
                            b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                          } catch (t) {
                            W$1(d, c, t);
                          }
                        }
                        break;
                      case 5:
                        Lj(r, r.return);
                        break;
                      case 22:
                        if (null !== r.memoizedState) {
                          gk(q);
                          continue;
                        }
                    }
                    null !== y ? (y.return = r, V$3 = y) : gk(q);
                  }
                  m = m.sibling;
                }
                a: for (m = null, q = a;;) {
                  if (5 === q.tag) {
                    if (null === m) {
                      m = q;
                      try {
                        e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                      } catch (t) {
                        W$1(a, a.return, t);
                      }
                    }
                  } else if (6 === q.tag) {
                    if (null === m) try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W$1(a, a.return, t);
                    }
                  } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                    q.child.return = q;
                    q = q.child;
                    continue;
                  }
                  if (q === a) break a;
                  for (; null === q.sibling;) {
                    if (null === q.return || q.return === a) break a;
                    m === q && (m = null);
                    q = q.return;
                  }
                  m === q && (m = null);
                  q.sibling.return = q.return;
                  q = q.sibling;
                }
              }
              break;
            case 19:
              ck(b, a);
              ek(a);
              d & 4 && ak(a);
              break;
            case 21:
              break;
            default:
              ck(b, a), ek(a);
          }
        }
        function ek(a) {
          var b = a.flags;
          if (b & 2) {
            try {
              a: {
                for (var c = a.return; null !== c;) {
                  if (Tj(c)) {
                    var d = c;
                    break a;
                  }
                  c = c.return;
                }
                throw Error(p$3(160));
              }
              switch (d.tag) {
                case 5:
                  var e = d.stateNode;
                  d.flags & 32 && (ob(e, ""), d.flags &= -33);
                  var f = Uj(a);
                  Wj(a, f, e);
                  break;
                case 3:
                case 4:
                  var g = d.stateNode.containerInfo,
                    h = Uj(a);
                  Vj(a, h, g);
                  break;
                default:
                  throw Error(p$3(161));
              }
            } catch (k) {
              W$1(a, a.return, k);
            }
            a.flags &= -3;
          }
          b & 4096 && (a.flags &= -4097);
        }
        function hk(a, b, c) {
          V$3 = a;
          ik(a);
        }
        function ik(a, b, c) {
          for (var d = 0 !== (a.mode & 1); null !== V$3;) {
            var e = V$3,
              f = e.child;
            if (22 === e.tag && d) {
              var g = null !== e.memoizedState || Jj;
              if (!g) {
                var h = e.alternate,
                  k = null !== h && null !== h.memoizedState || U$2;
                h = Jj;
                var l = U$2;
                Jj = g;
                if ((U$2 = k) && !l) for (V$3 = e; null !== V$3;) g = V$3, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V$3 = k) : jk(e);
                for (; null !== f;) V$3 = f, ik(f), f = f.sibling;
                V$3 = e;
                Jj = h;
                U$2 = l;
              }
              kk(a);
            } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V$3 = f) : kk(a);
          }
        }
        function kk(a) {
          for (; null !== V$3;) {
            var b = V$3;
            if (0 !== (b.flags & 8772)) {
              var c = b.alternate;
              try {
                if (0 !== (b.flags & 8772)) switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U$2 || Qj(5, b);
                    break;
                  case 1:
                    var d = b.stateNode;
                    if (b.flags & 4 && !U$2) if (null === c) d.componentDidMount();else {
                      var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                    var f = b.updateQueue;
                    null !== f && sh(b, f, d);
                    break;
                  case 3:
                    var g = b.updateQueue;
                    if (null !== g) {
                      c = null;
                      if (null !== b.child) switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                      sh(b, g, c);
                    }
                    break;
                  case 5:
                    var h = b.stateNode;
                    if (null === c && b.flags & 4) {
                      c = h;
                      var k = b.memoizedProps;
                      switch (b.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k.autoFocus && c.focus();
                          break;
                        case "img":
                          k.src && (c.src = k.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (null === b.memoizedState) {
                      var l = b.alternate;
                      if (null !== l) {
                        var m = l.memoizedState;
                        if (null !== m) {
                          var q = m.dehydrated;
                          null !== q && bd(q);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p$3(163));
                }
                U$2 || b.flags & 512 && Rj(b);
              } catch (r) {
                W$1(b, b.return, r);
              }
            }
            if (b === a) {
              V$3 = null;
              break;
            }
            c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V$3 = c;
              break;
            }
            V$3 = b.return;
          }
        }
        function gk(a) {
          for (; null !== V$3;) {
            var b = V$3;
            if (b === a) {
              V$3 = null;
              break;
            }
            var c = b.sibling;
            if (null !== c) {
              c.return = b.return;
              V$3 = c;
              break;
            }
            V$3 = b.return;
          }
        }
        function jk(a) {
          for (; null !== V$3;) {
            var b = V$3;
            try {
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  var c = b.return;
                  try {
                    Qj(4, b);
                  } catch (k) {
                    W$1(b, c, k);
                  }
                  break;
                case 1:
                  var d = b.stateNode;
                  if ("function" === typeof d.componentDidMount) {
                    var e = b.return;
                    try {
                      d.componentDidMount();
                    } catch (k) {
                      W$1(b, e, k);
                    }
                  }
                  var f = b.return;
                  try {
                    Rj(b);
                  } catch (k) {
                    W$1(b, f, k);
                  }
                  break;
                case 5:
                  var g = b.return;
                  try {
                    Rj(b);
                  } catch (k) {
                    W$1(b, g, k);
                  }
              }
            } catch (k) {
              W$1(b, b.return, k);
            }
            if (b === a) {
              V$3 = null;
              break;
            }
            var h = b.sibling;
            if (null !== h) {
              h.return = b.return;
              V$3 = h;
              break;
            }
            V$3 = b.return;
          }
        }
        var lk = Math.ceil,
          mk = ua.ReactCurrentDispatcher,
          nk = ua.ReactCurrentOwner,
          ok = ua.ReactCurrentBatchConfig,
          K$1 = 0,
          Q$2 = null,
          Y$2 = null,
          Z$1 = 0,
          fj = 0,
          ej = Uf(0),
          T$2 = 0,
          pk = null,
          rh = 0,
          qk = 0,
          rk = 0,
          sk = null,
          tk = null,
          fk = 0,
          Gj = Infinity,
          uk = null,
          Oi = false,
          Pi = null,
          Ri = null,
          vk = false,
          wk = null,
          xk = 0,
          yk = 0,
          zk = null,
          Ak = -1,
          Bk = 0;
        function R$1() {
          return 0 !== (K$1 & 6) ? B$2() : -1 !== Ak ? Ak : Ak = B$2();
        }
        function yi(a) {
          if (0 === (a.mode & 1)) return 1;
          if (0 !== (K$1 & 2) && 0 !== Z$1) return Z$1 & -Z$1;
          if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
          a = C$1;
          if (0 !== a) return a;
          a = window.event;
          a = void 0 === a ? 16 : jd(a.type);
          return a;
        }
        function gi(a, b, c, d) {
          if (50 < yk) throw yk = 0, zk = null, Error(p$3(185));
          Ac(a, c, d);
          if (0 === (K$1 & 2) || a !== Q$2) a === Q$2 && (0 === (K$1 & 2) && (qk |= c), 4 === T$2 && Ck(a, Z$1)), Dk(a, d), 1 === c && 0 === K$1 && 0 === (b.mode & 1) && (Gj = B$2() + 500, fg && jg());
        }
        function Dk(a, b) {
          var c = a.callbackNode;
          wc(a, b);
          var d = uc(a, a === Q$2 ? Z$1 : 0);
          if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;else if (b = d & -d, a.callbackPriority !== b) {
            null != c && bc(c);
            if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function () {
              0 === (K$1 & 6) && jg();
            }), c = null;else {
              switch (Dc(d)) {
                case 1:
                  c = fc;
                  break;
                case 4:
                  c = gc;
                  break;
                case 16:
                  c = hc;
                  break;
                case 536870912:
                  c = jc;
                  break;
                default:
                  c = hc;
              }
              c = Fk(c, Gk.bind(null, a));
            }
            a.callbackPriority = b;
            a.callbackNode = c;
          }
        }
        function Gk(a, b) {
          Ak = -1;
          Bk = 0;
          if (0 !== (K$1 & 6)) throw Error(p$3(327));
          var c = a.callbackNode;
          if (Hk() && a.callbackNode !== c) return null;
          var d = uc(a, a === Q$2 ? Z$1 : 0);
          if (0 === d) return null;
          if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);else {
            b = d;
            var e = K$1;
            K$1 |= 2;
            var f = Jk();
            if (Q$2 !== a || Z$1 !== b) uk = null, Gj = B$2() + 500, Kk(a, b);
            do try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            } while (1);
            $g();
            mk.current = f;
            K$1 = e;
            null !== Y$2 ? b = 0 : (Q$2 = null, Z$1 = 0, b = T$2);
          }
          if (0 !== b) {
            2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
            if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B$2()), c;
            if (6 === b) Ck(a, d);else {
              e = a.current.alternate;
              if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B$2()), c;
              a.finishedWork = e;
              a.finishedLanes = d;
              switch (b) {
                case 0:
                case 1:
                  throw Error(p$3(345));
                case 2:
                  Pk(a, tk, uk);
                  break;
                case 3:
                  Ck(a, d);
                  if ((d & 130023424) === d && (b = fk + 500 - B$2(), 10 < b)) {
                    if (0 !== uc(a, 0)) break;
                    e = a.suspendedLanes;
                    if ((e & d) !== d) {
                      R$1();
                      a.pingedLanes |= a.suspendedLanes & e;
                      break;
                    }
                    a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                    break;
                  }
                  Pk(a, tk, uk);
                  break;
                case 4:
                  Ck(a, d);
                  if ((d & 4194240) === d) break;
                  b = a.eventTimes;
                  for (e = -1; 0 < d;) {
                    var g = 31 - oc(d);
                    f = 1 << g;
                    g = b[g];
                    g > e && (e = g);
                    d &= ~f;
                  }
                  d = e;
                  d = B$2() - d;
                  d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                  if (10 < d) {
                    a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                    break;
                  }
                  Pk(a, tk, uk);
                  break;
                case 5:
                  Pk(a, tk, uk);
                  break;
                default:
                  throw Error(p$3(329));
              }
            }
          }
          Dk(a, B$2());
          return a.callbackNode === c ? Gk.bind(null, a) : null;
        }
        function Nk(a, b) {
          var c = sk;
          a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
          a = Ik(a, b);
          2 !== a && (b = tk, tk = c, null !== b && Fj(b));
          return a;
        }
        function Fj(a) {
          null === tk ? tk = a : tk.push.apply(tk, a);
        }
        function Ok(a) {
          for (var b = a;;) {
            if (b.flags & 16384) {
              var c = b.updateQueue;
              if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
                var e = c[d],
                  f = e.getSnapshot;
                e = e.value;
                try {
                  if (!He$2(f(), e)) return !1;
                } catch (g) {
                  return false;
                }
              }
            }
            c = b.child;
            if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;else {
              if (b === a) break;
              for (; null === b.sibling;) {
                if (null === b.return || b.return === a) return true;
                b = b.return;
              }
              b.sibling.return = b.return;
              b = b.sibling;
            }
          }
          return true;
        }
        function Ck(a, b) {
          b &= ~rk;
          b &= ~qk;
          a.suspendedLanes |= b;
          a.pingedLanes &= ~b;
          for (a = a.expirationTimes; 0 < b;) {
            var c = 31 - oc(b),
              d = 1 << c;
            a[c] = -1;
            b &= ~d;
          }
        }
        function Ek(a) {
          if (0 !== (K$1 & 6)) throw Error(p$3(327));
          Hk();
          var b = uc(a, 0);
          if (0 === (b & 1)) return Dk(a, B$2()), null;
          var c = Ik(a, b);
          if (0 !== a.tag && 2 === c) {
            var d = xc(a);
            0 !== d && (b = d, c = Nk(a, d));
          }
          if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B$2()), c;
          if (6 === c) throw Error(p$3(345));
          a.finishedWork = a.current.alternate;
          a.finishedLanes = b;
          Pk(a, tk, uk);
          Dk(a, B$2());
          return null;
        }
        function Qk(a, b) {
          var c = K$1;
          K$1 |= 1;
          try {
            return a(b);
          } finally {
            K$1 = c, 0 === K$1 && (Gj = B$2() + 500, fg && jg());
          }
        }
        function Rk(a) {
          null !== wk && 0 === wk.tag && 0 === (K$1 & 6) && Hk();
          var b = K$1;
          K$1 |= 1;
          var c = ok.transition,
            d = C$1;
          try {
            if (ok.transition = null, C$1 = 1, a) return a();
          } finally {
            C$1 = d, ok.transition = c, K$1 = b, 0 === (K$1 & 6) && jg();
          }
        }
        function Hj() {
          fj = ej.current;
          E(ej);
        }
        function Kk(a, b) {
          a.finishedWork = null;
          a.finishedLanes = 0;
          var c = a.timeoutHandle;
          -1 !== c && (a.timeoutHandle = -1, Gf(c));
          if (null !== Y$2) for (c = Y$2.return; null !== c;) {
            var d = c;
            wg(d);
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && $f();
                break;
              case 3:
                zh();
                E(Wf);
                E(H$2);
                Eh();
                break;
              case 5:
                Bh(d);
                break;
              case 4:
                zh();
                break;
              case 13:
                E(L$2);
                break;
              case 19:
                E(L$2);
                break;
              case 10:
                ah(d.type._context);
                break;
              case 22:
              case 23:
                Hj();
            }
            c = c.return;
          }
          Q$2 = a;
          Y$2 = a = Pg(a.current, null);
          Z$1 = fj = b;
          T$2 = 0;
          pk = null;
          rk = qk = rh = 0;
          tk = sk = null;
          if (null !== fh) {
            for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
              c.interleaved = null;
              var e = d.next,
                f = c.pending;
              if (null !== f) {
                var g = f.next;
                f.next = e;
                d.next = g;
              }
              c.pending = d;
            }
            fh = null;
          }
          return a;
        }
        function Mk(a, b) {
          do {
            var c = Y$2;
            try {
              $g();
              Fh.current = Rh;
              if (Ih) {
                for (var d = M$2.memoizedState; null !== d;) {
                  var e = d.queue;
                  null !== e && (e.pending = null);
                  d = d.next;
                }
                Ih = !1;
              }
              Hh = 0;
              O$1 = N$1 = M$2 = null;
              Jh = !1;
              Kh = 0;
              nk.current = null;
              if (null === c || null === c.return) {
                T$2 = 1;
                pk = b;
                Y$2 = null;
                break;
              }
              a: {
                var f = a,
                  g = c.return,
                  h = c,
                  k = b;
                b = Z$1;
                h.flags |= 32768;
                if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                  var l = k,
                    m = h,
                    q = m.tag;
                  if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                    var r = m.alternate;
                    r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                  }
                  var y = Ui(g);
                  if (null !== y) {
                    y.flags &= -257;
                    Vi(y, g, h, f, b);
                    y.mode & 1 && Si(f, l, b);
                    b = y;
                    k = l;
                    var n = b.updateQueue;
                    if (null === n) {
                      var t = new Set();
                      t.add(k);
                      b.updateQueue = t;
                    } else n.add(k);
                    break a;
                  } else {
                    if (0 === (b & 1)) {
                      Si(f, l, b);
                      tj();
                      break a;
                    }
                    k = Error(p$3(426));
                  }
                } else if (I$2 && h.mode & 1) {
                  var J = Ui(g);
                  if (null !== J) {
                    0 === (J.flags & 65536) && (J.flags |= 256);
                    Vi(J, g, h, f, b);
                    Jg(Ji(k, h));
                    break a;
                  }
                }
                f = k = Ji(k, h);
                4 !== T$2 && (T$2 = 2);
                null === sk ? sk = [f] : sk.push(f);
                f = g;
                do {
                  switch (f.tag) {
                    case 3:
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var x = Ni(f, k, b);
                      ph(f, x);
                      break a;
                    case 1:
                      h = k;
                      var w = f.type,
                        u = f.stateNode;
                      if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                        f.flags |= 65536;
                        b &= -b;
                        f.lanes |= b;
                        var F = Qi(f, h, b);
                        ph(f, F);
                        break a;
                      }
                  }
                  f = f.return;
                } while (null !== f);
              }
              Sk(c);
            } catch (na) {
              b = na;
              Y$2 === c && null !== c && (Y$2 = c = c.return);
              continue;
            }
            break;
          } while (1);
        }
        function Jk() {
          var a = mk.current;
          mk.current = Rh;
          return null === a ? Rh : a;
        }
        function tj() {
          if (0 === T$2 || 3 === T$2 || 2 === T$2) T$2 = 4;
          null === Q$2 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$2, Z$1);
        }
        function Ik(a, b) {
          var c = K$1;
          K$1 |= 2;
          var d = Jk();
          if (Q$2 !== a || Z$1 !== b) uk = null, Kk(a, b);
          do try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          } while (1);
          $g();
          K$1 = c;
          mk.current = d;
          if (null !== Y$2) throw Error(p$3(261));
          Q$2 = null;
          Z$1 = 0;
          return T$2;
        }
        function Tk() {
          for (; null !== Y$2;) Uk(Y$2);
        }
        function Lk() {
          for (; null !== Y$2 && !cc();) Uk(Y$2);
        }
        function Uk(a) {
          var b = Vk(a.alternate, a, fj);
          a.memoizedProps = a.pendingProps;
          null === b ? Sk(a) : Y$2 = b;
          nk.current = null;
        }
        function Sk(a) {
          var b = a;
          do {
            var c = b.alternate;
            a = b.return;
            if (0 === (b.flags & 32768)) {
              if (c = Ej(c, b, fj), null !== c) {
                Y$2 = c;
                return;
              }
            } else {
              c = Ij(c, b);
              if (null !== c) {
                c.flags &= 32767;
                Y$2 = c;
                return;
              }
              if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;else {
                T$2 = 6;
                Y$2 = null;
                return;
              }
            }
            b = b.sibling;
            if (null !== b) {
              Y$2 = b;
              return;
            }
            Y$2 = b = a;
          } while (null !== b);
          0 === T$2 && (T$2 = 5);
        }
        function Pk(a, b, c) {
          var d = C$1,
            e = ok.transition;
          try {
            ok.transition = null, C$1 = 1, Wk(a, b, c, d);
          } finally {
            ok.transition = e, C$1 = d;
          }
          return null;
        }
        function Wk(a, b, c, d) {
          do Hk(); while (null !== wk);
          if (0 !== (K$1 & 6)) throw Error(p$3(327));
          c = a.finishedWork;
          var e = a.finishedLanes;
          if (null === c) return null;
          a.finishedWork = null;
          a.finishedLanes = 0;
          if (c === a.current) throw Error(p$3(177));
          a.callbackNode = null;
          a.callbackPriority = 0;
          var f = c.lanes | c.childLanes;
          Bc(a, f);
          a === Q$2 && (Y$2 = Q$2 = null, Z$1 = 0);
          0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function () {
            Hk();
            return null;
          }));
          f = 0 !== (c.flags & 15990);
          if (0 !== (c.subtreeFlags & 15990) || f) {
            f = ok.transition;
            ok.transition = null;
            var g = C$1;
            C$1 = 1;
            var h = K$1;
            K$1 |= 4;
            nk.current = null;
            Oj(a, c);
            dk(c, a);
            Oe$1(Df);
            dd = !!Cf;
            Df = Cf = null;
            a.current = c;
            hk(c);
            dc();
            K$1 = h;
            C$1 = g;
            ok.transition = f;
          } else a.current = c;
          vk && (vk = false, wk = a, xk = e);
          f = a.pendingLanes;
          0 === f && (Ri = null);
          mc(c.stateNode);
          Dk(a, B$2());
          if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
            componentStack: e.stack,
            digest: e.digest
          });
          if (Oi) throw Oi = false, a = Pi, Pi = null, a;
          0 !== (xk & 1) && 0 !== a.tag && Hk();
          f = a.pendingLanes;
          0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
          jg();
          return null;
        }
        function Hk() {
          if (null !== wk) {
            var a = Dc(xk),
              b = ok.transition,
              c = C$1;
            try {
              ok.transition = null;
              C$1 = 16 > a ? 16 : a;
              if (null === wk) var d = !1;else {
                a = wk;
                wk = null;
                xk = 0;
                if (0 !== (K$1 & 6)) throw Error(p$3(331));
                var e = K$1;
                K$1 |= 4;
                for (V$3 = a.current; null !== V$3;) {
                  var f = V$3,
                    g = f.child;
                  if (0 !== (V$3.flags & 16)) {
                    var h = f.deletions;
                    if (null !== h) {
                      for (var k = 0; k < h.length; k++) {
                        var l = h[k];
                        for (V$3 = l; null !== V$3;) {
                          var m = V$3;
                          switch (m.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Pj(8, m, f);
                          }
                          var q = m.child;
                          if (null !== q) q.return = m, V$3 = q;else for (; null !== V$3;) {
                            m = V$3;
                            var r = m.sibling,
                              y = m.return;
                            Sj(m);
                            if (m === l) {
                              V$3 = null;
                              break;
                            }
                            if (null !== r) {
                              r.return = y;
                              V$3 = r;
                              break;
                            }
                            V$3 = y;
                          }
                        }
                      }
                      var n = f.alternate;
                      if (null !== n) {
                        var t = n.child;
                        if (null !== t) {
                          n.child = null;
                          do {
                            var J = t.sibling;
                            t.sibling = null;
                            t = J;
                          } while (null !== t);
                        }
                      }
                      V$3 = f;
                    }
                  }
                  if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V$3 = g;else b: for (; null !== V$3;) {
                    f = V$3;
                    if (0 !== (f.flags & 2048)) switch (f.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(9, f, f.return);
                    }
                    var x = f.sibling;
                    if (null !== x) {
                      x.return = f.return;
                      V$3 = x;
                      break b;
                    }
                    V$3 = f.return;
                  }
                }
                var w = a.current;
                for (V$3 = w; null !== V$3;) {
                  g = V$3;
                  var u = g.child;
                  if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V$3 = u;else b: for (g = w; null !== V$3;) {
                    h = V$3;
                    if (0 !== (h.flags & 2048)) try {
                      switch (h.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, h);
                      }
                    } catch (na) {
                      W$1(h, h.return, na);
                    }
                    if (h === g) {
                      V$3 = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (null !== F) {
                      F.return = h.return;
                      V$3 = F;
                      break b;
                    }
                    V$3 = h.return;
                  }
                }
                K$1 = e;
                jg();
                if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                  lc.onPostCommitFiberRoot(kc, a);
                } catch (na) {}
                d = !0;
              }
              return d;
            } finally {
              C$1 = c, ok.transition = b;
            }
          }
          return false;
        }
        function Xk(a, b, c) {
          b = Ji(c, b);
          b = Ni(a, b, 1);
          a = nh(a, b, 1);
          b = R$1();
          null !== a && (Ac(a, 1, b), Dk(a, b));
        }
        function W$1(a, b, c) {
          if (3 === a.tag) Xk(a, a, c);else for (; null !== b;) {
            if (3 === b.tag) {
              Xk(b, a, c);
              break;
            } else if (1 === b.tag) {
              var d = b.stateNode;
              if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
                a = Ji(c, a);
                a = Qi(b, a, 1);
                b = nh(b, a, 1);
                a = R$1();
                null !== b && (Ac(b, 1, a), Dk(b, a));
                break;
              }
            }
            b = b.return;
          }
        }
        function Ti(a, b, c) {
          var d = a.pingCache;
          null !== d && d.delete(b);
          b = R$1();
          a.pingedLanes |= a.suspendedLanes & c;
          Q$2 === a && (Z$1 & c) === c && (4 === T$2 || 3 === T$2 && (Z$1 & 130023424) === Z$1 && 500 > B$2() - fk ? Kk(a, 0) : rk |= c);
          Dk(a, b);
        }
        function Yk(a, b) {
          0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
          var c = R$1();
          a = ih(a, b);
          null !== a && (Ac(a, b, c), Dk(a, c));
        }
        function uj(a) {
          var b = a.memoizedState,
            c = 0;
          null !== b && (c = b.retryLane);
          Yk(a, c);
        }
        function bk(a, b) {
          var c = 0;
          switch (a.tag) {
            case 13:
              var d = a.stateNode;
              var e = a.memoizedState;
              null !== e && (c = e.retryLane);
              break;
            case 19:
              d = a.stateNode;
              break;
            default:
              throw Error(p$3(314));
          }
          null !== d && d.delete(b);
          Yk(a, c);
        }
        var Vk;
        Vk = function (a, b, c) {
          if (null !== a) {
            if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;else {
              if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
              dh = 0 !== (a.flags & 131072) ? true : false;
            }
          } else dh = false, I$2 && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
          b.lanes = 0;
          switch (b.tag) {
            case 2:
              var d = b.type;
              ij(a, b);
              a = b.pendingProps;
              var e = Yf(b, H$2.current);
              ch(b, c);
              e = Nh(null, b, d, a, e, c);
              var f = Sh();
              b.flags |= 1;
              "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I$2 && f && vg(b), Xi(null, b, e, c), b = b.child);
              return b;
            case 16:
              d = b.elementType;
              a: {
                ij(a, b);
                a = b.pendingProps;
                e = d._init;
                d = e(d._payload);
                b.type = d;
                e = b.tag = Zk(d);
                a = Ci(d, a);
                switch (e) {
                  case 0:
                    b = cj(null, b, d, a, c);
                    break a;
                  case 1:
                    b = hj(null, b, d, a, c);
                    break a;
                  case 11:
                    b = Yi(null, b, d, a, c);
                    break a;
                  case 14:
                    b = $i(null, b, d, Ci(d.type, a), c);
                    break a;
                }
                throw Error(p$3(306, d, ""));
              }
              return b;
            case 0:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
            case 1:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
            case 3:
              a: {
                kj(b);
                if (null === a) throw Error(p$3(387));
                d = b.pendingProps;
                f = b.memoizedState;
                e = f.element;
                lh(a, b);
                qh(b, d, null, c);
                var g = b.memoizedState;
                d = g.element;
                if (f.isDehydrated) {
                  if (f = {
                    element: d,
                    isDehydrated: false,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions
                  }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                    e = Ji(Error(p$3(423)), b);
                    b = lj(a, b, d, c, e);
                    break a;
                  } else if (d !== e) {
                    e = Ji(Error(p$3(424)), b);
                    b = lj(a, b, d, c, e);
                    break a;
                  } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I$2 = true, zg = null, c = Vg(b, null, d, c), b.child = c; c;) c.flags = c.flags & -3 | 4096, c = c.sibling;
                } else {
                  Ig();
                  if (d === e) {
                    b = Zi(a, b, c);
                    break a;
                  }
                  Xi(a, b, d, c);
                }
                b = b.child;
              }
              return b;
            case 5:
              return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
            case 6:
              return null === a && Eg(b), null;
            case 13:
              return oj(a, b, c);
            case 4:
              return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
            case 11:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
            case 7:
              return Xi(a, b, b.pendingProps, c), b.child;
            case 8:
              return Xi(a, b, b.pendingProps.children, c), b.child;
            case 12:
              return Xi(a, b, b.pendingProps.children, c), b.child;
            case 10:
              a: {
                d = b.type._context;
                e = b.pendingProps;
                f = b.memoizedProps;
                g = e.value;
                G$1(Wg, d._currentValue);
                d._currentValue = g;
                if (null !== f) if (He$2(f.value, g)) {
                  if (f.children === e.children && !Wf.current) {
                    b = Zi(a, b, c);
                    break a;
                  }
                } else for (f = b.child, null !== f && (f.return = b); null !== f;) {
                  var h = f.dependencies;
                  if (null !== h) {
                    g = f.child;
                    for (var k = h.firstContext; null !== k;) {
                      if (k.context === d) {
                        if (1 === f.tag) {
                          k = mh(-1, c & -c);
                          k.tag = 2;
                          var l = f.updateQueue;
                          if (null !== l) {
                            l = l.shared;
                            var m = l.pending;
                            null === m ? k.next = k : (k.next = m.next, m.next = k);
                            l.pending = k;
                          }
                        }
                        f.lanes |= c;
                        k = f.alternate;
                        null !== k && (k.lanes |= c);
                        bh(f.return, c, b);
                        h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (10 === f.tag) g = f.type === b.type ? null : f.child;else if (18 === f.tag) {
                    g = f.return;
                    if (null === g) throw Error(p$3(341));
                    g.lanes |= c;
                    h = g.alternate;
                    null !== h && (h.lanes |= c);
                    bh(g, c, b);
                    g = f.sibling;
                  } else g = f.child;
                  if (null !== g) g.return = f;else for (g = f; null !== g;) {
                    if (g === b) {
                      g = null;
                      break;
                    }
                    f = g.sibling;
                    if (null !== f) {
                      f.return = g.return;
                      g = f;
                      break;
                    }
                    g = g.return;
                  }
                  f = g;
                }
                Xi(a, b, e.children, c);
                b = b.child;
              }
              return b;
            case 9:
              return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
            case 14:
              return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
            case 15:
              return bj(a, b, b.type, b.pendingProps, c);
            case 17:
              return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
            case 19:
              return xj(a, b, c);
            case 22:
              return dj(a, b, c);
          }
          throw Error(p$3(156, b.tag));
        };
        function Fk(a, b) {
          return ac(a, b);
        }
        function $k(a, b, c, d) {
          this.tag = a;
          this.key = c;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = b;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = d;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
        }
        function Bg(a, b, c, d) {
          return new $k(a, b, c, d);
        }
        function aj(a) {
          a = a.prototype;
          return !(!a || !a.isReactComponent);
        }
        function Zk(a) {
          if ("function" === typeof a) return aj(a) ? 1 : 0;
          if (void 0 !== a && null !== a) {
            a = a.$$typeof;
            if (a === Da) return 11;
            if (a === Ga) return 14;
          }
          return 2;
        }
        function Pg(a, b) {
          var c = a.alternate;
          null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
          c.flags = a.flags & 14680064;
          c.childLanes = a.childLanes;
          c.lanes = a.lanes;
          c.child = a.child;
          c.memoizedProps = a.memoizedProps;
          c.memoizedState = a.memoizedState;
          c.updateQueue = a.updateQueue;
          b = a.dependencies;
          c.dependencies = null === b ? null : {
            lanes: b.lanes,
            firstContext: b.firstContext
          };
          c.sibling = a.sibling;
          c.index = a.index;
          c.ref = a.ref;
          return c;
        }
        function Rg(a, b, c, d, e, f) {
          var g = 2;
          d = a;
          if ("function" === typeof a) aj(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              g = 8;
              e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
            case Ia:
              return pj(c, e, f, b);
            default:
              if ("object" === typeof a && null !== a) switch (a.$$typeof) {
                case Ba:
                  g = 10;
                  break a;
                case Ca:
                  g = 9;
                  break a;
                case Da:
                  g = 11;
                  break a;
                case Ga:
                  g = 14;
                  break a;
                case Ha:
                  g = 16;
                  d = null;
                  break a;
              }
              throw Error(p$3(130, null == a ? a : typeof a, ""));
          }
          b = Bg(g, c, b, e);
          b.elementType = a;
          b.type = d;
          b.lanes = f;
          return b;
        }
        function Tg(a, b, c, d) {
          a = Bg(7, a, d, b);
          a.lanes = c;
          return a;
        }
        function pj(a, b, c, d) {
          a = Bg(22, a, d, b);
          a.elementType = Ia;
          a.lanes = c;
          a.stateNode = {
            isHidden: false
          };
          return a;
        }
        function Qg(a, b, c) {
          a = Bg(6, a, null, b);
          a.lanes = c;
          return a;
        }
        function Sg(a, b, c) {
          b = Bg(4, null !== a.children ? a.children : [], a.key, b);
          b.lanes = c;
          b.stateNode = {
            containerInfo: a.containerInfo,
            pendingChildren: null,
            implementation: a.implementation
          };
          return b;
        }
        function al(a, b, c, d, e) {
          this.tag = b;
          this.containerInfo = a;
          this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = -1;
          this.callbackNode = this.pendingContext = this.context = null;
          this.callbackPriority = 0;
          this.eventTimes = zc(0);
          this.expirationTimes = zc(-1);
          this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = zc(0);
          this.identifierPrefix = d;
          this.onRecoverableError = e;
          this.mutableSourceEagerHydrationData = null;
        }
        function bl(a, b, c, d, e, f, g, h, k) {
          a = new al(a, b, c, h, k);
          1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
          f = Bg(3, null, null, b);
          a.current = f;
          f.stateNode = a;
          f.memoizedState = {
            element: d,
            isDehydrated: c,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          kh(f);
          return a;
        }
        function cl(a, b, c) {
          var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          return {
            $$typeof: wa,
            key: null == d ? null : "" + d,
            children: a,
            containerInfo: b,
            implementation: c
          };
        }
        function dl(a) {
          if (!a) return Vf;
          a = a._reactInternals;
          a: {
            if (Vb(a) !== a || 1 !== a.tag) throw Error(p$3(170));
            var b = a;
            do {
              switch (b.tag) {
                case 3:
                  b = b.stateNode.context;
                  break a;
                case 1:
                  if (Zf(b.type)) {
                    b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                    break a;
                  }
              }
              b = b.return;
            } while (null !== b);
            throw Error(p$3(171));
          }
          if (1 === a.tag) {
            var c = a.type;
            if (Zf(c)) return bg(a, c, b);
          }
          return b;
        }
        function el(a, b, c, d, e, f, g, h, k) {
          a = bl(c, d, true, a, e, f, g, h, k);
          a.context = dl(null);
          c = a.current;
          d = R$1();
          e = yi(c);
          f = mh(d, e);
          f.callback = void 0 !== b && null !== b ? b : null;
          nh(c, f, e);
          a.current.lanes = e;
          Ac(a, e, d);
          Dk(a, d);
          return a;
        }
        function fl(a, b, c, d) {
          var e = b.current,
            f = R$1(),
            g = yi(e);
          c = dl(c);
          null === b.context ? b.context = c : b.pendingContext = c;
          b = mh(f, g);
          b.payload = {
            element: a
          };
          d = void 0 === d ? null : d;
          null !== d && (b.callback = d);
          a = nh(e, b, g);
          null !== a && (gi(a, e, g, f), oh(a, e, g));
          return g;
        }
        function gl(a) {
          a = a.current;
          if (!a.child) return null;
          switch (a.child.tag) {
            case 5:
              return a.child.stateNode;
            default:
              return a.child.stateNode;
          }
        }
        function hl(a, b) {
          a = a.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            var c = a.retryLane;
            a.retryLane = 0 !== c && c < b ? c : b;
          }
        }
        function il(a, b) {
          hl(a, b);
          (a = a.alternate) && hl(a, b);
        }
        function jl() {
          return null;
        }
        var kl = "function" === typeof reportError ? reportError : function (a) {
          console.error(a);
        };
        function ll(a) {
          this._internalRoot = a;
        }
        ml.prototype.render = ll.prototype.render = function (a) {
          var b = this._internalRoot;
          if (null === b) throw Error(p$3(409));
          fl(a, b, null, null);
        };
        ml.prototype.unmount = ll.prototype.unmount = function () {
          var a = this._internalRoot;
          if (null !== a) {
            this._internalRoot = null;
            var b = a.containerInfo;
            Rk(function () {
              fl(null, a, null, null);
            });
            b[uf] = null;
          }
        };
        function ml(a) {
          this._internalRoot = a;
        }
        ml.prototype.unstable_scheduleHydration = function (a) {
          if (a) {
            var b = Hc();
            a = {
              blockedOn: null,
              target: a,
              priority: b
            };
            for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
            Qc.splice(c, 0, a);
            0 === c && Vc(a);
          }
        };
        function nl(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
        }
        function ol(a) {
          return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
        }
        function pl() {}
        function ql(a, b, c, d, e) {
          if (e) {
            if ("function" === typeof d) {
              var f = d;
              d = function () {
                var a = gl(g);
                f.call(a);
              };
            }
            var g = el(b, d, a, 0, null, false, false, "", pl);
            a._reactRootContainer = g;
            a[uf] = g.current;
            sf(8 === a.nodeType ? a.parentNode : a);
            Rk();
            return g;
          }
          for (; e = a.lastChild;) a.removeChild(e);
          if ("function" === typeof d) {
            var h = d;
            d = function () {
              var a = gl(k);
              h.call(a);
            };
          }
          var k = bl(a, 0, false, null, null, false, false, "", pl);
          a._reactRootContainer = k;
          a[uf] = k.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk(function () {
            fl(b, k, c, d);
          });
          return k;
        }
        function rl(a, b, c, d, e) {
          var f = c._reactRootContainer;
          if (f) {
            var g = f;
            if ("function" === typeof e) {
              var h = e;
              e = function () {
                var a = gl(g);
                h.call(a);
              };
            }
            fl(b, g, a, e);
          } else g = ql(c, b, a, e, d);
          return gl(g);
        }
        Ec = function (a) {
          switch (a.tag) {
            case 3:
              var b = a.stateNode;
              if (b.current.memoizedState.isDehydrated) {
                var c = tc(b.pendingLanes);
                0 !== c && (Cc(b, c | 1), Dk(b, B$2()), 0 === (K$1 & 6) && (Gj = B$2() + 500, jg()));
              }
              break;
            case 13:
              Rk(function () {
                var b = ih(a, 1);
                if (null !== b) {
                  var c = R$1();
                  gi(b, a, 1, c);
                }
              }), il(a, 1);
          }
        };
        Fc = function (a) {
          if (13 === a.tag) {
            var b = ih(a, 134217728);
            if (null !== b) {
              var c = R$1();
              gi(b, a, 134217728, c);
            }
            il(a, 134217728);
          }
        };
        Gc = function (a) {
          if (13 === a.tag) {
            var b = yi(a),
              c = ih(a, b);
            if (null !== c) {
              var d = R$1();
              gi(c, a, b, d);
            }
            il(a, b);
          }
        };
        Hc = function () {
          return C$1;
        };
        Ic = function (a, b) {
          var c = C$1;
          try {
            return C$1 = a, b();
          } finally {
            C$1 = c;
          }
        };
        yb = function (a, b, c) {
          switch (b) {
            case "input":
              bb(a, c);
              b = c.name;
              if ("radio" === c.type && null != b) {
                for (c = a; c.parentNode;) c = c.parentNode;
                c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                for (b = 0; b < c.length; b++) {
                  var d = c[b];
                  if (d !== a && d.form === a.form) {
                    var e = Db(d);
                    if (!e) throw Error(p$3(90));
                    Wa(d);
                    bb(d, e);
                  }
                }
              }
              break;
            case "textarea":
              ib(a, c);
              break;
            case "select":
              b = c.value, null != b && fb(a, !!c.multiple, b, false);
          }
        };
        Gb = Qk;
        Hb = Rk;
        var sl = {
            usingClientEntryPoint: false,
            Events: [Cb, ue$1, Db, Eb, Fb, Qk]
          },
          tl = {
            findFiberByHostInstance: Wc,
            bundleType: 0,
            version: "18.3.1",
            rendererPackageName: "react-dom"
          };
        var ul = {
          bundleType: tl.bundleType,
          version: tl.version,
          rendererPackageName: tl.rendererPackageName,
          rendererConfig: tl.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: ua.ReactCurrentDispatcher,
          findHostInstanceByFiber: function (a) {
            a = Zb(a);
            return null === a ? null : a.stateNode;
          },
          findFiberByHostInstance: tl.findFiberByHostInstance || jl,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
        };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!vl.isDisabled && vl.supportsFiber) try {
            kc = vl.inject(ul), lc = vl;
          } catch (a) {}
        }
        reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
        reactDom_production_min.createPortal = function (a, b) {
          var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!nl(b)) throw Error(p$3(200));
          return cl(a, b, null, c);
        };
        reactDom_production_min.createRoot = function (a, b) {
          if (!nl(a)) throw Error(p$3(299));
          var c = false,
            d = "",
            e = kl;
          null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
          b = bl(a, 1, false, null, null, c, false, d, e);
          a[uf] = b.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          return new ll(b);
        };
        reactDom_production_min.findDOMNode = function (a) {
          if (null == a) return null;
          if (1 === a.nodeType) return a;
          var b = a._reactInternals;
          if (void 0 === b) {
            if ("function" === typeof a.render) throw Error(p$3(188));
            a = Object.keys(a).join(",");
            throw Error(p$3(268, a));
          }
          a = Zb(b);
          a = null === a ? null : a.stateNode;
          return a;
        };
        reactDom_production_min.flushSync = function (a) {
          return Rk(a);
        };
        reactDom_production_min.hydrate = function (a, b, c) {
          if (!ol(b)) throw Error(p$3(200));
          return rl(null, a, b, true, c);
        };
        reactDom_production_min.hydrateRoot = function (a, b, c) {
          if (!nl(a)) throw Error(p$3(405));
          var d = null != c && c.hydratedSources || null,
            e = false,
            f = "",
            g = kl;
          null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
          b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
          a[uf] = b.current;
          sf(a);
          if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(c, e);
          return new ml(b);
        };
        reactDom_production_min.render = function (a, b, c) {
          if (!ol(b)) throw Error(p$3(200));
          return rl(null, a, b, false, c);
        };
        reactDom_production_min.unmountComponentAtNode = function (a) {
          if (!ol(a)) throw Error(p$3(40));
          return a._reactRootContainer ? (Rk(function () {
            rl(null, null, a, !1, function () {
              a._reactRootContainer = null;
              a[uf] = null;
            });
          }), true) : false;
        };
        reactDom_production_min.unstable_batchedUpdates = Qk;
        reactDom_production_min.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
          if (!ol(c)) throw Error(p$3(200));
          if (null == a || void 0 === a._reactInternals) throw Error(p$3(38));
          return rl(a, b, c, false, d);
        };
        reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
        function checkDCE() {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
            return;
          }
          try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
          } catch (err) {
            console.error(err);
          }
        }
        {
          checkDCE();
          reactDom.exports = reactDom_production_min;
        }
        var reactDomExports = reactDom.exports;
        var createRoot;
        var m$4 = reactDomExports;
        {
          createRoot = m$4.createRoot;
          m$4.hydrateRoot;
        }
        function r$2(e) {
          var t,
            f,
            n = "";
          if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) {
            var o = e.length;
            for (t = 0; t < o; t++) e[t] && (f = r$2(e[t])) && (n && (n += " "), n += f);
          } else for (f in e) e[f] && (n && (n += " "), n += f);
          return n;
        }
        function clsx() {
          for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r$2(e)) && (n && (n += " "), n += t);
          return n;
        }

        /*!
         * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
         *
         * Copyright (c) 2014-2017, Jon Schlinkert.
         * Released under the MIT License.
         */

        function isObject(o) {
          return Object.prototype.toString.call(o) === '[object Object]';
        }
        function isPlainObject(o) {
          var ctor, prot;
          if (isObject(o) === false) return false;

          // If has modified constructor
          ctor = o.constructor;
          if (ctor === undefined) return true;

          // If has modified prototype
          prot = ctor.prototype;
          if (isObject(prot) === false) return false;

          // If constructor does not have an Object-specific method
          if (prot.hasOwnProperty('isPrototypeOf') === false) {
            return false;
          }

          // Most likely a plain Object
          return true;
        }

        /******************************************************************************
        Copyright (c) Microsoft Corporation.
        	Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise, SuppressedError, Symbol, Iterator */

        var __assign$1 = function () {
          __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign$1.apply(this, arguments);
        };
        typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };

        /**
         * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
         */
        /**
         * Lower case as a function.
         */
        function lowerCase(str) {
          return str.toLowerCase();
        }

        // Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
        var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
        // Remove all non-word characters.
        var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
        /**
         * Normalize the string into something other libraries can manipulate easier.
         */
        function noCase(input, options) {
          if (options === void 0) {
            options = {};
          }
          var _a = options.splitRegexp,
            splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a,
            _b = options.stripRegexp,
            stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b,
            _c = options.transform,
            transform = _c === void 0 ? lowerCase : _c,
            _d = options.delimiter,
            delimiter = _d === void 0 ? " " : _d;
          var result = replace$2(replace$2(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
          var start = 0;
          var end = result.length;
          // Trim the delimiter from around the output string.
          while (result.charAt(start) === "\0") start++;
          while (result.charAt(end - 1) === "\0") end--;
          // Transform each token independently.
          return result.slice(start, end).split("\0").map(transform).join(delimiter);
        }
        /**
         * Replace `re` in the input string with the replacement value.
         */
        function replace$2(input, re, value) {
          if (re instanceof RegExp) return input.replace(re, value);
          return re.reduce(function (input, re) {
            return input.replace(re, value);
          }, input);
        }
        function dotCase(input, options) {
          if (options === void 0) {
            options = {};
          }
          return noCase(input, __assign$1({
            delimiter: "."
          }, options));
        }
        function paramCase(input, options) {
          if (options === void 0) {
            options = {};
          }
          return dotCase(input, __assign$1({
            delimiter: "-"
          }, options));
        }

        /**
         * External dependencies
         */

        /**
         * @param {import('react').ComponentPropsWithoutRef<'path'>} props
         *
         * @return {JSX.Element} Path component
         */
        const Path = props => reactExports.createElement('path', props);
        const SVG = reactExports.forwardRef(
        /**
         * @param {SVGProps}                                    props isPressed indicates whether the SVG should appear as pressed.
         *                                                            Other props will be passed through to svg component.
         * @param {import('react').ForwardedRef<SVGSVGElement>} ref   The forwarded ref to the SVG element.
         *
         * @return {JSX.Element} Stop component
         */
        ({
          className,
          isPressed,
          ...props
        }, ref) => {
          const appliedProps = {
            ...props,
            className: clsx(className, {
              'is-pressed': isPressed
            }) || undefined,
            'aria-hidden': true,
            focusable: false
          };

          // Disable reason: We need to have a way to render HTML tag for web.
          // eslint-disable-next-line react/forbid-elements
          return /*#__PURE__*/jsxRuntimeExports.jsx("svg", {
            ...appliedProps,
            ref: ref
          });
        });
        SVG.displayName = 'SVG';

        /**
         * Memize options object.
         *
         * @typedef MemizeOptions
         *
         * @property {number} [maxSize] Maximum size of the cache.
         */

        /**
         * Internal cache entry.
         *
         * @typedef MemizeCacheNode
         *
         * @property {?MemizeCacheNode|undefined} [prev] Previous node.
         * @property {?MemizeCacheNode|undefined} [next] Next node.
         * @property {Array<*>}                   args   Function arguments for cache
         *                                               entry.
         * @property {*}                          val    Function result.
         */

        /**
         * Properties of the enhanced function for controlling cache.
         *
         * @typedef MemizeMemoizedFunction
         *
         * @property {()=>void} clear Clear the cache.
         */

        /**
         * Accepts a function to be memoized, and returns a new memoized function, with
         * optional options.
         *
         * @template {(...args: any[]) => any} F
         *
         * @param {F}             fn        Function to memoize.
         * @param {MemizeOptions} [options] Options object.
         *
         * @return {((...args: Parameters<F>) => ReturnType<F>) & MemizeMemoizedFunction} Memoized function.
         */
        function memize(fn, options) {
          var size = 0;

          /** @type {?MemizeCacheNode|undefined} */
          var head;

          /** @type {?MemizeCacheNode|undefined} */
          var tail;
          options = options || {};
          function memoized(/* ...args */
          ) {
            var node = head,
              len = arguments.length,
              args,
              i;
            searchCache: while (node) {
              // Perform a shallow equality test to confirm that whether the node
              // under test is a candidate for the arguments passed. Two arrays
              // are shallowly equal if their length matches and each entry is
              // strictly equal between the two sets. Avoid abstracting to a
              // function which could incur an arguments leaking deoptimization.

              // Check whether node arguments match arguments length
              if (node.args.length !== arguments.length) {
                node = node.next;
                continue;
              }

              // Check whether node arguments match arguments values
              for (i = 0; i < len; i++) {
                if (node.args[i] !== arguments[i]) {
                  node = node.next;
                  continue searchCache;
                }
              }

              // At this point we can assume we've found a match

              // Surface matched node to head if not already
              if (node !== head) {
                // As tail, shift to previous. Must only shift if not also
                // head, since if both head and tail, there is no previous.
                if (node === tail) {
                  tail = node.prev;
                }

                // Adjust siblings to point to each other. If node was tail,
                // this also handles new tail's empty `next` assignment.
                /** @type {MemizeCacheNode} */
                node.prev.next = node.next;
                if (node.next) {
                  node.next.prev = node.prev;
                }
                node.next = head;
                node.prev = null;
                /** @type {MemizeCacheNode} */
                head.prev = node;
                head = node;
              }

              // Return immediately
              return node.val;
            }

            // No cached value found. Continue to insertion phase:

            // Create a copy of arguments (avoid leaking deoptimization)
            args = new Array(len);
            for (i = 0; i < len; i++) {
              args[i] = arguments[i];
            }
            node = {
              args: args,
              // Generate the result from original function
              val: fn.apply(null, args)
            };

            // Don't need to check whether node is already head, since it would
            // have been returned above already if it was

            // Shift existing head down list
            if (head) {
              head.prev = node;
              node.next = head;
            } else {
              // If no head, follows that there's no tail (at initial or reset)
              tail = node;
            }

            // Trim tail if we're reached max size and are pending cache insertion
            if (size === /** @type {MemizeOptions} */options.maxSize) {
              tail = /** @type {MemizeCacheNode} */tail.prev;
              /** @type {MemizeCacheNode} */
              tail.next = null;
            } else {
              size++;
            }
            head = node;
            return node.val;
          }
          memoized.clear = function () {
            head = null;
            tail = null;
            size = 0;
          };

          // Ignore reason: There's not a clear solution to create an intersection of
          // the function with additional properties, where the goal is to retain the
          // function signature of the incoming argument and add control properties
          // on the return value.

          // @ts-ignore
          return memoized;
        }
        var sprintf = {};

        /* global window, exports, define */

        (function (exports) {
          !function () {
            var re = {
              not_type: /[^T]/,
              not_primitive: /[^v]/,
              number: /[diefg]/,
              numeric_arg: /[bcdiefguxX]/,
              json: /[j]/,
              text: /^[^\x25]+/,
              modulo: /^\x25{2}/,
              placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
              key: /^([a-z_][a-z_\d]*)/i,
              key_access: /^\.([a-z_][a-z_\d]*)/i,
              index_access: /^\[(\d+)\]/,
              sign: /^[+-]/
            };
            function sprintf(key) {
              // `arguments` is not an array, but should be fine for this call
              return sprintf_format(sprintf_parse(key), arguments);
            }
            function vsprintf(fmt, argv) {
              return sprintf.apply(null, [fmt].concat(argv || []));
            }
            function sprintf_format(parse_tree, argv) {
              var cursor = 1,
                tree_length = parse_tree.length,
                arg,
                output = '',
                i,
                k,
                ph,
                pad,
                pad_character,
                pad_length,
                is_positive,
                sign;
              for (i = 0; i < tree_length; i++) {
                if (typeof parse_tree[i] === 'string') {
                  output += parse_tree[i];
                } else if (typeof parse_tree[i] === 'object') {
                  ph = parse_tree[i]; // convenience purposes only
                  if (ph.keys) {
                    // keyword argument
                    arg = argv[cursor];
                    for (k = 0; k < ph.keys.length; k++) {
                      if (arg == undefined) {
                        throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                      }
                      arg = arg[ph.keys[k]];
                    }
                  } else if (ph.param_no) {
                    // positional argument (explicit)
                    arg = argv[ph.param_no];
                  } else {
                    // positional argument (implicit)
                    arg = argv[cursor++];
                  }
                  if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg();
                  }
                  if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
                  }
                  if (re.number.test(ph.type)) {
                    is_positive = arg >= 0;
                  }
                  switch (ph.type) {
                    case 'b':
                      arg = parseInt(arg, 10).toString(2);
                      break;
                    case 'c':
                      arg = String.fromCharCode(parseInt(arg, 10));
                      break;
                    case 'd':
                    case 'i':
                      arg = parseInt(arg, 10);
                      break;
                    case 'j':
                      arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                      break;
                    case 'e':
                      arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                      break;
                    case 'f':
                      arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                      break;
                    case 'g':
                      arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                      break;
                    case 'o':
                      arg = (parseInt(arg, 10) >>> 0).toString(8);
                      break;
                    case 's':
                      arg = String(arg);
                      arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                      break;
                    case 't':
                      arg = String(!!arg);
                      arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                      break;
                    case 'T':
                      arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                      arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                      break;
                    case 'u':
                      arg = parseInt(arg, 10) >>> 0;
                      break;
                    case 'v':
                      arg = arg.valueOf();
                      arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                      break;
                    case 'x':
                      arg = (parseInt(arg, 10) >>> 0).toString(16);
                      break;
                    case 'X':
                      arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                      break;
                  }
                  if (re.json.test(ph.type)) {
                    output += arg;
                  } else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                      sign = is_positive ? '+' : '-';
                      arg = arg.toString().replace(re.sign, '');
                    } else {
                      sign = '';
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
                    pad_length = ph.width - (sign + arg).length;
                    pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
                    output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
                  }
                }
              }
              return output;
            }
            var sprintf_cache = Object.create(null);
            function sprintf_parse(fmt) {
              if (sprintf_cache[fmt]) {
                return sprintf_cache[fmt];
              }
              var _fmt = fmt,
                match,
                parse_tree = [],
                arg_names = 0;
              while (_fmt) {
                if ((match = re.text.exec(_fmt)) !== null) {
                  parse_tree.push(match[0]);
                } else if ((match = re.modulo.exec(_fmt)) !== null) {
                  parse_tree.push('%');
                } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                  if (match[2]) {
                    arg_names |= 1;
                    var field_list = [],
                      replacement_field = match[2],
                      field_match = [];
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                      while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                        if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                        } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                        } else {
                          throw new SyntaxError('[sprintf] failed to parse named argument key');
                        }
                      }
                    } else {
                      throw new SyntaxError('[sprintf] failed to parse named argument key');
                    }
                    match[2] = field_list;
                  } else {
                    arg_names |= 2;
                  }
                  if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                  }
                  parse_tree.push({
                    placeholder: match[0],
                    param_no: match[1],
                    keys: match[2],
                    sign: match[3],
                    pad_char: match[4],
                    align: match[5],
                    width: match[6],
                    precision: match[7],
                    type: match[8]
                  });
                } else {
                  throw new SyntaxError('[sprintf] unexpected placeholder');
                }
                _fmt = _fmt.substring(match[0].length);
              }
              return sprintf_cache[fmt] = parse_tree;
            }

            /**
             * export to either browser or node.js
             */
            /* eslint-disable quote-props */
            {
              exports['sprintf'] = sprintf;
              exports['vsprintf'] = vsprintf;
            }
            if (typeof window !== 'undefined') {
              window['sprintf'] = sprintf;
              window['vsprintf'] = vsprintf;
            }
            /* eslint-enable quote-props */
          }(); // eslint-disable-line 
        })(sprintf);

        /**
         * External dependencies
         */

        /**
         * Log to console, once per message; or more precisely, per referentially equal
         * argument set. Because Jed throws errors, we log these to the console instead
         * to avoid crashing the application.
         *
         * @param {...*} args Arguments to pass to `console.error`
         */
        memize(console.error); // eslint-disable-line no-console

        var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;

        /**
         * Operator precedence mapping.
         *
         * @type {Object}
         */
        PRECEDENCE = {
          '(': 9,
          '!': 8,
          '*': 7,
          '/': 7,
          '%': 7,
          '+': 6,
          '-': 6,
          '<': 5,
          '<=': 5,
          '>': 5,
          '>=': 5,
          '==': 4,
          '!=': 4,
          '&&': 3,
          '||': 2,
          '?': 1,
          '?:': 1
        };

        /**
         * Characters which signal pair opening, to be terminated by terminators.
         *
         * @type {string[]}
         */
        OPENERS = ['(', '?'];

        /**
         * Characters which signal pair termination, the value an array with the
         * opener as its first member. The second member is an optional operator
         * replacement to push to the stack.
         *
         * @type {string[]}
         */
        TERMINATORS = {
          ')': ['('],
          ':': ['?', '?:']
        };

        /**
         * Pattern matching operators and openers.
         *
         * @type {RegExp}
         */
        PATTERN = /<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;

        /**
         * Given a C expression, returns the equivalent postfix (Reverse Polish)
         * notation terms as an array.
         *
         * If a postfix string is desired, simply `.join( ' ' )` the result.
         *
         * @example
         *
         * ```js
         * import postfix from '@tannin/postfix';
         *
         * postfix( 'n > 1' );
         * // ⇒ [ 'n', '1', '>' ]
         * ```
         *
         * @param {string} expression C expression.
         *
         * @return {string[]} Postfix terms.
         */
        function postfix(expression) {
          var terms = [],
            stack = [],
            match,
            operator,
            term,
            element;
          while (match = expression.match(PATTERN)) {
            operator = match[0];

            // Term is the string preceding the operator match. It may contain
            // whitespace, and may be empty (if operator is at beginning).
            term = expression.substr(0, match.index).trim();
            if (term) {
              terms.push(term);
            }
            while (element = stack.pop()) {
              if (TERMINATORS[operator]) {
                if (TERMINATORS[operator][0] === element) {
                  // Substitution works here under assumption that because
                  // the assigned operator will no longer be a terminator, it
                  // will be pushed to the stack during the condition below.
                  operator = TERMINATORS[operator][1] || operator;
                  break;
                }
              } else if (OPENERS.indexOf(element) >= 0 || PRECEDENCE[element] < PRECEDENCE[operator]) {
                // Push to stack if either an opener or when pop reveals an
                // element of lower precedence.
                stack.push(element);
                break;
              }

              // For each popped from stack, push to terms.
              terms.push(element);
            }
            if (!TERMINATORS[operator]) {
              stack.push(operator);
            }

            // Slice matched fragment from expression to continue match.
            expression = expression.substr(match.index + operator.length);
          }

          // Push remainder of operand, if exists, to terms.
          expression = expression.trim();
          if (expression) {
            terms.push(expression);
          }

          // Pop remaining items from stack into terms.
          return terms.concat(stack.reverse());
        }

        /**
         * Operator callback functions.
         *
         * @type {Object}
         */
        var OPERATORS = {
          '!': function (a) {
            return !a;
          },
          '*': function (a, b) {
            return a * b;
          },
          '/': function (a, b) {
            return a / b;
          },
          '%': function (a, b) {
            return a % b;
          },
          '+': function (a, b) {
            return a + b;
          },
          '-': function (a, b) {
            return a - b;
          },
          '<': function (a, b) {
            return a < b;
          },
          '<=': function (a, b) {
            return a <= b;
          },
          '>': function (a, b) {
            return a > b;
          },
          '>=': function (a, b) {
            return a >= b;
          },
          '==': function (a, b) {
            return a === b;
          },
          '!=': function (a, b) {
            return a !== b;
          },
          '&&': function (a, b) {
            return a && b;
          },
          '||': function (a, b) {
            return a || b;
          },
          '?:': function (a, b, c) {
            if (a) {
              throw b;
            }
            return c;
          }
        };

        /**
         * Given an array of postfix terms and operand variables, returns the result of
         * the postfix evaluation.
         *
         * @example
         *
         * ```js
         * import evaluate from '@tannin/evaluate';
         *
         * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'
         * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];
         *
         * evaluate( terms, {} );
         * // ⇒ 6.333333333333334
         * ```
         *
         * @param {string[]} postfix   Postfix terms.
         * @param {Object}   variables Operand variables.
         *
         * @return {*} Result of evaluation.
         */
        function evaluate$1(postfix, variables) {
          var stack = [],
            i,
            j,
            args,
            getOperatorResult,
            term,
            value;
          for (i = 0; i < postfix.length; i++) {
            term = postfix[i];
            getOperatorResult = OPERATORS[term];
            if (getOperatorResult) {
              // Pop from stack by number of function arguments.
              j = getOperatorResult.length;
              args = Array(j);
              while (j--) {
                args[j] = stack.pop();
              }
              try {
                value = getOperatorResult.apply(null, args);
              } catch (earlyReturn) {
                return earlyReturn;
              }
            } else if (variables.hasOwnProperty(term)) {
              value = variables[term];
            } else {
              value = +term;
            }
            stack.push(value);
          }
          return stack[0];
        }

        /**
         * Given a C expression, returns a function which can be called to evaluate its
         * result.
         *
         * @example
         *
         * ```js
         * import compile from '@tannin/compile';
         *
         * const evaluate = compile( 'n > 1' );
         *
         * evaluate( { n: 2 } );
         * // ⇒ true
         * ```
         *
         * @param {string} expression C expression.
         *
         * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.
         */
        function compile$2(expression) {
          var terms = postfix(expression);
          return function (variables) {
            return evaluate$1(terms, variables);
          };
        }

        /**
         * Given a C expression, returns a function which, when called with a value,
         * evaluates the result with the value assumed to be the "n" variable of the
         * expression. The result will be coerced to its numeric equivalent.
         *
         * @param {string} expression C expression.
         *
         * @return {Function} Evaluator function.
         */
        function pluralForms(expression) {
          var evaluate = compile$2(expression);
          return function (n) {
            return +evaluate({
              n: n
            });
          };
        }

        /**
         * Tannin constructor options.
         *
         * @typedef {Object} TanninOptions
         *
         * @property {string}   [contextDelimiter] Joiner in string lookup with context.
         * @property {Function} [onMissingKey]     Callback to invoke when key missing.
         */

        /**
         * Domain metadata.
         *
         * @typedef {Object} TanninDomainMetadata
         *
         * @property {string}            [domain]       Domain name.
         * @property {string}            [lang]         Language code.
         * @property {(string|Function)} [plural_forms] Plural forms expression or
         *                                              function evaluator.
         */

        /**
         * Domain translation pair respectively representing the singular and plural
         * translation.
         *
         * @typedef {[string,string]} TanninTranslation
         */

        /**
         * Locale data domain. The key is used as reference for lookup, the value an
         * array of two string entries respectively representing the singular and plural
         * translation.
         *
         * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain
         */

        /**
         * Jed-formatted locale data.
         *
         * @see http://messageformat.github.io/Jed/
         *
         * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData
         */

        /**
         * Default Tannin constructor options.
         *
         * @type {TanninOptions}
         */
        var DEFAULT_OPTIONS = {
          contextDelimiter: '\u0004',
          onMissingKey: null
        };

        /**
         * Given a specific locale data's config `plural_forms` value, returns the
         * expression.
         *
         * @example
         *
         * ```
         * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'
         * ```
         *
         * @param {string} pf Locale data plural forms.
         *
         * @return {string} Plural forms expression.
         */
        function getPluralExpression(pf) {
          var parts, i, part;
          parts = pf.split(';');
          for (i = 0; i < parts.length; i++) {
            part = parts[i].trim();
            if (part.indexOf('plural=') === 0) {
              return part.substr(7);
            }
          }
        }

        /**
         * Tannin constructor.
         *
         * @class
         *
         * @param {TanninLocaleData} data      Jed-formatted locale data.
         * @param {TanninOptions}    [options] Tannin options.
         */
        function Tannin(data, options) {
          var key;

          /**
           * Jed-formatted locale data.
           *
           * @name Tannin#data
           * @type {TanninLocaleData}
           */
          this.data = data;

          /**
           * Plural forms function cache, keyed by plural forms string.
           *
           * @name Tannin#pluralForms
           * @type {Object<string,Function>}
           */
          this.pluralForms = {};

          /**
           * Effective options for instance, including defaults.
           *
           * @name Tannin#options
           * @type {TanninOptions}
           */
          this.options = {};
          for (key in DEFAULT_OPTIONS) {
            this.options[key] = options !== undefined && key in options ? options[key] : DEFAULT_OPTIONS[key];
          }
        }

        /**
         * Returns the plural form index for the given domain and value.
         *
         * @param {string} domain Domain on which to calculate plural form.
         * @param {number} n      Value for which plural form is to be calculated.
         *
         * @return {number} Plural form index.
         */
        Tannin.prototype.getPluralForm = function (domain, n) {
          var getPluralForm = this.pluralForms[domain],
            config,
            plural,
            pf;
          if (!getPluralForm) {
            config = this.data[domain][''];
            pf = config['Plural-Forms'] || config['plural-forms'] ||
            // Ignore reason: As known, there's no way to document the empty
            // string property on a key to guarantee this as metadata.
            // @ts-ignore
            config.plural_forms;
            if (typeof pf !== 'function') {
              plural = getPluralExpression(config['Plural-Forms'] || config['plural-forms'] ||
              // Ignore reason: As known, there's no way to document the empty
              // string property on a key to guarantee this as metadata.
              // @ts-ignore
              config.plural_forms);
              pf = pluralForms(plural);
            }
            getPluralForm = this.pluralForms[domain] = pf;
          }
          return getPluralForm(n);
        };

        /**
         * Translate a string.
         *
         * @param {string}      domain   Translation domain.
         * @param {string|void} context  Context distinguishing terms of the same name.
         * @param {string}      singular Primary key for translation lookup.
         * @param {string=}     plural   Fallback value used for non-zero plural
         *                               form index.
         * @param {number=}     n        Value to use in calculating plural form.
         *
         * @return {string} Translated string.
         */
        Tannin.prototype.dcnpgettext = function (domain, context, singular, plural, n) {
          var index, key, entry;
          if (n === undefined) {
            // Default to singular.
            index = 0;
          } else {
            // Find index by evaluating plural form for value.
            index = this.getPluralForm(domain, n);
          }
          key = singular;

          // If provided, context is prepended to key with delimiter.
          if (context) {
            key = context + this.options.contextDelimiter + singular;
          }
          entry = this.data[domain][key];

          // Verify not only that entry exists, but that the intended index is within
          // range and non-empty.
          if (entry && entry[index]) {
            return entry[index];
          }
          if (this.options.onMissingKey) {
            this.options.onMissingKey(singular, domain);
          }

          // If entry not found, fall back to singular vs. plural with zero index
          // representing the singular value.
          return index === 0 ? singular : plural;
        };

        /**
         * External dependencies
         */

        /**
         * @typedef {Record<string,any>} LocaleData
         */

        /**
         * Default locale data to use for Tannin domain when not otherwise provided.
         * Assumes an English plural forms expression.
         *
         * @type {LocaleData}
         */
        const DEFAULT_LOCALE_DATA = {
          '': {
            /** @param {number} n */
            plural_forms(n) {
              return n === 1 ? 0 : 1;
            }
          }
        };

        /*
         * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,
         * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.
         */
        const I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;

        /**
         * @typedef {(domain?: string) => LocaleData} GetLocaleData
         *
         * Returns locale data by domain in a
         * Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         */
        /**
         * @typedef {(data?: LocaleData, domain?: string) => void} SetLocaleData
         *
         * Merges locale data into the Tannin instance by domain. Note that this
         * function will overwrite the domain configuration. Accepts data in a
         * Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         */
        /**
         * @typedef {(data?: LocaleData, domain?: string) => void} AddLocaleData
         *
         * Merges locale data into the Tannin instance by domain. Note that this
         * function will also merge the domain configuration. Accepts data in a
         * Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         */
        /**
         * @typedef {(data?: LocaleData, domain?: string) => void} ResetLocaleData
         *
         * Resets all current Tannin instance locale data and sets the specified
         * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         */
        /** @typedef {() => void} SubscribeCallback */
        /** @typedef {() => void} UnsubscribeCallback */
        /**
         * @typedef {(callback: SubscribeCallback) => UnsubscribeCallback} Subscribe
         *
         * Subscribes to changes of locale data
         */
        /**
         * @typedef {(domain?: string) => string} GetFilterDomain
         * Retrieve the domain to use when calling domain-specific filters.
         */
        /**
         * @typedef {(text: string, domain?: string) => string} __
         *
         * Retrieve the translation of text.
         *
         * @see https://developer.wordpress.org/reference/functions/__/
         */
        /**
         * @typedef {(text: string, context: string, domain?: string) => string} _x
         *
         * Retrieve translated string with gettext context.
         *
         * @see https://developer.wordpress.org/reference/functions/_x/
         */
        /**
         * @typedef {(single: string, plural: string, number: number, domain?: string) => string} _n
         *
         * Translates and retrieves the singular or plural form based on the supplied
         * number.
         *
         * @see https://developer.wordpress.org/reference/functions/_n/
         */
        /**
         * @typedef {(single: string, plural: string, number: number, context: string, domain?: string) => string} _nx
         *
         * Translates and retrieves the singular or plural form based on the supplied
         * number, with gettext context.
         *
         * @see https://developer.wordpress.org/reference/functions/_nx/
         */
        /**
         * @typedef {() => boolean} IsRtl
         *
         * Check if current locale is RTL.
         *
         * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
         * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
         * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
         * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
         */
        /**
         * @typedef {(single: string, context?: string, domain?: string) => boolean} HasTranslation
         *
         * Check if there is a translation for a given string in singular form.
         */
        /** @typedef {import('@wordpress/hooks').Hooks} Hooks */

        /**
         * An i18n instance
         *
         * @typedef I18n
         * @property {GetLocaleData}   getLocaleData   Returns locale data by domain in a Jed-formatted JSON object shape.
         * @property {SetLocaleData}   setLocaleData   Merges locale data into the Tannin instance by domain. Note that this
         *                                             function will overwrite the domain configuration. Accepts data in a
         *                                             Jed-formatted JSON object shape.
         * @property {AddLocaleData}   addLocaleData   Merges locale data into the Tannin instance by domain. Note that this
         *                                             function will also merge the domain configuration. Accepts data in a
         *                                             Jed-formatted JSON object shape.
         * @property {ResetLocaleData} resetLocaleData Resets all current Tannin instance locale data and sets the specified
         *                                             locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
         * @property {Subscribe}       subscribe       Subscribes to changes of Tannin locale data.
         * @property {__}              __              Retrieve the translation of text.
         * @property {_x}              _x              Retrieve translated string with gettext context.
         * @property {_n}              _n              Translates and retrieves the singular or plural form based on the supplied
         *                                             number.
         * @property {_nx}             _nx             Translates and retrieves the singular or plural form based on the supplied
         *                                             number, with gettext context.
         * @property {IsRtl}           isRTL           Check if current locale is RTL.
         * @property {HasTranslation}  hasTranslation  Check if there is a translation for a given string.
         */

        /**
         * Create an i18n instance
         *
         * @param {LocaleData} [initialData]   Locale data configuration.
         * @param {string}     [initialDomain] Domain for which configuration applies.
         * @param {Hooks}      [hooks]         Hooks implementation.
         *
         * @return {I18n} I18n instance.
         */
        const createI18n = (initialData, initialDomain, hooks) => {
          /**
           * The underlying instance of Tannin to which exported functions interface.
           *
           * @type {Tannin}
           */
          const tannin = new Tannin({});
          const listeners = new Set();
          const notifyListeners = () => {
            listeners.forEach(listener => listener());
          };

          /**
           * Subscribe to changes of locale data.
           *
           * @param {SubscribeCallback} callback Subscription callback.
           * @return {UnsubscribeCallback} Unsubscribe callback.
           */
          const subscribe = callback => {
            listeners.add(callback);
            return () => listeners.delete(callback);
          };

          /** @type {GetLocaleData} */
          const getLocaleData = (domain = 'default') => tannin.data[domain];

          /**
           * @param {LocaleData} [data]
           * @param {string}     [domain]
           */
          const doSetLocaleData = (data, domain = 'default') => {
            tannin.data[domain] = {
              ...tannin.data[domain],
              ...data
            };

            // Populate default domain configuration (supported locale date which omits
            // a plural forms expression).
            tannin.data[domain][''] = {
              ...DEFAULT_LOCALE_DATA[''],
              ...tannin.data[domain]?.['']
            };

            // Clean up cached plural forms functions cache as it might be updated.
            delete tannin.pluralForms[domain];
          };

          /** @type {SetLocaleData} */
          const setLocaleData = (data, domain) => {
            doSetLocaleData(data, domain);
            notifyListeners();
          };

          /** @type {AddLocaleData} */
          const addLocaleData = (data, domain = 'default') => {
            tannin.data[domain] = {
              ...tannin.data[domain],
              ...data,
              // Populate default domain configuration (supported locale date which omits
              // a plural forms expression).
              '': {
                ...DEFAULT_LOCALE_DATA[''],
                ...tannin.data[domain]?.[''],
                ...data?.['']
              }
            };

            // Clean up cached plural forms functions cache as it might be updated.
            delete tannin.pluralForms[domain];
            notifyListeners();
          };

          /** @type {ResetLocaleData} */
          const resetLocaleData = (data, domain) => {
            // Reset all current Tannin locale data.
            tannin.data = {};

            // Reset cached plural forms functions cache.
            tannin.pluralForms = {};
            setLocaleData(data, domain);
          };

          /**
           * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not
           * otherwise previously assigned.
           *
           * @param {string|undefined} domain   Domain to retrieve the translated text.
           * @param {string|undefined} context  Context information for the translators.
           * @param {string}           single   Text to translate if non-plural. Used as
           *                                    fallback return value on a caught error.
           * @param {string}           [plural] The text to be used if the number is
           *                                    plural.
           * @param {number}           [number] The number to compare against to use
           *                                    either the singular or plural form.
           *
           * @return {string} The translated string.
           */
          const dcnpgettext = (domain = 'default', context, single, plural, number) => {
            if (!tannin.data[domain]) {
              // Use `doSetLocaleData` to set silently, without notifying listeners.
              doSetLocaleData(undefined, domain);
            }
            return tannin.dcnpgettext(domain, context, single, plural, number);
          };

          /** @type {GetFilterDomain} */
          const getFilterDomain = (domain = 'default') => domain;

          /** @type {__} */
          const __ = (text, domain) => {
            let translation = dcnpgettext(domain, undefined, text);
            if (!hooks) {
              return translation;
            }

            /**
             * Filters text with its translation.
             *
             * @param {string} translation Translated text.
             * @param {string} text        Text to translate.
             * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
             */
            translation = /** @type {string} */
            /** @type {*} */hooks.applyFilters('i18n.gettext', translation, text, domain);
            return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.gettext_' + getFilterDomain(domain), translation, text, domain);
          };

          /** @type {_x} */
          const _x = (text, context, domain) => {
            let translation = dcnpgettext(domain, context, text);
            if (!hooks) {
              return translation;
            }

            /**
             * Filters text with its translation based on context information.
             *
             * @param {string} translation Translated text.
             * @param {string} text        Text to translate.
             * @param {string} context     Context information for the translators.
             * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
             */
            translation = /** @type {string} */
            /** @type {*} */hooks.applyFilters('i18n.gettext_with_context', translation, text, context, domain);
            return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.gettext_with_context_' + getFilterDomain(domain), translation, text, context, domain);
          };

          /** @type {_n} */
          const _n = (single, plural, number, domain) => {
            let translation = dcnpgettext(domain, undefined, single, plural, number);
            if (!hooks) {
              return translation;
            }

            /**
             * Filters the singular or plural form of a string.
             *
             * @param {string} translation Translated text.
             * @param {string} single      The text to be used if the number is singular.
             * @param {string} plural      The text to be used if the number is plural.
             * @param {string} number      The number to compare against to use either the singular or plural form.
             * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
             */
            translation = /** @type {string} */
            /** @type {*} */hooks.applyFilters('i18n.ngettext', translation, single, plural, number, domain);
            return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.ngettext_' + getFilterDomain(domain), translation, single, plural, number, domain);
          };

          /** @type {_nx} */
          const _nx = (single, plural, number, context, domain) => {
            let translation = dcnpgettext(domain, context, single, plural, number);
            if (!hooks) {
              return translation;
            }

            /**
             * Filters the singular or plural form of a string with gettext context.
             *
             * @param {string} translation Translated text.
             * @param {string} single      The text to be used if the number is singular.
             * @param {string} plural      The text to be used if the number is plural.
             * @param {string} number      The number to compare against to use either the singular or plural form.
             * @param {string} context     Context information for the translators.
             * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
             */
            translation = /** @type {string} */
            /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context', translation, single, plural, number, context, domain);
            return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context_' + getFilterDomain(domain), translation, single, plural, number, context, domain);
          };

          /** @type {IsRtl} */
          const isRTL = () => {
            return 'rtl' === _x('ltr', 'text direction');
          };

          /** @type {HasTranslation} */
          const hasTranslation = (single, context, domain) => {
            const key = context ? context + '\u0004' + single : single;
            let result = !!tannin.data?.[domain !== null && domain !== void 0 ? domain : 'default']?.[key];
            if (hooks) {
              /**
               * Filters the presence of a translation in the locale data.
               *
               * @param {boolean} hasTranslation Whether the translation is present or not..
               * @param {string}  single         The singular form of the translated text (used as key in locale data)
               * @param {string}  context        Context information for the translators.
               * @param {string}  domain         Text domain. Unique identifier for retrieving translated strings.
               */
              result = /** @type { boolean } */
              /** @type {*} */hooks.applyFilters('i18n.has_translation', result, single, context, domain);
              result = /** @type { boolean } */
              /** @type {*} */hooks.applyFilters('i18n.has_translation_' + getFilterDomain(domain), result, single, context, domain);
            }
            return result;
          };
          if (hooks) {
            /**
             * @param {string} hookName
             */
            const onHookAddedOrRemoved = hookName => {
              if (I18N_HOOK_REGEXP.test(hookName)) {
                notifyListeners();
              }
            };
            hooks.addAction('hookAdded', 'core/i18n', onHookAddedOrRemoved);
            hooks.addAction('hookRemoved', 'core/i18n', onHookAddedOrRemoved);
          }
          return {
            getLocaleData,
            setLocaleData,
            addLocaleData,
            resetLocaleData,
            subscribe,
            __,
            _x,
            _n,
            _nx,
            isRTL,
            hasTranslation
          };
        };

        /**
         * Validate a namespace string.
         *
         * @param {string} namespace The namespace to validate - should take the form
         *                           `vendor/plugin/function`.
         *
         * @return {boolean} Whether the namespace is valid.
         */
        function validateNamespace(namespace) {
          if ('string' !== typeof namespace || '' === namespace) {
            // eslint-disable-next-line no-console
            console.error('The namespace must be a non-empty string.');
            return false;
          }
          if (!/^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(namespace)) {
            // eslint-disable-next-line no-console
            console.error('The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.');
            return false;
          }
          return true;
        }

        /**
         * Validate a hookName string.
         *
         * @param {string} hookName The hook name to validate. Should be a non empty string containing
         *                          only numbers, letters, dashes, periods and underscores. Also,
         *                          the hook name cannot begin with `__`.
         *
         * @return {boolean} Whether the hook name is valid.
         */
        function validateHookName(hookName) {
          if ('string' !== typeof hookName || '' === hookName) {
            // eslint-disable-next-line no-console
            console.error('The hook name must be a non-empty string.');
            return false;
          }
          if (/^__/.test(hookName)) {
            // eslint-disable-next-line no-console
            console.error('The hook name cannot begin with `__`.');
            return false;
          }
          if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {
            // eslint-disable-next-line no-console
            console.error('The hook name can only contain numbers, letters, dashes, periods and underscores.');
            return false;
          }
          return true;
        }

        /**
         * Internal dependencies
         */

        /**
         * @callback AddHook
         *
         * Adds the hook to the appropriate hooks container.
         *
         * @param {string}               hookName      Name of hook to add
         * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.
         * @param {import('.').Callback} callback      Function to call when the hook is run
         * @param {number}               [priority=10] Priority of this hook
         */

        /**
         * Returns a function which, when invoked, will add a hook.
         *
         * @param {import('.').Hooks}    hooks    Hooks instance.
         * @param {import('.').StoreKey} storeKey
         *
         * @return {AddHook} Function that adds a new hook.
         */
        function createAddHook(hooks, storeKey) {
          return function addHook(hookName, namespace, callback, priority = 10) {
            const hooksStore = hooks[storeKey];
            if (!validateHookName(hookName)) {
              return;
            }
            if (!validateNamespace(namespace)) {
              return;
            }
            if ('function' !== typeof callback) {
              // eslint-disable-next-line no-console
              console.error('The hook callback must be a function.');
              return;
            }

            // Validate numeric priority
            if ('number' !== typeof priority) {
              // eslint-disable-next-line no-console
              console.error('If specified, the hook priority must be a number.');
              return;
            }
            const handler = {
              callback,
              priority,
              namespace
            };
            if (hooksStore[hookName]) {
              // Find the correct insert index of the new hook.
              const handlers = hooksStore[hookName].handlers;

              /** @type {number} */
              let i;
              for (i = handlers.length; i > 0; i--) {
                if (priority >= handlers[i - 1].priority) {
                  break;
                }
              }
              if (i === handlers.length) {
                // If append, operate via direct assignment.
                handlers[i] = handler;
              } else {
                // Otherwise, insert before index via splice.
                handlers.splice(i, 0, handler);
              }

              // We may also be currently executing this hook.  If the callback
              // we're adding would come after the current callback, there's no
              // problem; otherwise we need to increase the execution index of
              // any other runs by 1 to account for the added element.
              hooksStore.__current.forEach(hookInfo => {
                if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
                  hookInfo.currentIndex++;
                }
              });
            } else {
              // This is the first hook of its type.
              hooksStore[hookName] = {
                handlers: [handler],
                runs: 0
              };
            }
            if (hookName !== 'hookAdded') {
              hooks.doAction('hookAdded', hookName, namespace, callback, priority);
            }
          };
        }

        /**
         * Internal dependencies
         */

        /**
         * @callback RemoveHook
         * Removes the specified callback (or all callbacks) from the hook with a given hookName
         * and namespace.
         *
         * @param {string} hookName  The name of the hook to modify.
         * @param {string} namespace The unique namespace identifying the callback in the
         *                           form `vendor/plugin/function`.
         *
         * @return {number | undefined} The number of callbacks removed.
         */

        /**
         * Returns a function which, when invoked, will remove a specified hook or all
         * hooks by the given name.
         *
         * @param {import('.').Hooks}    hooks             Hooks instance.
         * @param {import('.').StoreKey} storeKey
         * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,
         *                                                 without regard to namespace. Used to create
         *                                                 `removeAll*` functions.
         *
         * @return {RemoveHook} Function that removes hooks.
         */
        function createRemoveHook(hooks, storeKey, removeAll = false) {
          return function removeHook(hookName, namespace) {
            const hooksStore = hooks[storeKey];
            if (!validateHookName(hookName)) {
              return;
            }
            if (!removeAll && !validateNamespace(namespace)) {
              return;
            }

            // Bail if no hooks exist by this name.
            if (!hooksStore[hookName]) {
              return 0;
            }
            let handlersRemoved = 0;
            if (removeAll) {
              handlersRemoved = hooksStore[hookName].handlers.length;
              hooksStore[hookName] = {
                runs: hooksStore[hookName].runs,
                handlers: []
              };
            } else {
              // Try to find the specified callback to remove.
              const handlers = hooksStore[hookName].handlers;
              for (let i = handlers.length - 1; i >= 0; i--) {
                if (handlers[i].namespace === namespace) {
                  handlers.splice(i, 1);
                  handlersRemoved++;
                  // This callback may also be part of a hook that is
                  // currently executing.  If the callback we're removing
                  // comes after the current callback, there's no problem;
                  // otherwise we need to decrease the execution index of any
                  // other runs by 1 to account for the removed element.
                  hooksStore.__current.forEach(hookInfo => {
                    if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
                      hookInfo.currentIndex--;
                    }
                  });
                }
              }
            }
            if (hookName !== 'hookRemoved') {
              hooks.doAction('hookRemoved', hookName, namespace);
            }
            return handlersRemoved;
          };
        }

        /**
         * @callback HasHook
         *
         * Returns whether any handlers are attached for the given hookName and optional namespace.
         *
         * @param {string} hookName    The name of the hook to check for.
         * @param {string} [namespace] Optional. The unique namespace identifying the callback
         *                             in the form `vendor/plugin/function`.
         *
         * @return {boolean} Whether there are handlers that are attached to the given hook.
         */
        /**
         * Returns a function which, when invoked, will return whether any handlers are
         * attached to a particular hook.
         *
         * @param {import('.').Hooks}    hooks    Hooks instance.
         * @param {import('.').StoreKey} storeKey
         *
         * @return {HasHook} Function that returns whether any handlers are
         *                   attached to a particular hook and optional namespace.
         */
        function createHasHook(hooks, storeKey) {
          return function hasHook(hookName, namespace) {
            const hooksStore = hooks[storeKey];

            // Use the namespace if provided.
            if ('undefined' !== typeof namespace) {
              return hookName in hooksStore && hooksStore[hookName].handlers.some(hook => hook.namespace === namespace);
            }
            return hookName in hooksStore;
          };
        }
        function createRunHook(hooks, storeKey, returnFirstArg, async) {
          return function runHook(hookName, ...args) {
            const hooksStore = hooks[storeKey];
            if (!hooksStore[hookName]) {
              hooksStore[hookName] = {
                handlers: [],
                runs: 0
              };
            }
            hooksStore[hookName].runs++;
            const handlers = hooksStore[hookName].handlers;
            if (!handlers || !handlers.length) {
              return returnFirstArg ? args[0] : void 0;
            }
            const hookInfo = {
              name: hookName,
              currentIndex: 0
            };
            async function asyncRunner() {
              try {
                hooksStore.__current.add(hookInfo);
                let result = returnFirstArg ? args[0] : void 0;
                while (hookInfo.currentIndex < handlers.length) {
                  const handler = handlers[hookInfo.currentIndex];
                  result = await handler.callback.apply(null, args);
                  if (returnFirstArg) {
                    args[0] = result;
                  }
                  hookInfo.currentIndex++;
                }
                return returnFirstArg ? result : void 0;
              } finally {
                hooksStore.__current.delete(hookInfo);
              }
            }
            function syncRunner() {
              try {
                hooksStore.__current.add(hookInfo);
                let result = returnFirstArg ? args[0] : void 0;
                while (hookInfo.currentIndex < handlers.length) {
                  const handler = handlers[hookInfo.currentIndex];
                  result = handler.callback.apply(null, args);
                  if (returnFirstArg) {
                    args[0] = result;
                  }
                  hookInfo.currentIndex++;
                }
                return returnFirstArg ? result : void 0;
              } finally {
                hooksStore.__current.delete(hookInfo);
              }
            }
            return (async ? asyncRunner : syncRunner)();
          };
        }

        /**
         * Returns a function which, when invoked, will return the name of the
         * currently running hook, or `null` if no hook of the given type is currently
         * running.
         *
         * @param {import('.').Hooks}    hooks    Hooks instance.
         * @param {import('.').StoreKey} storeKey
         *
         * @return {() => string | null} Function that returns the current hook name or null.
         */
        function createCurrentHook(hooks, storeKey) {
          return function currentHook() {
            var _currentArray$at$name;
            const hooksStore = hooks[storeKey];
            const currentArray = Array.from(hooksStore.__current);
            return (_currentArray$at$name = currentArray.at(-1)?.name) !== null && _currentArray$at$name !== void 0 ? _currentArray$at$name : null;
          };
        }

        /**
         * @callback DoingHook
         * Returns whether a hook is currently being executed.
         *
         * @param {string} [hookName] The name of the hook to check for.  If
         *                            omitted, will check for any hook being executed.
         *
         * @return {boolean} Whether the hook is being executed.
         */

        /**
         * Returns a function which, when invoked, will return whether a hook is
         * currently being executed.
         *
         * @param {import('.').Hooks}    hooks    Hooks instance.
         * @param {import('.').StoreKey} storeKey
         *
         * @return {DoingHook} Function that returns whether a hook is currently
         *                     being executed.
         */
        function createDoingHook(hooks, storeKey) {
          return function doingHook(hookName) {
            const hooksStore = hooks[storeKey];

            // If the hookName was not passed, check for any current hook.
            if ('undefined' === typeof hookName) {
              return hooksStore.__current.size > 0;
            }

            // Find if the `hookName` hook is in `__current`.
            return Array.from(hooksStore.__current).some(hook => hook.name === hookName);
          };
        }

        /**
         * Internal dependencies
         */

        /**
         * @callback DidHook
         *
         * Returns the number of times an action has been fired.
         *
         * @param {string} hookName The hook name to check.
         *
         * @return {number | undefined} The number of times the hook has run.
         */

        /**
         * Returns a function which, when invoked, will return the number of times a
         * hook has been called.
         *
         * @param {import('.').Hooks}    hooks    Hooks instance.
         * @param {import('.').StoreKey} storeKey
         *
         * @return {DidHook} Function that returns a hook's call count.
         */
        function createDidHook(hooks, storeKey) {
          return function didHook(hookName) {
            const hooksStore = hooks[storeKey];
            if (!validateHookName(hookName)) {
              return;
            }
            return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;
          };
        }

        /**
         * Internal dependencies
         */

        /**
         * Internal class for constructing hooks. Use `createHooks()` function
         *
         * Note, it is necessary to expose this class to make its type public.
         *
         * @private
         */
        class _Hooks {
          constructor() {
            /** @type {import('.').Store} actions */
            this.actions = Object.create(null);
            this.actions.__current = new Set();

            /** @type {import('.').Store} filters */
            this.filters = Object.create(null);
            this.filters.__current = new Set();
            this.addAction = createAddHook(this, 'actions');
            this.addFilter = createAddHook(this, 'filters');
            this.removeAction = createRemoveHook(this, 'actions');
            this.removeFilter = createRemoveHook(this, 'filters');
            this.hasAction = createHasHook(this, 'actions');
            this.hasFilter = createHasHook(this, 'filters');
            this.removeAllActions = createRemoveHook(this, 'actions', true);
            this.removeAllFilters = createRemoveHook(this, 'filters', true);
            this.doAction = createRunHook(this, 'actions', false, false);
            this.doActionAsync = createRunHook(this, 'actions', false, true);
            this.applyFilters = createRunHook(this, 'filters', true, false);
            this.applyFiltersAsync = createRunHook(this, 'filters', true, true);
            this.currentAction = createCurrentHook(this, 'actions');
            this.currentFilter = createCurrentHook(this, 'filters');
            this.doingAction = createDoingHook(this, 'actions');
            this.doingFilter = createDoingHook(this, 'filters');
            this.didAction = createDidHook(this, 'actions');
            this.didFilter = createDidHook(this, 'filters');
          }
        }

        /** @typedef {_Hooks} Hooks */

        /**
         * Returns an instance of the hooks object.
         *
         * @return {Hooks} A Hooks instance.
         */
        function createHooks() {
          return new _Hooks();
        }

        /**
         * Internal dependencies
         */

        /** @typedef {(...args: any[])=>any} Callback */

        /**
         * @typedef Handler
         * @property {Callback} callback  The callback
         * @property {string}   namespace The namespace
         * @property {number}   priority  The namespace
         */

        /**
         * @typedef Hook
         * @property {Handler[]} handlers Array of handlers
         * @property {number}    runs     Run counter
         */

        /**
         * @typedef Current
         * @property {string} name         Hook name
         * @property {number} currentIndex The index
         */

        /**
         * @typedef {Record<string, Hook> & {__current: Set<Current>}} Store
         */

        /**
         * @typedef {'actions' | 'filters'} StoreKey
         */

        /**
         * @typedef {import('./createHooks').Hooks} Hooks
         */

        const defaultHooks = createHooks();
        const {
          addAction,
          addFilter,
          removeAction,
          removeFilter,
          hasAction,
          hasFilter,
          removeAllActions,
          removeAllFilters,
          doAction,
          doActionAsync,
          applyFilters,
          applyFiltersAsync,
          currentAction,
          currentFilter,
          doingAction,
          doingFilter,
          didAction,
          didFilter,
          actions,
          filters
        } = defaultHooks;

        /**
         * Internal dependencies
         */
        const i18n = createI18n(undefined, undefined, defaultHooks);

        /*
         * Comments in this file are duplicated from ./i18n due to
         * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722
         */

        /**
         * @typedef {import('./create-i18n').LocaleData} LocaleData
         * @typedef {import('./create-i18n').SubscribeCallback} SubscribeCallback
         * @typedef {import('./create-i18n').UnsubscribeCallback} UnsubscribeCallback
         */

        /**
         * Returns locale data by domain in a Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         *
         * @param {string} [domain] Domain for which to get the data.
         * @return {LocaleData} Locale data.
         */
        i18n.getLocaleData.bind(i18n);

        /**
         * Merges locale data into the Tannin instance by domain. Accepts data in a
         * Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         *
         * @param {LocaleData} [data]   Locale data configuration.
         * @param {string}     [domain] Domain for which configuration applies.
         */
        i18n.setLocaleData.bind(i18n);

        /**
         * Resets all current Tannin instance locale data and sets the specified
         * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
         *
         * @see http://messageformat.github.io/Jed/
         *
         * @param {LocaleData} [data]   Locale data configuration.
         * @param {string}     [domain] Domain for which configuration applies.
         */
        i18n.resetLocaleData.bind(i18n);

        /**
         * Subscribes to changes of locale data
         *
         * @param {SubscribeCallback} callback Subscription callback
         * @return {UnsubscribeCallback} Unsubscribe callback
         */
        i18n.subscribe.bind(i18n);

        /**
         * Retrieve the translation of text.
         *
         * @see https://developer.wordpress.org/reference/functions/__/
         *
         * @param {string} text     Text to translate.
         * @param {string} [domain] Domain to retrieve the translated text.
         *
         * @return {string} Translated text.
         */
        const __ = i18n.__.bind(i18n);

        /**
         * Retrieve translated string with gettext context.
         *
         * @see https://developer.wordpress.org/reference/functions/_x/
         *
         * @param {string} text     Text to translate.
         * @param {string} context  Context information for the translators.
         * @param {string} [domain] Domain to retrieve the translated text.
         *
         * @return {string} Translated context string without pipe.
         */
        i18n._x.bind(i18n);

        /**
         * Translates and retrieves the singular or plural form based on the supplied
         * number.
         *
         * @see https://developer.wordpress.org/reference/functions/_n/
         *
         * @param {string} single   The text to be used if the number is singular.
         * @param {string} plural   The text to be used if the number is plural.
         * @param {number} number   The number to compare against to use either the
         *                          singular or plural form.
         * @param {string} [domain] Domain to retrieve the translated text.
         *
         * @return {string} The translated singular or plural form.
         */
        i18n._n.bind(i18n);

        /**
         * Translates and retrieves the singular or plural form based on the supplied
         * number, with gettext context.
         *
         * @see https://developer.wordpress.org/reference/functions/_nx/
         *
         * @param {string} single   The text to be used if the number is singular.
         * @param {string} plural   The text to be used if the number is plural.
         * @param {number} number   The number to compare against to use either the
         *                          singular or plural form.
         * @param {string} context  Context information for the translators.
         * @param {string} [domain] Domain to retrieve the translated text.
         *
         * @return {string} The translated singular or plural form.
         */
        i18n._nx.bind(i18n);

        /**
         * Check if current locale is RTL.
         *
         * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
         * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
         * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
         * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
         *
         * @return {boolean} Whether locale is RTL.
         */
        const isRTL$1 = i18n.isRTL.bind(i18n);

        /**
         * Check if there is a translation for a given string (in singular form).
         *
         * @param {string} single    Singular form of the string to look up.
         * @param {string} [context] Context information for the translators.
         * @param {string} [domain]  Domain to retrieve the translated text.
         * @return {boolean} Whether the translation exists or not.
         */
        i18n.hasTranslation.bind(i18n);

        /**
         * Parts of this source were derived and modified from lodash,
         * released under the MIT license.
         *
         * https://github.com/lodash/lodash
         *
         * Copyright JS Foundation and other contributors <https://js.foundation/>
         *
         * Based on Underscore.js, copyright Jeremy Ashkenas,
         * DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>
         *
         * This software consists of voluntary contributions made by many
         * individuals. For exact contribution history, see the revision history
         * available at https://github.com/lodash/lodash
         *
         * The following license applies to all parts of this software except as
         * documented below:
         *
         * ====
         *
         * Permission is hereby granted, free of charge, to any person obtaining
         * a copy of this software and associated documentation files (the
         * "Software"), to deal in the Software without restriction, including
         * without limitation the rights to use, copy, modify, merge, publish,
         * distribute, sublicense, and/or sell copies of the Software, and to
         * permit persons to whom the Software is furnished to do so, subject to
         * the following conditions:
         *
         * The above copyright notice and this permission notice shall be
         * included in all copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
         * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
         * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
         * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
         * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
         * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
         * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
         */

        /**
         * A simplified and properly typed version of lodash's `debounce`, that
         * always uses timers instead of sometimes using rAF.
         *
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel delayed
         * `func` invocations and a `flush` method to immediately invoke them. Provide
         * `options` to indicate whether `func` should be invoked on the leading and/or
         * trailing edge of the `wait` timeout. The `func` is invoked with the last
         * arguments provided to the debounced function. Subsequent calls to the debounced
         * function return the result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * @param {Function}                   func             The function to debounce.
         * @param {number}                     wait             The number of milliseconds to delay.
         * @param {Partial< DebounceOptions >} options          The options object.
         * @param {boolean}                    options.leading  Specify invoking on the leading edge of the timeout.
         * @param {number}                     options.maxWait  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean}                    options.trailing Specify invoking on the trailing edge of the timeout.
         *
         * @return Returns the new debounced function.
         */
        const debounce = (func, wait, options) => {
          let lastArgs;
          let lastThis;
          let result;
          let timerId;
          let lastCallTime;
          let maxing = false;
          function invokeFunc(time) {
            const args = lastArgs;
            const thisArg = lastThis;
            lastArgs = undefined;
            lastThis = undefined;
            result = func.apply(thisArg, args);
            return result;
          }
          function startTimer(pendingFunc, waitTime) {
            timerId = setTimeout(pendingFunc, waitTime);
          }
          function cancelTimer() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
          }
          function leadingEdge(time) {
            // Start the timer for the trailing edge.
            startTimer(timerExpired, wait);
            // Invoke the leading edge.
            return result;
          }
          function getTimeSinceLastCall(time) {
            return time - (lastCallTime || 0);
          }
          function remainingWait(time) {
            const timeSinceLastCall = getTimeSinceLastCall(time);
            const timeWaiting = wait - timeSinceLastCall;
            return timeWaiting;
          }
          function shouldInvoke(time) {
            const timeSinceLastCall = getTimeSinceLastCall(time);

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing;
          }
          function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
              return trailingEdge();
            }
            // Restart the timer.
            startTimer(timerExpired, remainingWait(time));
            return undefined;
          }
          function clearTimer() {
            timerId = undefined;
          }
          function trailingEdge(time) {
            clearTimer();

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (lastArgs) {
              return invokeFunc();
            }
            lastArgs = lastThis = undefined;
            return result;
          }
          function cancel() {
            cancelTimer();
            clearTimer();
            lastArgs = lastCallTime = lastThis = undefined;
          }
          function flush() {
            return pending() ? trailingEdge() : result;
          }
          function pending() {
            return timerId !== undefined;
          }
          function debounced(...args) {
            const time = Date.now();
            const isInvoking = shouldInvoke(time);
            lastArgs = args;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (!pending()) {
                return leadingEdge();
              }
            }
            if (!pending()) {
              startTimer(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          debounced.pending = pending;
          return debounced;
        };

        /**
         * WordPress dependencies
         */

        /**
         * Object map tracking messages which have been logged, for use in ensuring a
         * message is only logged once.
         */
        const logged$1 = Object.create(null);
        /**
         * Logs a message to notify developers about a deprecated feature.
         *
         * @param {string}            feature   Name of the deprecated feature.
         * @param {DeprecatedOptions} [options] Personalisation options
         *
         * @example
         * ```js
         * import deprecated from '@wordpress/deprecated';
         *
         * deprecated( 'Eating meat', {
         * 	since: '2019.01.01'
         * 	version: '2020.01.01',
         * 	alternative: 'vegetables',
         * 	plugin: 'the earth',
         * 	hint: 'You may find it beneficial to transition gradually.',
         * } );
         *
         * // Logs: 'Eating meat is deprecated since version 2019.01.01 and will be removed from the earth in version 2020.01.01. Please use vegetables instead. Note: You may find it beneficial to transition gradually.'
         * ```
         */
        function deprecated(feature, options = {}) {
          const {
            since,
            version,
            alternative,
            plugin,
            link,
            hint
          } = options;
          const pluginMessage = plugin ? ` from ${plugin}` : '';
          const sinceMessage = since ? ` since version ${since}` : '';
          const versionMessage = version ? ` and will be removed${pluginMessage} in version ${version}` : '';
          const useInsteadMessage = alternative ? ` Please use ${alternative} instead.` : '';
          const linkMessage = link ? ` See: ${link}` : '';
          const hintMessage = hint ? ` Note: ${hint}` : '';
          const message = `${feature} is deprecated${sinceMessage}${versionMessage}.${useInsteadMessage}${linkMessage}${hintMessage}`;

          // Skip if already logged.
          if (message in logged$1) {
            return;
          }

          /**
           * Fires whenever a deprecated feature is encountered
           *
           * @param {string}            feature Name of the deprecated feature.
           * @param {DeprecatedOptions} options Personalisation options
           * @param {string}            message Message sent to console.warn
           */
          doAction('deprecated', feature, options, message);

          // eslint-disable-next-line no-console
          console.warn(message);
          logged$1[message] = true;
        }

        /**
         * WordPress dependencies
         */
        const instanceMap = new WeakMap();

        /**
         * Creates a new id for a given object.
         *
         * @param object Object reference to create an id for.
         * @return The instance id (index).
         */
        function createId(object) {
          const instances = instanceMap.get(object) || 0;
          instanceMap.set(object, instances + 1);
          return instances;
        }

        /**
         * Specify the useInstanceId *function* signatures.
         *
         * More accurately, useInstanceId distinguishes between three different
         * signatures:
         *
         * 1. When only object is given, the returned value is a number
         * 2. When object and prefix is given, the returned value is a string
         * 3. When preferredId is given, the returned value is the type of preferredId
         *
         * @param object Object reference to create an id for.
         */

        /**
         * Provides a unique instance ID.
         *
         * @param object        Object reference to create an id for.
         * @param [prefix]      Prefix for the unique id.
         * @param [preferredId] Default ID to use.
         * @return The unique instance id.
         */
        function useInstanceId(object, prefix, preferredId) {
          return reactExports.useMemo(() => {
            if (preferredId) {
              return preferredId;
            }
            const id = createId(object);
            return prefix ? `${prefix}-${id}` : id;
          }, [object, preferredId, prefix]);
        }

        /**
         * References:
         *
         * Focusable:
         *  - https://www.w3.org/TR/html5/editing.html#focus-management
         *
         * Sequential focus navigation:
         *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
         *
         * Disabled elements:
         *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements
         *
         * getClientRects algorithm (requiring layout box):
         *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface
         *
         * AREA elements associated with an IMG:
         *  - https://w3c.github.io/html/editing.html#data-model
         */

        /**
         * Returns a CSS selector used to query for focusable elements.
         *
         * @param {boolean} sequential If set, only query elements that are sequentially
         *                             focusable. Non-interactive elements with a
         *                             negative `tabindex` are focusable but not
         *                             sequentially focusable.
         *                             https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute
         *
         * @return {string} CSS selector.
         */
        function buildSelector(sequential) {
          return [sequential ? '[tabindex]:not([tabindex^="-"])' : '[tabindex]', 'a[href]', 'button:not([disabled])', 'input:not([type="hidden"]):not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'iframe:not([tabindex^="-"])', 'object', 'embed', 'summary', 'area[href]', '[contenteditable]:not([contenteditable=false])'].join(',');
        }

        /**
         * Returns true if the specified element is visible (i.e. neither display: none
         * nor visibility: hidden).
         *
         * @param {HTMLElement} element DOM element to test.
         *
         * @return {boolean} Whether element is visible.
         */
        function isVisible$1(element) {
          return element.offsetWidth > 0 || element.offsetHeight > 0 || element.getClientRects().length > 0;
        }

        /**
         * Returns true if the specified area element is a valid focusable element, or
         * false otherwise. Area is only focusable if within a map where a named map
         * referenced by an image somewhere in the document.
         *
         * @param {HTMLAreaElement} element DOM area element to test.
         *
         * @return {boolean} Whether area element is valid for focus.
         */
        function isValidFocusableArea(element) {
          /** @type {HTMLMapElement | null} */
          const map = element.closest('map[name]');
          if (!map) {
            return false;
          }

          /** @type {HTMLImageElement | null} */
          const img = element.ownerDocument.querySelector('img[usemap="#' + map.name + '"]');
          return !!img && isVisible$1(img);
        }

        /**
         * Returns all focusable elements within a given context.
         *
         * @param {Element} context              Element in which to search.
         * @param {Object}  options
         * @param {boolean} [options.sequential] If set, only return elements that are
         *                                       sequentially focusable.
         *                                       Non-interactive elements with a
         *                                       negative `tabindex` are focusable but
         *                                       not sequentially focusable.
         *                                       https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute
         *
         * @return {HTMLElement[]} Focusable elements.
         */
        function find$1(context, {
          sequential = false
        } = {}) {
          /** @type {NodeListOf<HTMLElement>} */
          const elements = context.querySelectorAll(buildSelector(sequential));
          return Array.from(elements).filter(element => {
            if (!isVisible$1(element)) {
              return false;
            }
            const {
              nodeName
            } = element;
            if ('AREA' === nodeName) {
              return isValidFocusableArea(/** @type {HTMLAreaElement} */element);
            }
            return true;
          });
        }

        /**
         * Internal dependencies
         */

        /**
         * Returns the tab index of the given element. In contrast with the tabIndex
         * property, this normalizes the default (0) to avoid browser inconsistencies,
         * operating under the assumption that this function is only ever called with a
         * focusable node.
         *
         * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261
         *
         * @param {Element} element Element from which to retrieve.
         *
         * @return {number} Tab index of element (default 0).
         */
        function getTabIndex$1(element) {
          const tabIndex = element.getAttribute('tabindex');
          return tabIndex === null ? 0 : parseInt(tabIndex, 10);
        }

        /**
         * Returns true if the specified element is tabbable, or false otherwise.
         *
         * @param {Element} element Element to test.
         *
         * @return {boolean} Whether element is tabbable.
         */
        function isTabbableIndex(element) {
          return getTabIndex$1(element) !== -1;
        }

        /** @typedef {HTMLElement & { type?: string, checked?: boolean, name?: string }} MaybeHTMLInputElement */

        /**
         * Returns a stateful reducer function which constructs a filtered array of
         * tabbable elements, where at most one radio input is selected for a given
         * name, giving priority to checked input, falling back to the first
         * encountered.
         *
         * @return {(acc: MaybeHTMLInputElement[], el: MaybeHTMLInputElement) => MaybeHTMLInputElement[]} Radio group collapse reducer.
         */
        function createStatefulCollapseRadioGroup() {
          /** @type {Record<string, MaybeHTMLInputElement>} */
          const CHOSEN_RADIO_BY_NAME = {};
          return function collapseRadioGroup(/** @type {MaybeHTMLInputElement[]} */result, /** @type {MaybeHTMLInputElement} */element) {
            const {
              nodeName,
              type,
              checked,
              name
            } = element;

            // For all non-radio tabbables, construct to array by concatenating.
            if (nodeName !== 'INPUT' || type !== 'radio' || !name) {
              return result.concat(element);
            }
            const hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty(name);

            // Omit by skipping concatenation if the radio element is not chosen.
            const isChosen = checked || !hasChosen;
            if (!isChosen) {
              return result;
            }

            // At this point, if there had been a chosen element, the current
            // element is checked and should take priority. Retroactively remove
            // the element which had previously been considered the chosen one.
            if (hasChosen) {
              const hadChosenElement = CHOSEN_RADIO_BY_NAME[name];
              result = result.filter(e => e !== hadChosenElement);
            }
            CHOSEN_RADIO_BY_NAME[name] = element;
            return result.concat(element);
          };
        }

        /**
         * An array map callback, returning an object with the element value and its
         * array index location as properties. This is used to emulate a proper stable
         * sort where equal tabIndex should be left in order of their occurrence in the
         * document.
         *
         * @param {HTMLElement} element Element.
         * @param {number}      index   Array index of element.
         *
         * @return {{ element: HTMLElement, index: number }} Mapped object with element, index.
         */
        function mapElementToObjectTabbable(element, index) {
          return {
            element,
            index
          };
        }

        /**
         * An array map callback, returning an element of the given mapped object's
         * element value.
         *
         * @param {{ element: HTMLElement }} object Mapped object with element.
         *
         * @return {HTMLElement} Mapped object element.
         */
        function mapObjectTabbableToElement(object) {
          return object.element;
        }

        /**
         * A sort comparator function used in comparing two objects of mapped elements.
         *
         * @see mapElementToObjectTabbable
         *
         * @param {{ element: HTMLElement, index: number }} a First object to compare.
         * @param {{ element: HTMLElement, index: number }} b Second object to compare.
         *
         * @return {number} Comparator result.
         */
        function compareObjectTabbables(a, b) {
          const aTabIndex = getTabIndex$1(a.element);
          const bTabIndex = getTabIndex$1(b.element);
          if (aTabIndex === bTabIndex) {
            return a.index - b.index;
          }
          return aTabIndex - bTabIndex;
        }

        /**
         * Givin focusable elements, filters out tabbable element.
         *
         * @param {HTMLElement[]} focusables Focusable elements to filter.
         *
         * @return {HTMLElement[]} Tabbable elements.
         */
        function filterTabbable(focusables) {
          return focusables.filter(isTabbableIndex).map(mapElementToObjectTabbable).sort(compareObjectTabbables).map(mapObjectTabbableToElement).reduce(createStatefulCollapseRadioGroup(), []);
        }

        /**
         * @param {Element} context
         * @return {HTMLElement[]} Tabbable elements within the context.
         */
        function find(context) {
          return filterTabbable(find$1(context));
        }

        /**
         * Given a focusable element, find the preceding tabbable element.
         *
         * @param {Element} element The focusable element before which to look. Defaults
         *                          to the active element.
         *
         * @return {HTMLElement|undefined} Preceding tabbable element.
         */
        function findPrevious(element) {
          return filterTabbable(find$1(element.ownerDocument.body)).reverse().find(focusable =>
          // eslint-disable-next-line no-bitwise
          element.compareDocumentPosition(focusable) & element.DOCUMENT_POSITION_PRECEDING);
        }

        /**
         * Given a focusable element, find the next tabbable element.
         *
         * @param {Element} element The focusable element after which to look. Defaults
         *                          to the active element.
         *
         * @return {HTMLElement|undefined} Next tabbable element.
         */
        function findNext(element) {
          return filterTabbable(find$1(element.ownerDocument.body)).find(focusable =>
          // eslint-disable-next-line no-bitwise
          element.compareDocumentPosition(focusable) & element.DOCUMENT_POSITION_FOLLOWING);
        }
        const tabbable = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          find,
          findNext,
          findPrevious,
          isTabbableIndex
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        function assertIsDefined(val, name) {}

        /**
         * Internal dependencies
         */

        /* eslint-disable jsdoc/valid-types */
        /**
         * @param {Element} element
         * @return {ReturnType<Window['getComputedStyle']>} The computed style for the element.
         */
        function getComputedStyle$2(element) {
          /* eslint-enable jsdoc/valid-types */
          assertIsDefined(element.ownerDocument.defaultView);
          return element.ownerDocument.defaultView.getComputedStyle(element);
        }

        /**
         * Internal dependencies
         */

        /**
         * Given a DOM node, finds the closest scrollable container node or the node
         * itself, if scrollable.
         *
         * @param {Element | null} node      Node from which to start.
         * @param {?string}        direction Direction of scrollable container to search for ('vertical', 'horizontal', 'all').
         *                                   Defaults to 'vertical'.
         * @return {Element | undefined} Scrollable container node, if found.
         */
        function getScrollContainer(node, direction = 'vertical') {
          if (!node) {
            return undefined;
          }
          if (direction === 'vertical' || direction === 'all') {
            // Scrollable if scrollable height exceeds displayed...
            if (node.scrollHeight > node.clientHeight) {
              // ...except when overflow is defined to be hidden or visible
              const {
                overflowY
              } = getComputedStyle$2(node);
              if (/(auto|scroll)/.test(overflowY)) {
                return node;
              }
            }
          }
          if (direction === 'horizontal' || direction === 'all') {
            // Scrollable if scrollable width exceeds displayed...
            if (node.scrollWidth > node.clientWidth) {
              // ...except when overflow is defined to be hidden or visible
              const {
                overflowX
              } = getComputedStyle$2(node);
              if (/(auto|scroll)/.test(overflowX)) {
                return node;
              }
            }
          }
          if (node.ownerDocument === node.parentNode) {
            return node;
          }

          // Continue traversing.
          return getScrollContainer(/** @type {Element} */node.parentNode, direction);
        }

        /**
         * Internal dependencies
         */

        /**
         * Object grouping `focusable` and `tabbable` utils
         * under the keys with the same name.
         */
        const focus = {
          tabbable
        };

        /**
         * External dependencies
         */

        /**
         * Effect-like ref callback. Just like with `useEffect`, this allows you to
         * return a cleanup function to be run if the ref changes or one of the
         * dependencies changes. The ref is provided as an argument to the callback
         * functions. The main difference between this and `useEffect` is that
         * the `useEffect` callback is not called when the ref changes, but this is.
         * Pass the returned ref callback as the component's ref and merge multiple refs
         * with `useMergeRefs`.
         *
         * It's worth noting that if the dependencies array is empty, there's not
         * strictly a need to clean up event handlers for example, because the node is
         * to be removed. It *is* necessary if you add dependencies because the ref
         * callback will be called multiple times for the same node.
         *
         * @param callback     Callback with ref as argument.
         * @param dependencies Dependencies of the callback.
         *
         * @return Ref callback.
         */
        function useRefEffect(callback, dependencies) {
          const cleanupRef = reactExports.useRef();
          return reactExports.useCallback(node => {
            if (node) {
              cleanupRef.current = callback(node);
            } else if (cleanupRef.current) {
              cleanupRef.current();
            }
          }, dependencies);
        }

        /**
         * WordPress dependencies
         */

        /**
         * In Dialogs/modals, the tabbing must be constrained to the content of
         * the wrapper element. This hook adds the behavior to the returned ref.
         *
         * @return {import('react').RefCallback<Element>} Element Ref.
         *
         * @example
         * ```js
         * import { useConstrainedTabbing } from '@wordpress/compose';
         *
         * const ConstrainedTabbingExample = () => {
         *     const constrainedTabbingRef = useConstrainedTabbing()
         *     return (
         *         <div ref={ constrainedTabbingRef }>
         *             <Button />
         *             <Button />
         *         </div>
         *     );
         * }
         * ```
         */
        function useConstrainedTabbing() {
          return useRefEffect((/** @type {HTMLElement} */node) => {
            function onKeyDown(/** @type {KeyboardEvent} */event) {
              const {
                key,
                shiftKey,
                target
              } = event;
              if (key !== 'Tab') {
                return;
              }
              const action = shiftKey ? 'findPrevious' : 'findNext';
              const nextElement = focus.tabbable[action](/** @type {HTMLElement} */target) || null;

              // When the target element contains the element that is about to
              // receive focus, for example when the target is a tabbable
              // container, browsers may disagree on where to move focus next.
              // In this case we can't rely on native browsers behavior. We need
              // to manage focus instead.
              // See https://github.com/WordPress/gutenberg/issues/46041.
              if (/** @type {HTMLElement} */target.contains(nextElement)) {
                event.preventDefault();
                nextElement?.focus();
                return;
              }

              // If the element that is about to receive focus is inside the
              // area, rely on native browsers behavior and let tabbing follow
              // the native tab sequence.
              if (node.contains(nextElement)) {
                return;
              }

              // If the element that is about to receive focus is outside the
              // area, move focus to a div and insert it at the start or end of
              // the area, depending on the direction. Without preventing default
              // behaviour, the browser will then move focus to the next element.
              const domAction = shiftKey ? 'append' : 'prepend';
              const {
                ownerDocument
              } = node;
              const trap = ownerDocument.createElement('div');
              trap.tabIndex = -1;
              node[domAction](trap);

              // Remove itself when the trap loses focus.
              trap.addEventListener('blur', () => node.removeChild(trap));
              trap.focus();
            }
            node.addEventListener('keydown', onKeyDown);
            return () => {
              node.removeEventListener('keydown', onKeyDown);
            };
          }, []);
        }
        var clipboard = {
          exports: {}
        };

        /*!
         * clipboard.js v2.0.11
         * https://clipboardjs.com/
         *
         * Licensed MIT © Zeno Rocha
         */

        (function (module, exports) {
          (function webpackUniversalModuleDefinition(root, factory) {
            module.exports = factory();
          })(commonjsGlobal, function () {
            return /******/function () {
              // webpackBootstrap
              /******/
              var __webpack_modules__ = {
                /***/686: (/***/function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                  // EXPORTS
                  __webpack_require__.d(__webpack_exports__, {
                    "default": function () {
                      return /* binding */clipboard;
                    }
                  });

                  // EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
                  var tiny_emitter = __webpack_require__(279);
                  var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);
                  // EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
                  var listen = __webpack_require__(370);
                  var listen_default = /*#__PURE__*/__webpack_require__.n(listen);
                  // EXTERNAL MODULE: ./node_modules/select/src/select.js
                  var src_select = __webpack_require__(817);
                  var select_default = /*#__PURE__*/__webpack_require__.n(src_select);
                  /**
                   * Executes a given operation type.
                   * @param {String} type
                   * @return {Boolean}
                   */
                  function command(type) {
                    try {
                      return document.execCommand(type);
                    } catch (err) {
                      return false;
                    }
                  }

                  /**
                   * Cut action wrapper.
                   * @param {String|HTMLElement} target
                   * @return {String}
                   */

                  var ClipboardActionCut = function ClipboardActionCut(target) {
                    var selectedText = select_default()(target);
                    command('cut');
                    return selectedText;
                  };

                  /* harmony default export */
                  var actions_cut = ClipboardActionCut;
                  /**
                   * Creates a fake textarea element with a value.
                   * @param {String} value
                   * @return {HTMLElement}
                   */
                  function createFakeElement(value) {
                    var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
                    var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

                    fakeElement.style.fontSize = '12pt'; // Reset box model

                    fakeElement.style.border = '0';
                    fakeElement.style.padding = '0';
                    fakeElement.style.margin = '0'; // Move element out of screen horizontally

                    fakeElement.style.position = 'absolute';
                    fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                    fakeElement.style.top = "".concat(yPosition, "px");
                    fakeElement.setAttribute('readonly', '');
                    fakeElement.value = value;
                    return fakeElement;
                  }

                  /**
                   * Create fake copy action wrapper using a fake element.
                   * @param {String} target
                   * @param {Object} options
                   * @return {String}
                   */

                  var fakeCopyAction = function fakeCopyAction(value, options) {
                    var fakeElement = createFakeElement(value);
                    options.container.appendChild(fakeElement);
                    var selectedText = select_default()(fakeElement);
                    command('copy');
                    fakeElement.remove();
                    return selectedText;
                  };
                  /**
                   * Copy action wrapper.
                   * @param {String|HTMLElement} target
                   * @param {Object} options
                   * @return {String}
                   */

                  var ClipboardActionCopy = function ClipboardActionCopy(target) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                      container: document.body
                    };
                    var selectedText = '';
                    if (typeof target === 'string') {
                      selectedText = fakeCopyAction(target, options);
                    } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
                      // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
                      selectedText = fakeCopyAction(target.value, options);
                    } else {
                      selectedText = select_default()(target);
                      command('copy');
                    }
                    return selectedText;
                  };

                  /* harmony default export */
                  var actions_copy = ClipboardActionCopy;
                  function _typeof(obj) {
                    "@babel/helpers - typeof";

                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                      _typeof = function _typeof(obj) {
                        return typeof obj;
                      };
                    } else {
                      _typeof = function _typeof(obj) {
                        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                      };
                    }
                    return _typeof(obj);
                  }

                  /**
                   * Inner function which performs selection from either `text` or `target`
                   * properties and then executes copy or cut operations.
                   * @param {Object} options
                   */

                  var ClipboardActionDefault = function ClipboardActionDefault() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    // Defines base properties passed from constructor.
                    var _options$action = options.action,
                      action = _options$action === void 0 ? 'copy' : _options$action,
                      container = options.container,
                      target = options.target,
                      text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

                    if (action !== 'copy' && action !== 'cut') {
                      throw new Error('Invalid "action" value, use either "copy" or "cut"');
                    } // Sets the `target` property using an element that will be have its content copied.

                    if (target !== undefined) {
                      if (target && _typeof(target) === 'object' && target.nodeType === 1) {
                        if (action === 'copy' && target.hasAttribute('disabled')) {
                          throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                        }
                        if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                          throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                        }
                      } else {
                        throw new Error('Invalid "target" value, use a valid Element');
                      }
                    } // Define selection strategy based on `text` property.

                    if (text) {
                      return actions_copy(text, {
                        container: container
                      });
                    } // Defines which selection strategy based on `target` property.

                    if (target) {
                      return action === 'cut' ? actions_cut(target) : actions_copy(target, {
                        container: container
                      });
                    }
                  };

                  /* harmony default export */
                  var actions_default = ClipboardActionDefault;
                  function clipboard_typeof(obj) {
                    "@babel/helpers - typeof";

                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                      clipboard_typeof = function _typeof(obj) {
                        return typeof obj;
                      };
                    } else {
                      clipboard_typeof = function _typeof(obj) {
                        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                      };
                    }
                    return clipboard_typeof(obj);
                  }
                  function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                      throw new TypeError("Cannot call a class as a function");
                    }
                  }
                  function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                      var descriptor = props[i];
                      descriptor.enumerable = descriptor.enumerable || false;
                      descriptor.configurable = true;
                      if ("value" in descriptor) descriptor.writable = true;
                      Object.defineProperty(target, descriptor.key, descriptor);
                    }
                  }
                  function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                  }
                  function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                      throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                      constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                      }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                  }
                  function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                      o.__proto__ = p;
                      return o;
                    };
                    return _setPrototypeOf(o, p);
                  }
                  function _createSuper(Derived) {
                    var hasNativeReflectConstruct = _isNativeReflectConstruct();
                    return function _createSuperInternal() {
                      var Super = _getPrototypeOf(Derived),
                        result;
                      if (hasNativeReflectConstruct) {
                        var NewTarget = _getPrototypeOf(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                      } else {
                        result = Super.apply(this, arguments);
                      }
                      return _possibleConstructorReturn(this, result);
                    };
                  }
                  function _possibleConstructorReturn(self, call) {
                    if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
                      return call;
                    }
                    return _assertThisInitialized(self);
                  }
                  function _assertThisInitialized(self) {
                    if (self === void 0) {
                      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                  }
                  function _isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }
                  function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                      return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                  }

                  /**
                   * Helper function to retrieve attribute value.
                   * @param {String} suffix
                   * @param {Element} element
                   */

                  function getAttributeValue(suffix, element) {
                    var attribute = "data-clipboard-".concat(suffix);
                    if (!element.hasAttribute(attribute)) {
                      return;
                    }
                    return element.getAttribute(attribute);
                  }
                  /**
                   * Base class which takes one or more elements, adds event listeners to them,
                   * and instantiates a new `ClipboardAction` on each click.
                   */

                  var Clipboard = /*#__PURE__*/function (_Emitter) {
                    _inherits(Clipboard, _Emitter);
                    var _super = _createSuper(Clipboard);

                    /**
                     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                     * @param {Object} options
                     */
                    function Clipboard(trigger, options) {
                      var _this;
                      _classCallCheck(this, Clipboard);
                      _this = _super.call(this);
                      _this.resolveOptions(options);
                      _this.listenClick(trigger);
                      return _this;
                    }
                    /**
                     * Defines if attributes would be resolved using internal setter functions
                     * or custom functions that were passed in the constructor.
                     * @param {Object} options
                     */

                    _createClass(Clipboard, [{
                      key: "resolveOptions",
                      value: function resolveOptions() {
                        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                        this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
                        this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
                        this.text = typeof options.text === 'function' ? options.text : this.defaultText;
                        this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
                      }
                      /**
                       * Adds a click event listener to the passed trigger.
                       * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                       */
                    }, {
                      key: "listenClick",
                      value: function listenClick(trigger) {
                        var _this2 = this;
                        this.listener = listen_default()(trigger, 'click', function (e) {
                          return _this2.onClick(e);
                        });
                      }
                      /**
                       * Defines a new `ClipboardAction` on each click event.
                       * @param {Event} e
                       */
                    }, {
                      key: "onClick",
                      value: function onClick(e) {
                        var trigger = e.delegateTarget || e.currentTarget;
                        var action = this.action(trigger) || 'copy';
                        var text = actions_default({
                          action: action,
                          container: this.container,
                          target: this.target(trigger),
                          text: this.text(trigger)
                        }); // Fires an event based on the copy operation result.

                        this.emit(text ? 'success' : 'error', {
                          action: action,
                          text: text,
                          trigger: trigger,
                          clearSelection: function clearSelection() {
                            if (trigger) {
                              trigger.focus();
                            }
                            window.getSelection().removeAllRanges();
                          }
                        });
                      }
                      /**
                       * Default `action` lookup function.
                       * @param {Element} trigger
                       */
                    }, {
                      key: "defaultAction",
                      value: function defaultAction(trigger) {
                        return getAttributeValue('action', trigger);
                      }
                      /**
                       * Default `target` lookup function.
                       * @param {Element} trigger
                       */
                    }, {
                      key: "defaultTarget",
                      value: function defaultTarget(trigger) {
                        var selector = getAttributeValue('target', trigger);
                        if (selector) {
                          return document.querySelector(selector);
                        }
                      }
                      /**
                       * Allow fire programmatically a copy action
                       * @param {String|HTMLElement} target
                       * @param {Object} options
                       * @returns Text copied.
                       */
                    }, {
                      key: "defaultText",
                      /**
                       * Default `text` lookup function.
                       * @param {Element} trigger
                       */
                      value: function defaultText(trigger) {
                        return getAttributeValue('text', trigger);
                      }
                      /**
                       * Destroy lifecycle.
                       */
                    }, {
                      key: "destroy",
                      value: function destroy() {
                        this.listener.destroy();
                      }
                    }], [{
                      key: "copy",
                      value: function copy(target) {
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                          container: document.body
                        };
                        return actions_copy(target, options);
                      }
                      /**
                       * Allow fire programmatically a cut action
                       * @param {String|HTMLElement} target
                       * @returns Text cutted.
                       */
                    }, {
                      key: "cut",
                      value: function cut(target) {
                        return actions_cut(target);
                      }
                      /**
                       * Returns the support of the given action, or all actions if no action is
                       * given.
                       * @param {String} [action]
                       */
                    }, {
                      key: "isSupported",
                      value: function isSupported() {
                        var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
                        var actions = typeof action === 'string' ? [action] : action;
                        var support = !!document.queryCommandSupported;
                        actions.forEach(function (action) {
                          support = support && !!document.queryCommandSupported(action);
                        });
                        return support;
                      }
                    }]);
                    return Clipboard;
                  }(tiny_emitter_default());

                  /* harmony default export */
                  var clipboard = Clipboard;

                  /***/
                }),
                /***/828: (/***/function (module) {
                  var DOCUMENT_NODE_TYPE = 9;

                  /**
                   * A polyfill for Element.matches()
                   */
                  if (typeof Element !== 'undefined' && !Element.prototype.matches) {
                    var proto = Element.prototype;
                    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
                  }

                  /**
                   * Finds the closest parent that matches a selector.
                   *
                   * @param {Element} element
                   * @param {String} selector
                   * @return {Function}
                   */
                  function closest(element, selector) {
                    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                      if (typeof element.matches === 'function' && element.matches(selector)) {
                        return element;
                      }
                      element = element.parentNode;
                    }
                  }
                  module.exports = closest;

                  /***/
                }),
                /***/438: (/***/function (module, __unused_webpack_exports, __webpack_require__) {
                  var closest = __webpack_require__(828);

                  /**
                   * Delegates event to a selector.
                   *
                   * @param {Element} element
                   * @param {String} selector
                   * @param {String} type
                   * @param {Function} callback
                   * @param {Boolean} useCapture
                   * @return {Object}
                   */
                  function _delegate(element, selector, type, callback, useCapture) {
                    var listenerFn = listener.apply(this, arguments);
                    element.addEventListener(type, listenerFn, useCapture);
                    return {
                      destroy: function () {
                        element.removeEventListener(type, listenerFn, useCapture);
                      }
                    };
                  }

                  /**
                   * Delegates event to a selector.
                   *
                   * @param {Element|String|Array} [elements]
                   * @param {String} selector
                   * @param {String} type
                   * @param {Function} callback
                   * @param {Boolean} useCapture
                   * @return {Object}
                   */
                  function delegate(elements, selector, type, callback, useCapture) {
                    // Handle the regular Element usage
                    if (typeof elements.addEventListener === 'function') {
                      return _delegate.apply(null, arguments);
                    }

                    // Handle Element-less usage, it defaults to global delegation
                    if (typeof type === 'function') {
                      // Use `document` as the first parameter, then apply arguments
                      // This is a short way to .unshift `arguments` without running into deoptimizations
                      return _delegate.bind(null, document).apply(null, arguments);
                    }

                    // Handle Selector-based usage
                    if (typeof elements === 'string') {
                      elements = document.querySelectorAll(elements);
                    }

                    // Handle Array-like based usage
                    return Array.prototype.map.call(elements, function (element) {
                      return _delegate(element, selector, type, callback, useCapture);
                    });
                  }

                  /**
                   * Finds closest match and invokes callback.
                   *
                   * @param {Element} element
                   * @param {String} selector
                   * @param {String} type
                   * @param {Function} callback
                   * @return {Function}
                   */
                  function listener(element, selector, type, callback) {
                    return function (e) {
                      e.delegateTarget = closest(e.target, selector);
                      if (e.delegateTarget) {
                        callback.call(element, e);
                      }
                    };
                  }
                  module.exports = delegate;

                  /***/
                }),
                /***/879: (/***/function (__unused_webpack_module, exports) {
                  /**
                   * Check if argument is a HTML element.
                   *
                   * @param {Object} value
                   * @return {Boolean}
                   */
                  exports.node = function (value) {
                    return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
                  };

                  /**
                   * Check if argument is a list of HTML elements.
                   *
                   * @param {Object} value
                   * @return {Boolean}
                   */
                  exports.nodeList = function (value) {
                    var type = Object.prototype.toString.call(value);
                    return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));
                  };

                  /**
                   * Check if argument is a string.
                   *
                   * @param {Object} value
                   * @return {Boolean}
                   */
                  exports.string = function (value) {
                    return typeof value === 'string' || value instanceof String;
                  };

                  /**
                   * Check if argument is a function.
                   *
                   * @param {Object} value
                   * @return {Boolean}
                   */
                  exports.fn = function (value) {
                    var type = Object.prototype.toString.call(value);
                    return type === '[object Function]';
                  };

                  /***/
                }),
                /***/370: (/***/function (module, __unused_webpack_exports, __webpack_require__) {
                  var is = __webpack_require__(879);
                  var delegate = __webpack_require__(438);

                  /**
                   * Validates all params and calls the right
                   * listener function based on its target type.
                   *
                   * @param {String|HTMLElement|HTMLCollection|NodeList} target
                   * @param {String} type
                   * @param {Function} callback
                   * @return {Object}
                   */
                  function listen(target, type, callback) {
                    if (!target && !type && !callback) {
                      throw new Error('Missing required arguments');
                    }
                    if (!is.string(type)) {
                      throw new TypeError('Second argument must be a String');
                    }
                    if (!is.fn(callback)) {
                      throw new TypeError('Third argument must be a Function');
                    }
                    if (is.node(target)) {
                      return listenNode(target, type, callback);
                    } else if (is.nodeList(target)) {
                      return listenNodeList(target, type, callback);
                    } else if (is.string(target)) {
                      return listenSelector(target, type, callback);
                    } else {
                      throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
                    }
                  }

                  /**
                   * Adds an event listener to a HTML element
                   * and returns a remove listener function.
                   *
                   * @param {HTMLElement} node
                   * @param {String} type
                   * @param {Function} callback
                   * @return {Object}
                   */
                  function listenNode(node, type, callback) {
                    node.addEventListener(type, callback);
                    return {
                      destroy: function () {
                        node.removeEventListener(type, callback);
                      }
                    };
                  }

                  /**
                   * Add an event listener to a list of HTML elements
                   * and returns a remove listener function.
                   *
                   * @param {NodeList|HTMLCollection} nodeList
                   * @param {String} type
                   * @param {Function} callback
                   * @return {Object}
                   */
                  function listenNodeList(nodeList, type, callback) {
                    Array.prototype.forEach.call(nodeList, function (node) {
                      node.addEventListener(type, callback);
                    });
                    return {
                      destroy: function () {
                        Array.prototype.forEach.call(nodeList, function (node) {
                          node.removeEventListener(type, callback);
                        });
                      }
                    };
                  }

                  /**
                   * Add an event listener to a selector
                   * and returns a remove listener function.
                   *
                   * @param {String} selector
                   * @param {String} type
                   * @param {Function} callback
                   * @return {Object}
                   */
                  function listenSelector(selector, type, callback) {
                    return delegate(document.body, selector, type, callback);
                  }
                  module.exports = listen;

                  /***/
                }),
                /***/817: (/***/function (module) {
                  function select(element) {
                    var selectedText;
                    if (element.nodeName === 'SELECT') {
                      element.focus();
                      selectedText = element.value;
                    } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                      var isReadOnly = element.hasAttribute('readonly');
                      if (!isReadOnly) {
                        element.setAttribute('readonly', '');
                      }
                      element.select();
                      element.setSelectionRange(0, element.value.length);
                      if (!isReadOnly) {
                        element.removeAttribute('readonly');
                      }
                      selectedText = element.value;
                    } else {
                      if (element.hasAttribute('contenteditable')) {
                        element.focus();
                      }
                      var selection = window.getSelection();
                      var range = document.createRange();
                      range.selectNodeContents(element);
                      selection.removeAllRanges();
                      selection.addRange(range);
                      selectedText = selection.toString();
                    }
                    return selectedText;
                  }
                  module.exports = select;

                  /***/
                }),
                /***/279: (/***/function (module) {
                  function E() {
                    // Keep this empty so it's easier to inherit from
                    // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
                  }
                  E.prototype = {
                    on: function (name, callback, ctx) {
                      var e = this.e || (this.e = {});
                      (e[name] || (e[name] = [])).push({
                        fn: callback,
                        ctx: ctx
                      });
                      return this;
                    },
                    once: function (name, callback, ctx) {
                      var self = this;
                      function listener() {
                        self.off(name, listener);
                        callback.apply(ctx, arguments);
                      }
                      listener._ = callback;
                      return this.on(name, listener, ctx);
                    },
                    emit: function (name) {
                      var data = [].slice.call(arguments, 1);
                      var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                      var i = 0;
                      var len = evtArr.length;
                      for (i; i < len; i++) {
                        evtArr[i].fn.apply(evtArr[i].ctx, data);
                      }
                      return this;
                    },
                    off: function (name, callback) {
                      var e = this.e || (this.e = {});
                      var evts = e[name];
                      var liveEvents = [];
                      if (evts && callback) {
                        for (var i = 0, len = evts.length; i < len; i++) {
                          if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
                        }
                      }

                      // Remove event from queue to prevent memory leak
                      // Suggested by https://github.com/lazd
                      // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

                      liveEvents.length ? e[name] = liveEvents : delete e[name];
                      return this;
                    }
                  };
                  module.exports = E;
                  module.exports.TinyEmitter = E;

                  /***/
                })

                /******/
              };
              /************************************************************************/
              /******/ // The module cache
              /******/
              var __webpack_module_cache__ = {};
              /******/
              /******/ // The require function
              /******/
              function __webpack_require__(moduleId) {
                /******/ // Check if module is in cache
                /******/if (__webpack_module_cache__[moduleId]) {
                  /******/return __webpack_module_cache__[moduleId].exports;
                  /******/
                }
                /******/ // Create a new module (and put it into the cache)
                /******/
                var module = __webpack_module_cache__[moduleId] = {
                  /******/ // no module.id needed
                  /******/ // no module.loaded needed
                  /******/exports: {}
                  /******/
                };
                /******/
                /******/ // Execute the module function
                /******/
                __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
                /******/
                /******/ // Return the exports of the module
                /******/
                return module.exports;
                /******/
              }
              /******/
              /************************************************************************/
              /******/ /* webpack/runtime/compat get default export */
              /******/
              !function () {
                /******/ // getDefaultExport function for compatibility with non-harmony modules
                /******/__webpack_require__.n = function (module) {
                  /******/var getter = module && module.__esModule ? /******/function () {
                    return module['default'];
                  } : /******/function () {
                    return module;
                  };
                  /******/
                  __webpack_require__.d(getter, {
                    a: getter
                  });
                  /******/
                  return getter;
                  /******/
                };
                /******/
              }();
              /******/
              /******/ /* webpack/runtime/define property getters */
              /******/
              !function () {
                /******/ // define getter functions for harmony exports
                /******/__webpack_require__.d = function (exports, definition) {
                  /******/for (var key in definition) {
                    /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                      /******/Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                      });
                      /******/
                    }
                    /******/
                  }
                  /******/
                };
                /******/
              }();
              /******/
              /******/ /* webpack/runtime/hasOwnProperty shorthand */
              /******/
              !function () {
                /******/__webpack_require__.o = function (obj, prop) {
                  return Object.prototype.hasOwnProperty.call(obj, prop);
                };
                /******/
              }();
              /******/
              /************************************************************************/
              /******/ // module exports must be returned from runtime so entry inlining is disabled
              /******/ // startup
              /******/ // Load entry module and return exports
              /******/
              return __webpack_require__(686);
              /******/
            }().default;
          });
        })(clipboard);
        var clipboardExports = clipboard.exports;
        const Clipboard = /*@__PURE__*/getDefaultExportFromCjs(clipboardExports);

        /**
         * External dependencies
         */

        /**
         * @template T
         * @param {T} value
         * @return {import('react').RefObject<T>} The updated ref
         */
        function useUpdatedRef(value) {
          const ref = reactExports.useRef(value);
          reactExports.useLayoutEffect(() => {
            ref.current = value;
          }, [value]);
          return ref;
        }

        /**
         * Copies the given text to the clipboard when the element is clicked.
         *
         * @template {HTMLElement} TElementType
         * @param {string | (() => string)} text      The text to copy. Use a function if not
         *                                            already available and expensive to compute.
         * @param {Function}                onSuccess Called when to text is copied.
         *
         * @return {import('react').Ref<TElementType>} A ref to assign to the target element.
         */
        function useCopyToClipboard(text, onSuccess) {
          // Store the dependencies as refs and continuously update them so they're
          // fresh when the callback is called.
          const textRef = useUpdatedRef(text);
          const onSuccessRef = useUpdatedRef(onSuccess);
          return useRefEffect(node => {
            // Clipboard listens to click events.
            const clipboard = new Clipboard(node, {
              text() {
                return typeof textRef.current === 'function' ? textRef.current() : textRef.current || '';
              }
            });
            clipboard.on('success', ({
              clearSelection
            }) => {
              // Clearing selection will move focus back to the triggering
              // button, ensuring that it is not reset to the body, and
              // further that it is kept within the rendered node.
              clearSelection();
              if (onSuccessRef.current) {
                onSuccessRef.current();
              }
            });
            return () => {
              clipboard.destroy();
            };
          }, []);
        }

        /**
         * WordPress dependencies
         */

        /**
         * Hook used to focus the first tabbable element on mount.
         *
         * @param {boolean | 'firstElement'} focusOnMount Focus on mount mode.
         * @return {import('react').RefCallback<HTMLElement>} Ref callback.
         *
         * @example
         * ```js
         * import { useFocusOnMount } from '@wordpress/compose';
         *
         * const WithFocusOnMount = () => {
         *     const ref = useFocusOnMount()
         *     return (
         *         <div ref={ ref }>
         *             <Button />
         *             <Button />
         *         </div>
         *     );
         * }
         * ```
         */
        function useFocusOnMount(focusOnMount = 'firstElement') {
          const focusOnMountRef = reactExports.useRef(focusOnMount);

          /**
           * Sets focus on a DOM element.
           *
           * @param {HTMLElement} target The DOM element to set focus to.
           * @return {void}
           */
          const setFocus = target => {
            target.focus({
              // When focusing newly mounted dialogs,
              // the position of the popover is often not right on the first render
              // This prevents the layout shifts when focusing the dialogs.
              preventScroll: true
            });
          };

          /** @type {import('react').MutableRefObject<ReturnType<setTimeout> | undefined>} */
          const timerIdRef = reactExports.useRef();
          reactExports.useEffect(() => {
            focusOnMountRef.current = focusOnMount;
          }, [focusOnMount]);
          return useRefEffect(node => {
            var _node$ownerDocument$a;
            if (!node || focusOnMountRef.current === false) {
              return;
            }
            if (node.contains((_node$ownerDocument$a = node.ownerDocument?.activeElement) !== null && _node$ownerDocument$a !== void 0 ? _node$ownerDocument$a : null)) {
              return;
            }
            if (focusOnMountRef.current !== 'firstElement') {
              setFocus(node);
              return;
            }
            timerIdRef.current = setTimeout(() => {
              const firstTabbable = focus.tabbable.find(node)[0];
              if (firstTabbable) {
                setFocus(firstTabbable);
              }
            }, 0);
            return () => {
              if (timerIdRef.current) {
                clearTimeout(timerIdRef.current);
              }
            };
          }, []);
        }

        /**
         * WordPress dependencies
         */

        /** @type {Element|null} */
        let origin = null;

        /**
         * Adds the unmount behavior of returning focus to the element which had it
         * previously as is expected for roles like menus or dialogs.
         *
         * @param {() => void} [onFocusReturn] Overrides the default return behavior.
         * @return {import('react').RefCallback<HTMLElement>} Element Ref.
         *
         * @example
         * ```js
         * import { useFocusReturn } from '@wordpress/compose';
         *
         * const WithFocusReturn = () => {
         *     const ref = useFocusReturn()
         *     return (
         *         <div ref={ ref }>
         *             <Button />
         *             <Button />
         *         </div>
         *     );
         * }
         * ```
         */
        function useFocusReturn(onFocusReturn) {
          /** @type {import('react').MutableRefObject<null | HTMLElement>} */
          const ref = reactExports.useRef(null);
          /** @type {import('react').MutableRefObject<null | Element>} */
          const focusedBeforeMount = reactExports.useRef(null);
          const onFocusReturnRef = reactExports.useRef(onFocusReturn);
          reactExports.useEffect(() => {
            onFocusReturnRef.current = onFocusReturn;
          }, [onFocusReturn]);
          return reactExports.useCallback(node => {
            if (node) {
              var _activeDocument$activ;
              // Set ref to be used when unmounting.
              ref.current = node;

              // Only set when the node mounts.
              if (focusedBeforeMount.current) {
                return;
              }
              const activeDocument = node.ownerDocument.activeElement instanceof window.HTMLIFrameElement ? node.ownerDocument.activeElement.contentDocument : node.ownerDocument;
              focusedBeforeMount.current = (_activeDocument$activ = activeDocument?.activeElement) !== null && _activeDocument$activ !== void 0 ? _activeDocument$activ : null;
            } else if (focusedBeforeMount.current) {
              const isFocused = ref.current?.contains(ref.current?.ownerDocument.activeElement);
              if (ref.current?.isConnected && !isFocused) {
                var _origin;
                (_origin = origin) !== null && _origin !== void 0 ? _origin : origin = focusedBeforeMount.current;
                return;
              }

              // Defer to the component's own explicit focus return behavior, if
              // specified. This allows for support that the `onFocusReturn`
              // decides to allow the default behavior to occur under some
              // conditions.
              if (onFocusReturnRef.current) {
                onFocusReturnRef.current();
              } else {
                /** @type {null|HTMLElement} */(!focusedBeforeMount.current.isConnected ? origin : focusedBeforeMount.current)?.focus();
              }
              origin = null;
            }
          }, []);
        }

        /**
         * WordPress dependencies
         */

        /* eslint-disable jsdoc/valid-types */
        /**
         * @template T
         * @typedef {T extends import('react').Ref<infer R> ? R : never} TypeFromRef
         */
        /* eslint-enable jsdoc/valid-types */

        /**
         * @template T
         * @param {import('react').Ref<T>} ref
         * @param {T}                      value
         */
        function assignRef(ref, value) {
          if (typeof ref === 'function') {
            ref(value);
          } else if (ref && ref.hasOwnProperty('current')) {
            /* eslint-disable jsdoc/no-undefined-types */
            /** @type {import('react').MutableRefObject<T>} */ref.current = value;
            /* eslint-enable jsdoc/no-undefined-types */
          }
        }

        /**
         * Merges refs into one ref callback.
         *
         * It also ensures that the merged ref callbacks are only called when they
         * change (as a result of a `useCallback` dependency update) OR when the ref
         * value changes, just as React does when passing a single ref callback to the
         * component.
         *
         * As expected, if you pass a new function on every render, the ref callback
         * will be called after every render.
         *
         * If you don't wish a ref callback to be called after every render, wrap it
         * with `useCallback( callback, dependencies )`. When a dependency changes, the
         * old ref callback will be called with `null` and the new ref callback will be
         * called with the same value.
         *
         * To make ref callbacks easier to use, you can also pass the result of
         * `useRefEffect`, which makes cleanup easier by allowing you to return a
         * cleanup function instead of handling `null`.
         *
         * It's also possible to _disable_ a ref (and its behaviour) by simply not
         * passing the ref.
         *
         * ```jsx
         * const ref = useRefEffect( ( node ) => {
         *   node.addEventListener( ... );
         *   return () => {
         *     node.removeEventListener( ... );
         *   };
         * }, [ ...dependencies ] );
         * const otherRef = useRef();
         * const mergedRefs useMergeRefs( [
         *   enabled && ref,
         *   otherRef,
         * ] );
         * return <div ref={ mergedRefs } />;
         * ```
         *
         * @template {import('react').Ref<any>} TRef
         * @param {Array<TRef>} refs The refs to be merged.
         *
         * @return {import('react').RefCallback<TypeFromRef<TRef>>} The merged ref callback.
         */
        function useMergeRefs$1(refs) {
          const element = reactExports.useRef();
          const isAttachedRef = reactExports.useRef(false);
          const didElementChangeRef = reactExports.useRef(false);
          /* eslint-disable jsdoc/no-undefined-types */
          /** @type {import('react').MutableRefObject<TRef[]>} */
          /* eslint-enable jsdoc/no-undefined-types */
          const previousRefsRef = reactExports.useRef([]);
          const currentRefsRef = reactExports.useRef(refs);

          // Update on render before the ref callback is called, so the ref callback
          // always has access to the current refs.
          currentRefsRef.current = refs;

          // If any of the refs change, call the previous ref with `null` and the new
          // ref with the node, except when the element changes in the same cycle, in
          // which case the ref callbacks will already have been called.
          reactExports.useLayoutEffect(() => {
            if (didElementChangeRef.current === false && isAttachedRef.current === true) {
              refs.forEach((ref, index) => {
                const previousRef = previousRefsRef.current[index];
                if (ref !== previousRef) {
                  assignRef(previousRef, null);
                  assignRef(ref, element.current);
                }
              });
            }
            previousRefsRef.current = refs;
          }, refs);

          // No dependencies, must be reset after every render so ref callbacks are
          // correctly called after a ref change.
          reactExports.useLayoutEffect(() => {
            didElementChangeRef.current = false;
          });

          // There should be no dependencies so that `callback` is only called when
          // the node changes.
          return reactExports.useCallback(value => {
            // Update the element so it can be used when calling ref callbacks on a
            // dependency change.
            assignRef(element, value);
            didElementChangeRef.current = true;
            isAttachedRef.current = value !== null;

            // When an element changes, the current ref callback should be called
            // with the new element and the previous one with `null`.
            const refsToAssign = value ? currentRefsRef.current : previousRefsRef.current;

            // Update the latest refs.
            for (const ref of refsToAssign) {
              assignRef(ref, value);
            }
          }, []);
        }

        /**
         * WordPress dependencies
         */
        const matchMediaCache = new Map();

        /**
         * A new MediaQueryList object for the media query
         *
         * @param {string} [query] Media Query.
         * @return {MediaQueryList|null} A new object for the media query
         */
        function getMediaQueryList(query) {
          let match = matchMediaCache.get(query);
          if (match) {
            return match;
          }
          if (typeof window !== 'undefined' && typeof window.matchMedia === 'function') {
            match = window.matchMedia(query);
            matchMediaCache.set(query, match);
            return match;
          }
          return null;
        }

        /**
         * Runs a media query and returns its value when it changes.
         *
         * @param {string} [query] Media Query.
         * @return {boolean} return value of the media query.
         */
        function useMediaQuery(query) {
          const source = reactExports.useMemo(() => {
            const mediaQueryList = getMediaQueryList(query);
            return {
              /** @type {(onStoreChange: () => void) => () => void} */
              subscribe(onStoreChange) {
                if (!mediaQueryList) {
                  return () => {};
                }

                // Avoid a fatal error when browsers don't support `addEventListener` on MediaQueryList.
                mediaQueryList.addEventListener?.('change', onStoreChange);
                return () => {
                  mediaQueryList.removeEventListener?.('change', onStoreChange);
                };
              },
              getValue() {
                var _mediaQueryList$match;
                return (_mediaQueryList$match = mediaQueryList?.matches) !== null && _mediaQueryList$match !== void 0 ? _mediaQueryList$match : false;
              }
            };
          }, [query]);
          return reactExports.useSyncExternalStore(source.subscribe, source.getValue, () => false);
        }

        /**
         * WordPress dependencies
         */

        /**
         * Use something's value from the previous render.
         * Based on https://usehooks.com/usePrevious/.
         *
         * @param value The value to track.
         *
         * @return The value from the previous render.
         */
        function usePrevious$1(value) {
          const ref = reactExports.useRef();

          // Store current value in ref.
          reactExports.useEffect(() => {
            ref.current = value;
          }, [value]); // Re-run when value changes.

          // Return previous value (happens before update in useEffect above).
          return ref.current;
        }

        /**
         * Internal dependencies
         */

        /**
         * Hook returning whether the user has a preference for reduced motion.
         *
         * @return {boolean} Reduced motion preference value.
         */
        const useReducedMotion = () => useMediaQuery('(prefers-reduced-motion: reduce)');
        function areInputsEqual(newInputs, lastInputs) {
          if (newInputs.length !== lastInputs.length) {
            return false;
          }
          for (var i = 0; i < newInputs.length; i++) {
            if (newInputs[i] !== lastInputs[i]) {
              return false;
            }
          }
          return true;
        }
        function useMemoOne(getResult, inputs) {
          var initial = reactExports.useState(function () {
            return {
              inputs: inputs,
              result: getResult()
            };
          })[0];
          var isFirstRun = reactExports.useRef(true);
          var committed = reactExports.useRef(initial);
          var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
          var cache = useCache ? committed.current : {
            inputs: inputs,
            result: getResult()
          };
          reactExports.useEffect(function () {
            isFirstRun.current = false;
            committed.current = cache;
          }, [cache]);
          return cache.result;
        }

        /**
         * External dependencies
         */

        /**
         * Debounces a function similar to Lodash's `debounce`. A new debounced function will
         * be returned and any scheduled calls cancelled if any of the arguments change,
         * including the function to debounce, so please wrap functions created on
         * render in components in `useCallback`.
         *
         * @see https://lodash.com/docs/4#debounce
         *
         * @template {(...args: any[]) => void} TFunc
         *
         * @param {TFunc}                                          fn        The function to debounce.
         * @param {number}                                         [wait]    The number of milliseconds to delay.
         * @param {import('../../utils/debounce').DebounceOptions} [options] The options object.
         * @return {import('../../utils/debounce').DebouncedFunc<TFunc>} Debounced function.
         */
        function useDebounce(fn, wait, options) {
          const debounced = useMemoOne(() => debounce(fn, 0), [fn, wait, options]);
          reactExports.useEffect(() => () => debounced.cancel(), [debounced]);
          return debounced;
        }
        var __defProp$1 = Object.defineProperty;
        var __defProps$1 = Object.defineProperties;
        var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
        var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
        var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
        var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
        var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value
        }) : obj[key] = value;
        var __spreadValues$1 = (a, b) => {
          for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
          if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {
            if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);
          }
          return a;
        };
        var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
        var __objRest$1 = (source, exclude) => {
          var target = {};
          for (var prop in source) if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
          if (source != null && __getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop)) target[prop] = source[prop];
          }
          return target;
        };
        var __defProp = Object.defineProperty;
        var __defProps = Object.defineProperties;
        var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
        var __getOwnPropSymbols = Object.getOwnPropertySymbols;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __propIsEnum = Object.prototype.propertyIsEnumerable;
        var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value
        }) : obj[key] = value;
        var __spreadValues = (a, b) => {
          for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
          if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
          }
          return a;
        };
        var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
        var __objRest = (source, exclude) => {
          var target = {};
          for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
          if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
          }
          return target;
        };

        // src/utils/misc.ts
        function noop$8(..._) {}
        function applyState(argument, currentValue) {
          if (isUpdater(argument)) {
            const value = isLazyValue(currentValue) ? currentValue() : currentValue;
            return argument(value);
          }
          return argument;
        }
        function isUpdater(argument) {
          return typeof argument === "function";
        }
        function isLazyValue(value) {
          return typeof value === "function";
        }
        function hasOwnProperty(object, prop) {
          if (typeof Object.hasOwn === "function") {
            return Object.hasOwn(object, prop);
          }
          return Object.prototype.hasOwnProperty.call(object, prop);
        }
        function chain$1(...fns) {
          return (...args) => {
            for (const fn of fns) {
              if (typeof fn === "function") {
                fn(...args);
              }
            }
          };
        }
        function omit(object, keys) {
          const result = __spreadValues({}, object);
          for (const key of keys) {
            if (hasOwnProperty(result, key)) {
              delete result[key];
            }
          }
          return result;
        }
        function pick(object, paths) {
          const result = {};
          for (const key of paths) {
            if (hasOwnProperty(object, key)) {
              result[key] = object[key];
            }
          }
          return result;
        }
        function identity$1(value) {
          return value;
        }
        function invariant(condition, message) {
          if (condition) return;
          if (typeof message !== "string") throw new Error("Invariant failed");
          throw new Error(message);
        }
        function getKeys$1(obj) {
          return Object.keys(obj);
        }
        function isFalsyBooleanCallback(booleanOrCallback, ...args) {
          const result = typeof booleanOrCallback === "function" ? booleanOrCallback(...args) : booleanOrCallback;
          if (result == null) return false;
          return !result;
        }
        function disabledFromProps(props) {
          return props.disabled || props["aria-disabled"] === true || props["aria-disabled"] === "true";
        }
        function removeUndefinedValues(obj) {
          const result = {};
          for (const key in obj) {
            if (obj[key] !== void 0) {
              result[key] = obj[key];
            }
          }
          return result;
        }
        function defaultValue$3(...values) {
          for (const value of values) {
            if (value !== void 0) return value;
          }
          return void 0;
        }
        function setRef(ref, value) {
          if (typeof ref === "function") {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
        }
        function isValidElementWithRef(element) {
          if (!element) return false;
          if (!reactExports.isValidElement(element)) return false;
          if ("ref" in element.props) return true;
          if ("ref" in element) return true;
          return false;
        }
        function getRefProperty(element) {
          if (!isValidElementWithRef(element)) return null;
          const props = __spreadValues$1({}, element.props);
          return props.ref || element.ref;
        }
        function mergeProps(base, overrides) {
          const props = __spreadValues$1({}, base);
          for (const key in overrides) {
            if (!hasOwnProperty(overrides, key)) continue;
            if (key === "className") {
              const prop = "className";
              props[prop] = base[prop] ? `${base[prop]} ${overrides[prop]}` : overrides[prop];
              continue;
            }
            if (key === "style") {
              const prop = "style";
              props[prop] = base[prop] ? __spreadValues$1(__spreadValues$1({}, base[prop]), overrides[prop]) : overrides[prop];
              continue;
            }
            const overrideValue = overrides[key];
            if (typeof overrideValue === "function" && key.startsWith("on")) {
              const baseValue = base[key];
              if (typeof baseValue === "function") {
                props[key] = (...args) => {
                  overrideValue(...args);
                  baseValue(...args);
                };
                continue;
              }
            }
            props[key] = overrideValue;
          }
          return props;
        }

        // src/utils/dom.ts
        var canUseDOM$1 = checkIsBrowser();
        function checkIsBrowser() {
          var _a;
          return typeof window !== "undefined" && !!((_a = window.document) == null ? void 0 : _a.createElement);
        }
        function getDocument(node) {
          if (!node) return document;
          if ("self" in node) return node.document;
          return node.ownerDocument || document;
        }
        function getWindow$2(node) {
          if (!node) return self;
          if ("self" in node) return node.self;
          return getDocument(node).defaultView || window;
        }
        function getActiveElement(node, activeDescendant = false) {
          const {
            activeElement
          } = getDocument(node);
          if (!(activeElement == null ? void 0 : activeElement.nodeName)) {
            return null;
          }
          if (isFrame(activeElement) && activeElement.contentDocument) {
            return getActiveElement(activeElement.contentDocument.body, activeDescendant);
          }
          if (activeDescendant) {
            const id = activeElement.getAttribute("aria-activedescendant");
            if (id) {
              const element = getDocument(activeElement).getElementById(id);
              if (element) {
                return element;
              }
            }
          }
          return activeElement;
        }
        function contains(parent, child) {
          return parent === child || parent.contains(child);
        }
        function isFrame(element) {
          return element.tagName === "IFRAME";
        }
        function isButton(element) {
          const tagName = element.tagName.toLowerCase();
          if (tagName === "button") return true;
          if (tagName === "input" && element.type) {
            return buttonInputTypes.indexOf(element.type) !== -1;
          }
          return false;
        }
        var buttonInputTypes = ["button", "color", "file", "image", "reset", "submit"];
        function isVisible(element) {
          if (typeof element.checkVisibility === "function") {
            return element.checkVisibility();
          }
          const htmlElement = element;
          return htmlElement.offsetWidth > 0 || htmlElement.offsetHeight > 0 || element.getClientRects().length > 0;
        }
        function isTextField(element) {
          try {
            const isTextInput = element instanceof HTMLInputElement && element.selectionStart !== null;
            const isTextArea = element.tagName === "TEXTAREA";
            return isTextInput || isTextArea || false;
          } catch (error) {
            return false;
          }
        }
        function isTextbox(element) {
          return element.isContentEditable || isTextField(element);
        }
        function getTextboxValue(element) {
          if (isTextField(element)) {
            return element.value;
          }
          if (element.isContentEditable) {
            const range = getDocument(element).createRange();
            range.selectNodeContents(element);
            return range.toString();
          }
          return "";
        }
        function getTextboxSelection(element) {
          let start = 0;
          let end = 0;
          if (isTextField(element)) {
            start = element.selectionStart || 0;
            end = element.selectionEnd || 0;
          } else if (element.isContentEditable) {
            const selection = getDocument(element).getSelection();
            if ((selection == null ? void 0 : selection.rangeCount) && selection.anchorNode && contains(element, selection.anchorNode) && selection.focusNode && contains(element, selection.focusNode)) {
              const range = selection.getRangeAt(0);
              const nextRange = range.cloneRange();
              nextRange.selectNodeContents(element);
              nextRange.setEnd(range.startContainer, range.startOffset);
              start = nextRange.toString().length;
              nextRange.setEnd(range.endContainer, range.endOffset);
              end = nextRange.toString().length;
            }
          }
          return {
            start,
            end
          };
        }
        function getScrollingElement(element) {
          if (!element) return null;
          const isScrollableOverflow = overflow => {
            if (overflow === "auto") return true;
            if (overflow === "scroll") return true;
            return false;
          };
          if (element.clientHeight && element.scrollHeight > element.clientHeight) {
            const {
              overflowY
            } = getComputedStyle(element);
            if (isScrollableOverflow(overflowY)) return element;
          } else if (element.clientWidth && element.scrollWidth > element.clientWidth) {
            const {
              overflowX
            } = getComputedStyle(element);
            if (isScrollableOverflow(overflowX)) return element;
          }
          return getScrollingElement(element.parentElement) || document.scrollingElement || document.body;
        }
        function sortBasedOnDOMPosition(items, getElement) {
          const pairs = items.map((item, index) => [index, item]);
          let isOrderDifferent = false;
          pairs.sort(([indexA, a], [indexB, b]) => {
            const elementA = getElement(a);
            const elementB = getElement(b);
            if (elementA === elementB) return 0;
            if (!elementA || !elementB) return 0;
            if (isElementPreceding(elementA, elementB)) {
              if (indexA > indexB) {
                isOrderDifferent = true;
              }
              return -1;
            }
            if (indexA < indexB) {
              isOrderDifferent = true;
            }
            return 1;
          });
          if (isOrderDifferent) {
            return pairs.map(([_, item]) => item);
          }
          return items;
        }
        function isElementPreceding(a, b) {
          return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
        }

        // src/utils/platform.ts
        function isTouchDevice() {
          return canUseDOM$1 && !!navigator.maxTouchPoints;
        }
        function isApple() {
          if (!canUseDOM$1) return false;
          return /mac|iphone|ipad|ipod/i.test(navigator.platform);
        }
        function isSafari() {
          return canUseDOM$1 && isApple() && /apple/i.test(navigator.vendor);
        }
        function isFirefox() {
          return canUseDOM$1 && /firefox\//i.test(navigator.userAgent);
        }
        function isMac() {
          return canUseDOM$1 && navigator.platform.startsWith("Mac") && !isTouchDevice();
        }

        // src/utils/events.ts
        function isPortalEvent(event) {
          return Boolean(event.currentTarget && !contains(event.currentTarget, event.target));
        }
        function isSelfTarget(event) {
          return event.target === event.currentTarget;
        }
        function fireBlurEvent(element, eventInit) {
          const event = new FocusEvent("blur", eventInit);
          const defaultAllowed = element.dispatchEvent(event);
          const bubbleInit = __spreadProps(__spreadValues({}, eventInit), {
            bubbles: true
          });
          element.dispatchEvent(new FocusEvent("focusout", bubbleInit));
          return defaultAllowed;
        }
        function fireKeyboardEvent(element, type, eventInit) {
          const event = new KeyboardEvent(type, eventInit);
          return element.dispatchEvent(event);
        }
        function fireClickEvent(element, eventInit) {
          const event = new MouseEvent("click", eventInit);
          return element.dispatchEvent(event);
        }
        function isFocusEventOutside(event, container) {
          const containerElement = container || event.currentTarget;
          const relatedTarget = event.relatedTarget;
          return !relatedTarget || !contains(containerElement, relatedTarget);
        }
        function queueBeforeEvent(element, type, callback, timeout) {
          const createTimer = callback2 => {
            const timerId = requestAnimationFrame(callback2);
            return () => cancelAnimationFrame(timerId);
          };
          const cancelTimer = createTimer(() => {
            element.removeEventListener(type, callSync, true);
            callback();
          });
          const callSync = () => {
            cancelTimer();
            callback();
          };
          element.addEventListener(type, callSync, {
            once: true,
            capture: true
          });
          return cancelTimer;
        }
        function addGlobalEventListener(type, listener, options, scope = window) {
          const children = [];
          try {
            scope.document.addEventListener(type, listener, options);
            for (const frame of Array.from(scope.frames)) {
              children.push(addGlobalEventListener(type, listener, options, frame));
            }
          } catch (e) {}
          const removeEventListener = () => {
            try {
              scope.document.removeEventListener(type, listener, options);
            } catch (e) {}
            for (const remove of children) {
              remove();
            }
          };
          return removeEventListener;
        }
        var _React = __spreadValues$1({}, React$2);
        var useReactId = _React.useId;
        _React.useDeferredValue;
        var useReactInsertionEffect = _React.useInsertionEffect;
        var useSafeLayoutEffect = canUseDOM$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
        function useLiveRef(value) {
          const ref = reactExports.useRef(value);
          useSafeLayoutEffect(() => {
            ref.current = value;
          });
          return ref;
        }
        function useEvent$1(callback) {
          const ref = reactExports.useRef(() => {
            throw new Error("Cannot call an event handler while rendering.");
          });
          if (useReactInsertionEffect) {
            useReactInsertionEffect(() => {
              ref.current = callback;
            });
          } else {
            ref.current = callback;
          }
          return reactExports.useCallback((...args) => {
            var _a;
            return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);
          }, []);
        }
        function useTransactionState(callback) {
          const [state, setState] = reactExports.useState(null);
          useSafeLayoutEffect(() => {
            if (state == null) return;
            if (!callback) return;
            let prevState = null;
            callback(prev => {
              prevState = prev;
              return state;
            });
            return () => {
              callback(prevState);
            };
          }, [state, callback]);
          return [state, setState];
        }
        function useMergeRefs(...refs) {
          return reactExports.useMemo(() => {
            if (!refs.some(Boolean)) return;
            return value => {
              for (const ref of refs) {
                setRef(ref, value);
              }
            };
          }, refs);
        }
        function useId(defaultId) {
          if (useReactId) {
            const reactId = useReactId();
            if (defaultId) return defaultId;
            return reactId;
          }
          const [id, setId] = reactExports.useState(defaultId);
          useSafeLayoutEffect(() => {
            if (defaultId || id) return;
            const random = Math.random().toString(36).slice(2, 8);
            setId(`id-${random}`);
          }, [defaultId, id]);
          return defaultId || id;
        }
        function useTagName(refOrElement, type) {
          const stringOrUndefined = type2 => {
            return;
          };
          const [tagName, setTagName] = reactExports.useState(() => stringOrUndefined());
          useSafeLayoutEffect(() => {
            const element = refOrElement && "current" in refOrElement ? refOrElement.current : refOrElement;
            setTagName((element == null ? void 0 : element.tagName.toLowerCase()) || stringOrUndefined());
          }, [refOrElement, type]);
          return tagName;
        }
        function useUpdateEffect$1(effect, deps) {
          const mounted = reactExports.useRef(false);
          reactExports.useEffect(() => {
            if (mounted.current) {
              return effect();
            }
            mounted.current = true;
          }, deps);
          reactExports.useEffect(() => () => {
            mounted.current = false;
          }, []);
        }
        function useForceUpdate() {
          return reactExports.useReducer(() => [], []);
        }
        function useBooleanEvent(booleanOrCallback) {
          return useEvent$1(typeof booleanOrCallback === "function" ? booleanOrCallback : () => booleanOrCallback);
        }
        function useWrapElement(props, callback, deps = []) {
          const wrapElement = reactExports.useCallback(element => {
            if (props.wrapElement) {
              element = props.wrapElement(element);
            }
            return callback(element);
          }, [...deps, props.wrapElement]);
          return __spreadProps$1(__spreadValues$1({}, props), {
            wrapElement
          });
        }
        function usePortalRef(portalProp = false, portalRefProp) {
          const [portalNode, setPortalNode] = reactExports.useState(null);
          const portalRef = useMergeRefs(setPortalNode, portalRefProp);
          const domReady = !portalProp || portalNode;
          return {
            portalRef,
            portalNode,
            domReady
          };
        }
        function useMetadataProps(props, key, value) {
          const parent = props.onLoadedMetadataCapture;
          const onLoadedMetadataCapture = reactExports.useMemo(() => {
            return Object.assign(() => {}, __spreadProps$1(__spreadValues$1({}, parent), {
              [key]: value
            }));
          }, [parent, key, value]);
          return [parent == null ? void 0 : parent[key], {
            onLoadedMetadataCapture
          }];
        }
        function useIsMouseMoving() {
          reactExports.useEffect(() => {
            addGlobalEventListener("mousemove", setMouseMoving, true);
            addGlobalEventListener("mousedown", resetMouseMoving, true);
            addGlobalEventListener("mouseup", resetMouseMoving, true);
            addGlobalEventListener("keydown", resetMouseMoving, true);
            addGlobalEventListener("scroll", resetMouseMoving, true);
          }, []);
          const isMouseMoving = useEvent$1(() => mouseMoving);
          return isMouseMoving;
        }
        var mouseMoving = false;
        var previousScreenX = 0;
        var previousScreenY = 0;
        function hasMouseMovement(event) {
          const movementX = event.movementX || event.screenX - previousScreenX;
          const movementY = event.movementY || event.screenY - previousScreenY;
          previousScreenX = event.screenX;
          previousScreenY = event.screenY;
          return movementX || movementY || false;
        }
        function setMouseMoving(event) {
          if (!hasMouseMovement(event)) return;
          mouseMoving = true;
        }
        function resetMouseMoving() {
          mouseMoving = false;
        }
        function forwardRef2(render) {
          const Role = reactExports.forwardRef((props, ref) => render(__spreadProps$1(__spreadValues$1({}, props), {
            ref
          })));
          Role.displayName = render.displayName || render.name;
          return Role;
        }
        function memo2(Component, propsAreEqual) {
          return reactExports.memo(Component, propsAreEqual);
        }
        function createElement(Type, props) {
          const _a = props,
            {
              wrapElement,
              render
            } = _a,
            rest = __objRest$1(_a, ["wrapElement", "render"]);
          const mergedRef = useMergeRefs(props.ref, getRefProperty(render));
          let element;
          if (reactExports.isValidElement(render)) {
            const renderProps = __spreadProps$1(__spreadValues$1({}, render.props), {
              ref: mergedRef
            });
            element = reactExports.cloneElement(render, mergeProps(rest, renderProps));
          } else if (render) {
            element = render(rest);
          } else {
            element = /* @__PURE__ */jsxRuntimeExports.jsx(Type, __spreadValues$1({}, rest));
          }
          if (wrapElement) {
            return wrapElement(element);
          }
          return element;
        }
        function createHook(useProps) {
          const useRole = (props = {}) => {
            return useProps(props);
          };
          useRole.displayName = useProps.name;
          return useRole;
        }
        function createStoreContext(providers = [], scopedProviders = []) {
          const context = reactExports.createContext(void 0);
          const scopedContext = reactExports.createContext(void 0);
          const useContext2 = () => reactExports.useContext(context);
          const useScopedContext = (onlyScoped = false) => {
            const scoped = reactExports.useContext(scopedContext);
            const store = useContext2();
            if (onlyScoped) return scoped;
            return scoped || store;
          };
          const useProviderContext = () => {
            const scoped = reactExports.useContext(scopedContext);
            const store = useContext2();
            if (scoped && scoped === store) return;
            return store;
          };
          const ContextProvider = props => {
            return providers.reduceRight((children, Provider) => /* @__PURE__ */jsxRuntimeExports.jsx(Provider, __spreadProps$1(__spreadValues$1({}, props), {
              children
            })), /* @__PURE__ */jsxRuntimeExports.jsx(context.Provider, __spreadValues$1({}, props)));
          };
          const ScopedContextProvider = props => {
            return /* @__PURE__ */jsxRuntimeExports.jsx(ContextProvider, __spreadProps$1(__spreadValues$1({}, props), {
              children: scopedProviders.reduceRight((children, Provider) => /* @__PURE__ */jsxRuntimeExports.jsx(Provider, __spreadProps$1(__spreadValues$1({}, props), {
                children
              })), /* @__PURE__ */jsxRuntimeExports.jsx(scopedContext.Provider, __spreadValues$1({}, props)))
            }));
          };
          return {
            context,
            scopedContext,
            useContext: useContext2,
            useScopedContext,
            useProviderContext,
            ContextProvider,
            ScopedContextProvider
          };
        }

        // src/disclosure/disclosure-context.tsx
        var ctx$9 = createStoreContext();
        var useDisclosureProviderContext = ctx$9.useProviderContext;
        var DisclosureContextProvider = ctx$9.ContextProvider;
        var DisclosureScopedContextProvider = ctx$9.ScopedContextProvider;
        var ctx$8 = createStoreContext([DisclosureContextProvider], [DisclosureScopedContextProvider]);
        var useDialogProviderContext = ctx$8.useProviderContext;
        var DialogContextProvider = ctx$8.ContextProvider;
        var DialogScopedContextProvider = ctx$8.ScopedContextProvider;
        var DialogHeadingContext = reactExports.createContext(void 0);
        var DialogDescriptionContext = reactExports.createContext(void 0);

        // src/popover/popover-context.tsx
        var ctx$7 = createStoreContext([DialogContextProvider], [DialogScopedContextProvider]);
        ctx$7.useContext;
        ctx$7.useScopedContext;
        var usePopoverProviderContext = ctx$7.useProviderContext;
        var PopoverContextProvider = ctx$7.ContextProvider;
        var PopoverScopedContextProvider = ctx$7.ScopedContextProvider;

        // src/collection/collection-context.tsx
        var ctx$6 = createStoreContext();
        var useCollectionContext = ctx$6.useContext;
        ctx$6.useScopedContext;
        ctx$6.useProviderContext;
        var CollectionContextProvider = ctx$6.ContextProvider;
        var CollectionScopedContextProvider = ctx$6.ScopedContextProvider;
        var ctx$5 = createStoreContext([CollectionContextProvider], [CollectionScopedContextProvider]);
        var useCompositeContext = ctx$5.useContext;
        ctx$5.useScopedContext;
        var useCompositeProviderContext = ctx$5.useProviderContext;
        var CompositeContextProvider = ctx$5.ContextProvider;
        var CompositeScopedContextProvider = ctx$5.ScopedContextProvider;
        var CompositeItemContext = reactExports.createContext(void 0);
        var CompositeRowContext = reactExports.createContext(void 0);
        var ctx$4 = createStoreContext([PopoverContextProvider, CompositeContextProvider], [PopoverScopedContextProvider, CompositeScopedContextProvider]);
        var useSelectContext = ctx$4.useContext;
        reactExports.createContext(false);
        reactExports.createContext(null);
        function getInternal(store, key) {
          const internals = store.__unstableInternals;
          invariant(internals, "Invalid store");
          return internals[key];
        }
        function createStore(initialState, ...stores) {
          let state = initialState;
          let prevStateBatch = state;
          let lastUpdate = Symbol();
          let destroy = noop$8;
          const instances = /* @__PURE__ */new Set();
          const updatedKeys = /* @__PURE__ */new Set();
          const setups = /* @__PURE__ */new Set();
          const listeners = /* @__PURE__ */new Set();
          const batchListeners = /* @__PURE__ */new Set();
          const disposables = /* @__PURE__ */new WeakMap();
          const listenerKeys = /* @__PURE__ */new WeakMap();
          const storeSetup = callback => {
            setups.add(callback);
            return () => setups.delete(callback);
          };
          const storeInit = () => {
            const initialized = instances.size;
            const instance = Symbol();
            instances.add(instance);
            const maybeDestroy = () => {
              instances.delete(instance);
              if (instances.size) return;
              destroy();
            };
            if (initialized) return maybeDestroy;
            const desyncs = getKeys$1(state).map(key => chain$1(...stores.map(store => {
              var _a;
              const storeState = (_a = store == null ? void 0 : store.getState) == null ? void 0 : _a.call(store);
              if (!storeState) return;
              if (!hasOwnProperty(storeState, key)) return;
              return sync(store, [key], state2 => {
                setState(key, state2[key],
                // @ts-expect-error - Not public API. This is just to prevent
                // infinite loops.
                true);
              });
            })));
            const teardowns = [];
            for (const setup2 of setups) {
              teardowns.push(setup2());
            }
            const cleanups = stores.map(init);
            destroy = chain$1(...desyncs, ...teardowns, ...cleanups);
            return maybeDestroy;
          };
          const sub = (keys, listener, set = listeners) => {
            set.add(listener);
            listenerKeys.set(listener, keys);
            return () => {
              var _a;
              (_a = disposables.get(listener)) == null ? void 0 : _a();
              disposables.delete(listener);
              listenerKeys.delete(listener);
              set.delete(listener);
            };
          };
          const storeSubscribe = (keys, listener) => sub(keys, listener);
          const storeSync = (keys, listener) => {
            disposables.set(listener, listener(state, state));
            return sub(keys, listener);
          };
          const storeBatch = (keys, listener) => {
            disposables.set(listener, listener(state, prevStateBatch));
            return sub(keys, listener, batchListeners);
          };
          const storePick = keys => createStore(pick(state, keys), finalStore);
          const storeOmit = keys => createStore(omit(state, keys), finalStore);
          const getState = () => state;
          const setState = (key, value, fromStores = false) => {
            var _a;
            if (!hasOwnProperty(state, key)) return;
            const nextValue = applyState(value, state[key]);
            if (nextValue === state[key]) return;
            if (!fromStores) {
              for (const store of stores) {
                (_a = store == null ? void 0 : store.setState) == null ? void 0 : _a.call(store, key, nextValue);
              }
            }
            const prevState = state;
            state = __spreadProps(__spreadValues({}, state), {
              [key]: nextValue
            });
            const thisUpdate = Symbol();
            lastUpdate = thisUpdate;
            updatedKeys.add(key);
            const run = (listener, prev, uKeys) => {
              var _a2;
              const keys = listenerKeys.get(listener);
              const updated = k => uKeys ? uKeys.has(k) : k === key;
              if (!keys || keys.some(updated)) {
                (_a2 = disposables.get(listener)) == null ? void 0 : _a2();
                disposables.set(listener, listener(state, prev));
              }
            };
            for (const listener of listeners) {
              run(listener, prevState);
            }
            queueMicrotask(() => {
              if (lastUpdate !== thisUpdate) return;
              const snapshot = state;
              for (const listener of batchListeners) {
                run(listener, prevStateBatch, updatedKeys);
              }
              prevStateBatch = snapshot;
              updatedKeys.clear();
            });
          };
          const finalStore = {
            getState,
            setState,
            __unstableInternals: {
              setup: storeSetup,
              init: storeInit,
              subscribe: storeSubscribe,
              sync: storeSync,
              batch: storeBatch,
              pick: storePick,
              omit: storeOmit
            }
          };
          return finalStore;
        }
        function setup(store, ...args) {
          if (!store) return;
          return getInternal(store, "setup")(...args);
        }
        function init(store, ...args) {
          if (!store) return;
          return getInternal(store, "init")(...args);
        }
        function subscribe(store, ...args) {
          if (!store) return;
          return getInternal(store, "subscribe")(...args);
        }
        function sync(store, ...args) {
          if (!store) return;
          return getInternal(store, "sync")(...args);
        }
        function batch(store, ...args) {
          if (!store) return;
          return getInternal(store, "batch")(...args);
        }
        function omit2(store, ...args) {
          if (!store) return;
          return getInternal(store, "omit")(...args);
        }
        function mergeStore(...stores) {
          const initialState = stores.reduce((state, store2) => {
            var _a;
            const nextState = (_a = store2 == null ? void 0 : store2.getState) == null ? void 0 : _a.call(store2);
            if (!nextState) return state;
            return Object.assign(state, nextState);
          }, {});
          const store = createStore(initialState, ...stores);
          return Object.assign({}, ...stores, store);
        }
        function throwOnConflictingProps(props, store) {
          return;
        }
        var shim$1 = {
          exports: {}
        };
        var useSyncExternalStoreShim_production = {};

        /**
         * @license React
         * use-sync-external-store-shim.production.js
         *
         * Copyright (c) Meta Platforms, Inc. and affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var React = reactExports;
        function is(x, y) {
          return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = "function" === typeof Object.is ? Object.is : is,
          useState = React.useState,
          useEffect = React.useEffect,
          useLayoutEffect = React.useLayoutEffect,
          useDebugValue = React.useDebugValue;
        function useSyncExternalStore$2(subscribe, getSnapshot) {
          var value = getSnapshot(),
            _useState = useState({
              inst: {
                value: value,
                getSnapshot: getSnapshot
              }
            }),
            inst = _useState[0].inst,
            forceUpdate = _useState[1];
          useLayoutEffect(function () {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({
              inst: inst
            });
          }, [subscribe, value, getSnapshot]);
          useEffect(function () {
            checkIfSnapshotChanged(inst) && forceUpdate({
              inst: inst
            });
            return subscribe(function () {
              checkIfSnapshotChanged(inst) && forceUpdate({
                inst: inst
              });
            });
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot) {
          return getSnapshot();
        }
        var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
        useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
        {
          shim$1.exports = useSyncExternalStoreShim_production;
        }
        var shimExports = shim$1.exports;
        const useSyncExternalStoreExports = /*@__PURE__*/getDefaultExportFromCjs(shimExports);
        var {
          useSyncExternalStore
        } = useSyncExternalStoreExports;
        var noopSubscribe = () => () => {};
        function useStoreState(store, keyOrSelector = identity$1) {
          const storeSubscribe = reactExports.useCallback(callback => {
            if (!store) return noopSubscribe();
            return subscribe(store, null, callback);
          }, [store]);
          const getSnapshot = () => {
            const key = typeof keyOrSelector === "string" ? keyOrSelector : null;
            const selector = typeof keyOrSelector === "function" ? keyOrSelector : null;
            const state = store == null ? void 0 : store.getState();
            if (selector) return selector(state);
            if (!state) return;
            if (!key) return;
            if (!hasOwnProperty(state, key)) return;
            return state[key];
          };
          return useSyncExternalStore(storeSubscribe, getSnapshot, getSnapshot);
        }
        function useStoreStateObject(store, object) {
          const objRef = reactExports.useRef({});
          const storeSubscribe = reactExports.useCallback(callback => {
            if (!store) return noopSubscribe();
            return subscribe(store, null, callback);
          }, [store]);
          const getSnapshot = () => {
            const state = store == null ? void 0 : store.getState();
            let updated = false;
            const obj = objRef.current;
            for (const prop in object) {
              const keyOrSelector = object[prop];
              if (typeof keyOrSelector === "function") {
                const value = keyOrSelector(state);
                if (value !== obj[prop]) {
                  obj[prop] = value;
                  updated = true;
                }
              }
              if (typeof keyOrSelector === "string") {
                if (!state) continue;
                if (!hasOwnProperty(state, keyOrSelector)) continue;
                const value = state[keyOrSelector];
                if (value !== obj[prop]) {
                  obj[prop] = value;
                  updated = true;
                }
              }
            }
            if (updated) {
              objRef.current = __spreadValues$1({}, obj);
            }
            return objRef.current;
          };
          return useSyncExternalStore(storeSubscribe, getSnapshot, getSnapshot);
        }
        function useStoreProps(store, props, key, setKey) {
          const value = hasOwnProperty(props, key) ? props[key] : void 0;
          const setValue = setKey ? props[setKey] : void 0;
          const propsRef = useLiveRef({
            value,
            setValue
          });
          useSafeLayoutEffect(() => {
            return sync(store, [key], (state, prev) => {
              const {
                value: value2,
                setValue: setValue2
              } = propsRef.current;
              if (!setValue2) return;
              if (state[key] === prev[key]) return;
              if (state[key] === value2) return;
              setValue2(state[key]);
            });
          }, [store, key]);
          useSafeLayoutEffect(() => {
            if (value === void 0) return;
            store.setState(key, value);
            return batch(store, [key], () => {
              if (value === void 0) return;
              store.setState(key, value);
            });
          });
        }
        function useStore(createStore, props) {
          const [store, setStore] = reactExports.useState(() => createStore(props));
          useSafeLayoutEffect(() => init(store), [store]);
          const useState2 = reactExports.useCallback(keyOrSelector => useStoreState(store, keyOrSelector), [store]);
          const memoizedStore = reactExports.useMemo(() => __spreadProps$1(__spreadValues$1({}, store), {
            useState: useState2
          }), [store, useState2]);
          const updateStore = useEvent$1(() => {
            setStore(store2 => createStore(__spreadValues$1(__spreadValues$1({}, props), store2.getState())));
          });
          return [memoizedStore, updateStore];
        }

        // src/collection/collection-store.ts
        function getCommonParent(items) {
          var _a;
          const firstItem = items.find(item => !!item.element);
          const lastItem = [...items].reverse().find(item => !!item.element);
          let parentElement = (_a = firstItem == null ? void 0 : firstItem.element) == null ? void 0 : _a.parentElement;
          while (parentElement && (lastItem == null ? void 0 : lastItem.element)) {
            const parent = parentElement;
            if (lastItem && parent.contains(lastItem.element)) {
              return parentElement;
            }
            parentElement = parentElement.parentElement;
          }
          return getDocument(parentElement).body;
        }
        function getPrivateStore(store) {
          return store == null ? void 0 : store.__unstablePrivateStore;
        }
        function createCollectionStore(props = {}) {
          var _a;
          throwOnConflictingProps(props, props.store);
          const syncState = (_a = props.store) == null ? void 0 : _a.getState();
          const items = defaultValue$3(props.items, syncState == null ? void 0 : syncState.items, props.defaultItems, []);
          const itemsMap = new Map(items.map(item => [item.id, item]));
          const initialState = {
            items,
            renderedItems: defaultValue$3(syncState == null ? void 0 : syncState.renderedItems, [])
          };
          const syncPrivateStore = getPrivateStore(props.store);
          const privateStore = createStore({
            items,
            renderedItems: initialState.renderedItems
          }, syncPrivateStore);
          const collection = createStore(initialState, props.store);
          const sortItems = renderedItems => {
            const sortedItems = sortBasedOnDOMPosition(renderedItems, i => i.element);
            privateStore.setState("renderedItems", sortedItems);
            collection.setState("renderedItems", sortedItems);
          };
          setup(collection, () => init(privateStore));
          setup(privateStore, () => {
            return batch(privateStore, ["items"], state => {
              collection.setState("items", state.items);
            });
          });
          setup(privateStore, () => {
            return batch(privateStore, ["renderedItems"], state => {
              let firstRun = true;
              let raf = requestAnimationFrame(() => {
                const {
                  renderedItems
                } = collection.getState();
                if (state.renderedItems === renderedItems) return;
                sortItems(state.renderedItems);
              });
              if (typeof IntersectionObserver !== "function") {
                return () => cancelAnimationFrame(raf);
              }
              const ioCallback = () => {
                if (firstRun) {
                  firstRun = false;
                  return;
                }
                cancelAnimationFrame(raf);
                raf = requestAnimationFrame(() => sortItems(state.renderedItems));
              };
              const root = getCommonParent(state.renderedItems);
              const observer = new IntersectionObserver(ioCallback, {
                root
              });
              for (const item of state.renderedItems) {
                if (!item.element) continue;
                observer.observe(item.element);
              }
              return () => {
                cancelAnimationFrame(raf);
                observer.disconnect();
              };
            });
          });
          const mergeItem = (item, setItems, canDeleteFromMap = false) => {
            let prevItem;
            setItems(items2 => {
              const index = items2.findIndex(({
                id
              }) => id === item.id);
              const nextItems = items2.slice();
              if (index !== -1) {
                prevItem = items2[index];
                const nextItem = __spreadValues(__spreadValues({}, prevItem), item);
                nextItems[index] = nextItem;
                itemsMap.set(item.id, nextItem);
              } else {
                nextItems.push(item);
                itemsMap.set(item.id, item);
              }
              return nextItems;
            });
            const unmergeItem = () => {
              setItems(items2 => {
                if (!prevItem) {
                  if (canDeleteFromMap) {
                    itemsMap.delete(item.id);
                  }
                  return items2.filter(({
                    id
                  }) => id !== item.id);
                }
                const index = items2.findIndex(({
                  id
                }) => id === item.id);
                if (index === -1) return items2;
                const nextItems = items2.slice();
                nextItems[index] = prevItem;
                itemsMap.set(item.id, prevItem);
                return nextItems;
              });
            };
            return unmergeItem;
          };
          const registerItem = item => mergeItem(item, getItems => privateStore.setState("items", getItems), true);
          return __spreadProps(__spreadValues({}, collection), {
            registerItem,
            renderItem: item => chain$1(registerItem(item), mergeItem(item, getItems => privateStore.setState("renderedItems", getItems))),
            item: id => {
              if (!id) return null;
              let item = itemsMap.get(id);
              if (!item) {
                const {
                  items: items2
                } = privateStore.getState();
                item = items2.find(item2 => item2.id === id);
                if (item) {
                  itemsMap.set(id, item);
                }
              }
              return item || null;
            },
            // @ts-expect-error Internal
            __unstablePrivateStore: privateStore
          });
        }
        function useCollectionStoreProps(store, update, props) {
          useUpdateEffect$1(update, [props.store]);
          useStoreProps(store, props, "items", "setItems");
          return store;
        }
        function flatten2DArray(array) {
          const flattened = [];
          for (const row of array) {
            flattened.push(...row);
          }
          return flattened;
        }
        function reverseArray(array) {
          return array.slice().reverse();
        }

        // src/composite/composite-store.ts
        var NULL_ITEM = {
          id: null
        };
        function findFirstEnabledItem$1(items, excludeId) {
          return items.find(item => {
            if (excludeId) {
              return !item.disabled && item.id !== excludeId;
            }
            return !item.disabled;
          });
        }
        function getEnabledItems(items, excludeId) {
          return items.filter(item => {
            if (excludeId) {
              return !item.disabled && item.id !== excludeId;
            }
            return !item.disabled;
          });
        }
        function getItemsInRow(items, rowId) {
          return items.filter(item => item.rowId === rowId);
        }
        function flipItems(items, activeId, shouldInsertNullItem = false) {
          const index = items.findIndex(item => item.id === activeId);
          return [...items.slice(index + 1), ...(shouldInsertNullItem ? [NULL_ITEM] : []), ...items.slice(0, index)];
        }
        function groupItemsByRows$1(items) {
          const rows = [];
          for (const item of items) {
            const row = rows.find(currentRow => {
              var _a;
              return ((_a = currentRow[0]) == null ? void 0 : _a.rowId) === item.rowId;
            });
            if (row) {
              row.push(item);
            } else {
              rows.push([item]);
            }
          }
          return rows;
        }
        function getMaxRowLength(array) {
          let maxLength = 0;
          for (const {
            length
          } of array) {
            if (length > maxLength) {
              maxLength = length;
            }
          }
          return maxLength;
        }
        function createEmptyItem(rowId) {
          return {
            id: "__EMPTY_ITEM__",
            disabled: true,
            rowId
          };
        }
        function normalizeRows(rows, activeId, focusShift) {
          const maxLength = getMaxRowLength(rows);
          for (const row of rows) {
            for (let i = 0; i < maxLength; i += 1) {
              const item = row[i];
              if (!item || focusShift && item.disabled) {
                const isFirst = i === 0;
                const previousItem = isFirst && focusShift ? findFirstEnabledItem$1(row) : row[i - 1];
                row[i] = previousItem && activeId !== previousItem.id && focusShift ? previousItem : createEmptyItem(previousItem == null ? void 0 : previousItem.rowId);
              }
            }
          }
          return rows;
        }
        function verticalizeItems(items) {
          const rows = groupItemsByRows$1(items);
          const maxLength = getMaxRowLength(rows);
          const verticalized = [];
          for (let i = 0; i < maxLength; i += 1) {
            for (const row of rows) {
              const item = row[i];
              if (item) {
                verticalized.push(__spreadProps(__spreadValues({}, item), {
                  // If there's no rowId, it means that it's not a grid composite, but
                  // a single row instead. So, instead of verticalizing it, that is,
                  // assigning a different rowId based on the column index, we keep it
                  // undefined so they will be part of the same row. This is useful
                  // when using up/down on one-dimensional composites.
                  rowId: item.rowId ? `${i}` : void 0
                }));
              }
            }
          }
          return verticalized;
        }
        function createCompositeStore(props = {}) {
          var _a;
          const syncState = (_a = props.store) == null ? void 0 : _a.getState();
          const collection = createCollectionStore(props);
          const activeId = defaultValue$3(props.activeId, syncState == null ? void 0 : syncState.activeId, props.defaultActiveId);
          const initialState = __spreadProps(__spreadValues({}, collection.getState()), {
            id: defaultValue$3(props.id, syncState == null ? void 0 : syncState.id, `id-${Math.random().toString(36).slice(2, 8)}`),
            activeId,
            baseElement: defaultValue$3(syncState == null ? void 0 : syncState.baseElement, null),
            includesBaseElement: defaultValue$3(props.includesBaseElement, syncState == null ? void 0 : syncState.includesBaseElement, activeId === null),
            moves: defaultValue$3(syncState == null ? void 0 : syncState.moves, 0),
            orientation: defaultValue$3(props.orientation, syncState == null ? void 0 : syncState.orientation, "both"),
            rtl: defaultValue$3(props.rtl, syncState == null ? void 0 : syncState.rtl, false),
            virtualFocus: defaultValue$3(props.virtualFocus, syncState == null ? void 0 : syncState.virtualFocus, false),
            focusLoop: defaultValue$3(props.focusLoop, syncState == null ? void 0 : syncState.focusLoop, false),
            focusWrap: defaultValue$3(props.focusWrap, syncState == null ? void 0 : syncState.focusWrap, false),
            focusShift: defaultValue$3(props.focusShift, syncState == null ? void 0 : syncState.focusShift, false)
          });
          const composite = createStore(initialState, collection, props.store);
          setup(composite, () => sync(composite, ["renderedItems", "activeId"], state => {
            composite.setState("activeId", activeId2 => {
              var _a2;
              if (activeId2 !== void 0) return activeId2;
              return (_a2 = findFirstEnabledItem$1(state.renderedItems)) == null ? void 0 : _a2.id;
            });
          }));
          const getNextId = (direction = "next", options = {}) => {
            var _a2, _b;
            const defaultState = composite.getState();
            const {
              skip = 0,
              activeId: activeId2 = defaultState.activeId,
              focusShift = defaultState.focusShift,
              focusLoop = defaultState.focusLoop,
              focusWrap = defaultState.focusWrap,
              includesBaseElement = defaultState.includesBaseElement,
              renderedItems = defaultState.renderedItems,
              rtl = defaultState.rtl
            } = options;
            const isVerticalDirection = direction === "up" || direction === "down";
            const isNextDirection = direction === "next" || direction === "down";
            const canReverse = isNextDirection ? rtl && !isVerticalDirection : !rtl || isVerticalDirection;
            const canShift = focusShift && !skip;
            let items = !isVerticalDirection ? renderedItems : flatten2DArray(normalizeRows(groupItemsByRows$1(renderedItems), activeId2, canShift));
            items = canReverse ? reverseArray(items) : items;
            items = isVerticalDirection ? verticalizeItems(items) : items;
            if (activeId2 == null) {
              return (_a2 = findFirstEnabledItem$1(items)) == null ? void 0 : _a2.id;
            }
            const activeItem = items.find(item => item.id === activeId2);
            if (!activeItem) {
              return (_b = findFirstEnabledItem$1(items)) == null ? void 0 : _b.id;
            }
            const isGrid = items.some(item => item.rowId);
            const activeIndex = items.indexOf(activeItem);
            const nextItems = items.slice(activeIndex + 1);
            const nextItemsInRow = getItemsInRow(nextItems, activeItem.rowId);
            if (skip) {
              const nextEnabledItemsInRow = getEnabledItems(nextItemsInRow, activeId2);
              const nextItem2 = nextEnabledItemsInRow.slice(skip)[0] ||
              // If we can't find an item, just return the last one.
              nextEnabledItemsInRow[nextEnabledItemsInRow.length - 1];
              return nextItem2 == null ? void 0 : nextItem2.id;
            }
            const canLoop = focusLoop && (isVerticalDirection ? focusLoop !== "horizontal" : focusLoop !== "vertical");
            const canWrap = isGrid && focusWrap && (isVerticalDirection ? focusWrap !== "horizontal" : focusWrap !== "vertical");
            const hasNullItem = isNextDirection ? (!isGrid || isVerticalDirection) && canLoop && includesBaseElement : isVerticalDirection ? includesBaseElement : false;
            if (canLoop) {
              const loopItems = canWrap && !hasNullItem ? items : getItemsInRow(items, activeItem.rowId);
              const sortedItems = flipItems(loopItems, activeId2, hasNullItem);
              const nextItem2 = findFirstEnabledItem$1(sortedItems, activeId2);
              return nextItem2 == null ? void 0 : nextItem2.id;
            }
            if (canWrap) {
              const nextItem2 = findFirstEnabledItem$1(
              // We can use nextItems, which contains all the next items, including
              // items from other rows, to wrap between rows. However, if there is a
              // null item (the composite container), we'll only use the next items in
              // the row. So moving next from the last item will focus on the
              // composite container. On grid composites, horizontal navigation never
              // focuses on the composite container, only vertical.
              hasNullItem ? nextItemsInRow : nextItems, activeId2);
              const nextId = hasNullItem ? (nextItem2 == null ? void 0 : nextItem2.id) || null : nextItem2 == null ? void 0 : nextItem2.id;
              return nextId;
            }
            const nextItem = findFirstEnabledItem$1(nextItemsInRow, activeId2);
            if (!nextItem && hasNullItem) {
              return null;
            }
            return nextItem == null ? void 0 : nextItem.id;
          };
          return __spreadProps(__spreadValues(__spreadValues({}, collection), composite), {
            setBaseElement: element => composite.setState("baseElement", element),
            setActiveId: id => composite.setState("activeId", id),
            move: id => {
              if (id === void 0) return;
              composite.setState("activeId", id);
              composite.setState("moves", moves => moves + 1);
            },
            first: () => {
              var _a2;
              return (_a2 = findFirstEnabledItem$1(composite.getState().renderedItems)) == null ? void 0 : _a2.id;
            },
            last: () => {
              var _a2;
              return (_a2 = findFirstEnabledItem$1(reverseArray(composite.getState().renderedItems))) == null ? void 0 : _a2.id;
            },
            next: options => {
              if (options !== void 0 && typeof options === "number") {
                options = {
                  skip: options
                };
              }
              return getNextId("next", options);
            },
            previous: options => {
              if (options !== void 0 && typeof options === "number") {
                options = {
                  skip: options
                };
              }
              return getNextId("previous", options);
            },
            down: options => {
              if (options !== void 0 && typeof options === "number") {
                options = {
                  skip: options
                };
              }
              return getNextId("down", options);
            },
            up: options => {
              if (options !== void 0 && typeof options === "number") {
                options = {
                  skip: options
                };
              }
              return getNextId("up", options);
            }
          });
        }
        function useCompositeStoreProps(store, update, props) {
          store = useCollectionStoreProps(store, update, props);
          useStoreProps(store, props, "activeId", "setActiveId");
          useStoreProps(store, props, "includesBaseElement");
          useStoreProps(store, props, "virtualFocus");
          useStoreProps(store, props, "orientation");
          useStoreProps(store, props, "rtl");
          useStoreProps(store, props, "focusLoop");
          useStoreProps(store, props, "focusWrap");
          useStoreProps(store, props, "focusShift");
          return store;
        }
        reactExports.createContext(void 0);
        var ctx$3 = createStoreContext([PopoverContextProvider, CompositeContextProvider], [PopoverScopedContextProvider, CompositeScopedContextProvider]);
        var useComboboxContext = ctx$3.useContext;
        reactExports.createContext(void 0);
        reactExports.createContext(false);

        // src/tab/tab-store.ts
        function createTabStore(_a = {}) {
          var _b = _a,
            {
              composite: parentComposite,
              combobox
            } = _b,
            props = __objRest(_b, ["composite", "combobox"]);
          const independentKeys = ["items", "renderedItems", "moves", "orientation", "virtualFocus", "includesBaseElement", "baseElement", "focusLoop", "focusShift", "focusWrap"];
          const store = mergeStore(props.store, omit2(parentComposite, independentKeys), omit2(combobox, independentKeys));
          const syncState = store == null ? void 0 : store.getState();
          const composite = createCompositeStore(__spreadProps(__spreadValues({}, props), {
            store,
            // We need to explicitly set the default value of `includesBaseElement` to
            // `false` since we don't want the composite store to default it to `true`
            // when the activeId state is null, which could be the case when rendering
            // combobox with tab.
            includesBaseElement: defaultValue$3(props.includesBaseElement, syncState == null ? void 0 : syncState.includesBaseElement, false),
            orientation: defaultValue$3(props.orientation, syncState == null ? void 0 : syncState.orientation, "horizontal"),
            focusLoop: defaultValue$3(props.focusLoop, syncState == null ? void 0 : syncState.focusLoop, true)
          }));
          const panels = createCollectionStore();
          const initialState = __spreadProps(__spreadValues({}, composite.getState()), {
            selectedId: defaultValue$3(props.selectedId, syncState == null ? void 0 : syncState.selectedId, props.defaultSelectedId),
            selectOnMove: defaultValue$3(props.selectOnMove, syncState == null ? void 0 : syncState.selectOnMove, true)
          });
          const tab = createStore(initialState, composite, store);
          setup(tab, () => sync(tab, ["moves"], () => {
            const {
              activeId,
              selectOnMove
            } = tab.getState();
            if (!selectOnMove) return;
            if (!activeId) return;
            const tabItem = composite.item(activeId);
            if (!tabItem) return;
            if (tabItem.dimmed) return;
            if (tabItem.disabled) return;
            tab.setState("selectedId", tabItem.id);
          }));
          let syncActiveId = true;
          setup(tab, () => batch(tab, ["selectedId"], (state, prev) => {
            if (!syncActiveId) {
              syncActiveId = true;
              return;
            }
            if (parentComposite && state.selectedId === prev.selectedId) return;
            tab.setState("activeId", state.selectedId);
          }));
          setup(tab, () => sync(tab, ["selectedId", "renderedItems"], state => {
            if (state.selectedId !== void 0) return;
            const {
              activeId,
              renderedItems
            } = tab.getState();
            const tabItem = composite.item(activeId);
            if (tabItem && !tabItem.disabled && !tabItem.dimmed) {
              tab.setState("selectedId", tabItem.id);
            } else {
              const tabItem2 = renderedItems.find(item => !item.disabled && !item.dimmed);
              tab.setState("selectedId", tabItem2 == null ? void 0 : tabItem2.id);
            }
          }));
          setup(tab, () => sync(tab, ["renderedItems"], state => {
            const tabs = state.renderedItems;
            if (!tabs.length) return;
            return sync(panels, ["renderedItems"], state2 => {
              const items = state2.renderedItems;
              const hasOrphanPanels = items.some(panel => !panel.tabId);
              if (!hasOrphanPanels) return;
              items.forEach((panel, i) => {
                if (panel.tabId) return;
                const tabItem = tabs[i];
                if (!tabItem) return;
                panels.renderItem(__spreadProps(__spreadValues({}, panel), {
                  tabId: tabItem.id
                }));
              });
            });
          }));
          let selectedIdFromSelectedValue = null;
          setup(tab, () => {
            const backupSelectedId = () => {
              selectedIdFromSelectedValue = tab.getState().selectedId;
            };
            const restoreSelectedId = () => {
              syncActiveId = false;
              tab.setState("selectedId", selectedIdFromSelectedValue);
            };
            if (parentComposite && "setSelectElement" in parentComposite) {
              return chain$1(sync(parentComposite, ["value"], backupSelectedId), sync(parentComposite, ["mounted"], restoreSelectedId));
            }
            if (!combobox) return;
            return chain$1(sync(combobox, ["selectedValue"], backupSelectedId), sync(combobox, ["mounted"], restoreSelectedId));
          });
          return __spreadProps(__spreadValues(__spreadValues({}, composite), tab), {
            panels,
            setSelectedId: id => tab.setState("selectedId", id),
            select: id => {
              tab.setState("selectedId", id);
              composite.move(id);
            }
          });
        }
        function useTabStoreProps(store, update, props) {
          useUpdateEffect$1(update, [props.composite, props.combobox]);
          store = useCompositeStoreProps(store, update, props);
          useStoreProps(store, props, "selectedId", "setSelectedId");
          useStoreProps(store, props, "selectOnMove");
          const [panels, updatePanels] = useStore(() => store.panels, {});
          useUpdateEffect$1(updatePanels, [store, updatePanels]);
          return Object.assign(reactExports.useMemo(() => __spreadProps$1(__spreadValues$1({}, store), {
            panels
          }), [store, panels]), {
            composite: props.composite,
            combobox: props.combobox
          });
        }
        function useTabStore(props = {}) {
          const combobox = useComboboxContext();
          const composite = useSelectContext() || combobox;
          props = __spreadProps$1(__spreadValues$1({}, props), {
            composite: props.composite !== void 0 ? props.composite : composite,
            combobox: props.combobox !== void 0 ? props.combobox : combobox
          });
          const [store, update] = useStore(createTabStore, props);
          return useTabStoreProps(store, update, props);
        }

        // src/tab/tab-context.tsx
        var ctx$2 = createStoreContext([CompositeContextProvider], [CompositeScopedContextProvider]);
        var useTabScopedContext = ctx$2.useScopedContext;
        var useTabProviderContext = ctx$2.useProviderContext;
        var TabScopedContextProvider = ctx$2.ScopedContextProvider;
        function findFirstEnabledItem(items, excludeId) {
          return items.find(item => {
            return !item.disabled;
          });
        }
        function getEnabledItem(store, id) {
          if (!id) return null;
          return store.item(id) || null;
        }
        function groupItemsByRows(items) {
          const rows = [];
          for (const item of items) {
            const row = rows.find(currentRow => {
              var _a;
              return ((_a = currentRow[0]) == null ? void 0 : _a.rowId) === item.rowId;
            });
            if (row) {
              row.push(item);
            } else {
              rows.push([item]);
            }
          }
          return rows;
        }
        function selectTextField(element, collapseToEnd = false) {
          if (isTextField(element)) {
            element.setSelectionRange(collapseToEnd ? element.value.length : 0, element.value.length);
          } else if (element.isContentEditable) {
            const selection = getDocument(element).getSelection();
            selection == null ? void 0 : selection.selectAllChildren(element);
            if (collapseToEnd) {
              selection == null ? void 0 : selection.collapseToEnd();
            }
          }
        }
        var FOCUS_SILENTLY = Symbol("FOCUS_SILENTLY");
        function focusSilently(element) {
          element[FOCUS_SILENTLY] = true;
          element.focus({
            preventScroll: true
          });
        }
        function silentlyFocused(element) {
          const isSilentlyFocused = element[FOCUS_SILENTLY];
          delete element[FOCUS_SILENTLY];
          return isSilentlyFocused;
        }
        function isItem(store, element, exclude) {
          if (!element) return false;
          if (element === exclude) return false;
          const item = store.item(element.id);
          if (!item) return false;
          return true;
        }
        var TagName$k = "div";
        var useCollectionItem = createHook(function useCollectionItem2(_a) {
          var _b = _a,
            {
              store,
              shouldRegisterItem = true,
              getItem = identity$1,
              element: element
            } = _b,
            props = __objRest$1(_b, ["store", "shouldRegisterItem", "getItem",
            // @ts-expect-error This prop may come from a collection renderer.
            "element"]);
          const context = useCollectionContext();
          store = store || context;
          const id = useId(props.id);
          const ref = reactExports.useRef(element);
          reactExports.useEffect(() => {
            const element2 = ref.current;
            if (!id) return;
            if (!element2) return;
            if (!shouldRegisterItem) return;
            const item = getItem({
              id,
              element: element2
            });
            return store == null ? void 0 : store.renderItem(item);
          }, [id, shouldRegisterItem, getItem, store]);
          props = __spreadProps$1(__spreadValues$1({}, props), {
            ref: useMergeRefs(ref, props.ref)
          });
          return removeUndefinedValues(props);
        });
        forwardRef2(function CollectionItem2(props) {
          const htmlProps = useCollectionItem(props);
          return createElement(TagName$k, htmlProps);
        });
        var FocusableContext = reactExports.createContext(true);

        // src/utils/focus.ts
        var selector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], summary, iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
        function hasNegativeTabIndex(element) {
          const tabIndex = Number.parseInt(element.getAttribute("tabindex") || "0", 10);
          return tabIndex < 0;
        }
        function isFocusable(element) {
          if (!element.matches(selector)) return false;
          if (!isVisible(element)) return false;
          if (element.closest("[inert]")) return false;
          return true;
        }
        function isTabbable(element) {
          if (!isFocusable(element)) return false;
          if (hasNegativeTabIndex(element)) return false;
          if (!("form" in element)) return true;
          if (!element.form) return true;
          if (element.checked) return true;
          if (element.type !== "radio") return true;
          const radioGroup = element.form.elements.namedItem(element.name);
          if (!radioGroup) return true;
          if (!("length" in radioGroup)) return true;
          const activeElement = getActiveElement(element);
          if (!activeElement) return true;
          if (activeElement === element) return true;
          if (!("form" in activeElement)) return true;
          if (activeElement.form !== element.form) return true;
          if (activeElement.name !== element.name) return true;
          return false;
        }
        function getAllFocusableIn(container, includeContainer) {
          const elements = Array.from(container.querySelectorAll(selector));
          if (includeContainer) {
            elements.unshift(container);
          }
          const focusableElements = elements.filter(isFocusable);
          focusableElements.forEach((element, i) => {
            if (isFrame(element) && element.contentDocument) {
              const frameBody = element.contentDocument.body;
              focusableElements.splice(i, 1, ...getAllFocusableIn(frameBody));
            }
          });
          return focusableElements;
        }
        function getAllTabbableIn(container, includeContainer, fallbackToFocusable) {
          const elements = Array.from(container.querySelectorAll(selector));
          const tabbableElements = elements.filter(isTabbable);
          if (includeContainer && isTabbable(container)) {
            tabbableElements.unshift(container);
          }
          tabbableElements.forEach((element, i) => {
            if (isFrame(element) && element.contentDocument) {
              const frameBody = element.contentDocument.body;
              const allFrameTabbable = getAllTabbableIn(frameBody, false, fallbackToFocusable);
              tabbableElements.splice(i, 1, ...allFrameTabbable);
            }
          });
          if (!tabbableElements.length && fallbackToFocusable) {
            return elements;
          }
          return tabbableElements;
        }
        function getFirstTabbableIn(container, includeContainer, fallbackToFocusable) {
          const [first] = getAllTabbableIn(container, includeContainer, fallbackToFocusable);
          return first || null;
        }
        function getNextTabbableIn(container, includeContainer, fallbackToFirst, fallbackToFocusable) {
          const activeElement = getActiveElement(container);
          const allFocusable = getAllFocusableIn(container, includeContainer);
          const activeIndex = allFocusable.indexOf(activeElement);
          const nextFocusableElements = allFocusable.slice(activeIndex + 1);
          return nextFocusableElements.find(isTabbable) || (fallbackToFirst ? allFocusable.find(isTabbable) : null) || (fallbackToFocusable ? nextFocusableElements[0] : null) || null;
        }
        function getNextTabbable(fallbackToFirst, fallbackToFocusable) {
          return getNextTabbableIn(document.body, false, fallbackToFirst, fallbackToFocusable);
        }
        function getPreviousTabbableIn(container, includeContainer, fallbackToLast, fallbackToFocusable) {
          const activeElement = getActiveElement(container);
          const allFocusable = getAllFocusableIn(container, includeContainer).reverse();
          const activeIndex = allFocusable.indexOf(activeElement);
          const previousFocusableElements = allFocusable.slice(activeIndex + 1);
          return previousFocusableElements.find(isTabbable) || null || null || null;
        }
        function getPreviousTabbable(fallbackToFirst, fallbackToFocusable) {
          return getPreviousTabbableIn(document.body, false);
        }
        function getClosestFocusable(element) {
          while (element && !isFocusable(element)) {
            element = element.closest(selector);
          }
          return element || null;
        }
        function hasFocus(element) {
          const activeElement = getActiveElement(element);
          if (!activeElement) return false;
          if (activeElement === element) return true;
          const activeDescendant = activeElement.getAttribute("aria-activedescendant");
          if (!activeDescendant) return false;
          return activeDescendant === element.id;
        }
        function hasFocusWithin(element) {
          const activeElement = getActiveElement(element);
          if (!activeElement) return false;
          if (contains(element, activeElement)) return true;
          const activeDescendant = activeElement.getAttribute("aria-activedescendant");
          if (!activeDescendant) return false;
          if (!("id" in element)) return false;
          if (activeDescendant === element.id) return true;
          return !!element.querySelector(`#${CSS.escape(activeDescendant)}`);
        }
        function focusIfNeeded(element) {
          if (!hasFocusWithin(element) && isFocusable(element)) {
            element.focus();
          }
        }
        function disableFocus(element) {
          var _a;
          const currentTabindex = (_a = element.getAttribute("tabindex")) != null ? _a : "";
          element.setAttribute("data-tabindex", currentTabindex);
          element.setAttribute("tabindex", "-1");
        }
        function disableFocusIn(container, includeContainer) {
          const tabbableElements = getAllTabbableIn(container, includeContainer);
          for (const element of tabbableElements) {
            disableFocus(element);
          }
        }
        function restoreFocusIn(container) {
          const elements = container.querySelectorAll("[data-tabindex]");
          const restoreTabIndex = element => {
            const tabindex = element.getAttribute("data-tabindex");
            element.removeAttribute("data-tabindex");
            if (tabindex) {
              element.setAttribute("tabindex", tabindex);
            } else {
              element.removeAttribute("tabindex");
            }
          };
          if (container.hasAttribute("data-tabindex")) {
            restoreTabIndex(container);
          }
          for (const element of elements) {
            restoreTabIndex(element);
          }
        }
        function focusIntoView(element, options) {
          if (!("scrollIntoView" in element)) {
            element.focus();
          } else {
            element.focus({
              preventScroll: true
            });
            element.scrollIntoView(__spreadValues({
              block: "nearest",
              inline: "nearest"
            }, options));
          }
        }
        var TagName$j = "div";
        var isSafariBrowser$1 = isSafari();
        var alwaysFocusVisibleInputTypes = ["text", "search", "url", "tel", "email", "password", "number", "date", "month", "week", "time", "datetime", "datetime-local"];
        var safariFocusAncestorSymbol = Symbol("safariFocusAncestor");
        function isSafariFocusAncestor(element) {
          if (!element) return false;
          return !!element[safariFocusAncestorSymbol];
        }
        function markSafariFocusAncestor(element, value) {
          if (!element) return;
          element[safariFocusAncestorSymbol] = value;
        }
        function isAlwaysFocusVisible(element) {
          const {
            tagName,
            readOnly,
            type
          } = element;
          if (tagName === "TEXTAREA" && !readOnly) return true;
          if (tagName === "SELECT" && !readOnly) return true;
          if (tagName === "INPUT" && !readOnly) {
            return alwaysFocusVisibleInputTypes.includes(type);
          }
          if (element.isContentEditable) return true;
          const role = element.getAttribute("role");
          if (role === "combobox" && element.dataset.name) {
            return true;
          }
          return false;
        }
        function getLabels(element) {
          if ("labels" in element) {
            return element.labels;
          }
          return null;
        }
        function isNativeCheckboxOrRadio(element) {
          const tagName = element.tagName.toLowerCase();
          if (tagName === "input" && element.type) {
            return element.type === "radio" || element.type === "checkbox";
          }
          return false;
        }
        function isNativeTabbable(tagName) {
          if (!tagName) return true;
          return tagName === "button" || tagName === "summary" || tagName === "input" || tagName === "select" || tagName === "textarea" || tagName === "a";
        }
        function supportsDisabledAttribute(tagName) {
          if (!tagName) return true;
          return tagName === "button" || tagName === "input" || tagName === "select" || tagName === "textarea";
        }
        function getTabIndex(focusable, trulyDisabled, nativeTabbable, supportsDisabled, tabIndexProp) {
          if (!focusable) {
            return tabIndexProp;
          }
          if (trulyDisabled) {
            if (nativeTabbable && !supportsDisabled) {
              return -1;
            }
            return;
          }
          if (nativeTabbable) {
            return tabIndexProp;
          }
          return tabIndexProp || 0;
        }
        function useDisableEvent(onEvent, disabled) {
          return useEvent$1(event => {
            onEvent == null ? void 0 : onEvent(event);
            if (event.defaultPrevented) return;
            if (disabled) {
              event.stopPropagation();
              event.preventDefault();
            }
          });
        }
        var isKeyboardModality = true;
        function onGlobalMouseDown(event) {
          const target = event.target;
          if (target && "hasAttribute" in target) {
            if (!target.hasAttribute("data-focus-visible")) {
              isKeyboardModality = false;
            }
          }
        }
        function onGlobalKeyDown(event) {
          if (event.metaKey) return;
          if (event.ctrlKey) return;
          if (event.altKey) return;
          isKeyboardModality = true;
        }
        var useFocusable = createHook(function useFocusable2(_a) {
          var _b = _a,
            {
              focusable = true,
              accessibleWhenDisabled,
              autoFocus,
              onFocusVisible
            } = _b,
            props = __objRest$1(_b, ["focusable", "accessibleWhenDisabled", "autoFocus", "onFocusVisible"]);
          const ref = reactExports.useRef(null);
          reactExports.useEffect(() => {
            if (!focusable) return;
            addGlobalEventListener("mousedown", onGlobalMouseDown, true);
            addGlobalEventListener("keydown", onGlobalKeyDown, true);
          }, [focusable]);
          if (isSafariBrowser$1) {
            reactExports.useEffect(() => {
              if (!focusable) return;
              const element = ref.current;
              if (!element) return;
              if (!isNativeCheckboxOrRadio(element)) return;
              const labels = getLabels(element);
              if (!labels) return;
              const onMouseUp = () => queueMicrotask(() => element.focus());
              for (const label of labels) {
                label.addEventListener("mouseup", onMouseUp);
              }
              return () => {
                for (const label of labels) {
                  label.removeEventListener("mouseup", onMouseUp);
                }
              };
            }, [focusable]);
          }
          const disabled = focusable && disabledFromProps(props);
          const trulyDisabled = !!disabled && !accessibleWhenDisabled;
          const [focusVisible, setFocusVisible] = reactExports.useState(false);
          reactExports.useEffect(() => {
            if (!focusable) return;
            if (trulyDisabled && focusVisible) {
              setFocusVisible(false);
            }
          }, [focusable, trulyDisabled, focusVisible]);
          reactExports.useEffect(() => {
            if (!focusable) return;
            if (!focusVisible) return;
            const element = ref.current;
            if (!element) return;
            if (typeof IntersectionObserver === "undefined") return;
            const observer = new IntersectionObserver(() => {
              if (!isFocusable(element)) {
                setFocusVisible(false);
              }
            });
            observer.observe(element);
            return () => observer.disconnect();
          }, [focusable, focusVisible]);
          const onKeyPressCapture = useDisableEvent(props.onKeyPressCapture, disabled);
          const onMouseDownCapture = useDisableEvent(props.onMouseDownCapture, disabled);
          const onClickCapture = useDisableEvent(props.onClickCapture, disabled);
          const onMouseDownProp = props.onMouseDown;
          const onMouseDown = useEvent$1(event => {
            onMouseDownProp == null ? void 0 : onMouseDownProp(event);
            if (event.defaultPrevented) return;
            if (!focusable) return;
            const element = event.currentTarget;
            if (!isSafariBrowser$1) return;
            if (isPortalEvent(event)) return;
            if (!isButton(element) && !isNativeCheckboxOrRadio(element)) return;
            let receivedFocus = false;
            const onFocus = () => {
              receivedFocus = true;
            };
            const options = {
              capture: true,
              once: true
            };
            element.addEventListener("focusin", onFocus, options);
            const focusableContainer = getClosestFocusable(element.parentElement);
            markSafariFocusAncestor(focusableContainer, true);
            queueBeforeEvent(element, "mouseup", () => {
              element.removeEventListener("focusin", onFocus, true);
              markSafariFocusAncestor(focusableContainer, false);
              if (receivedFocus) return;
              focusIfNeeded(element);
            });
          });
          const handleFocusVisible = (event, currentTarget) => {
            if (currentTarget) {
              event.currentTarget = currentTarget;
            }
            if (!focusable) return;
            const element = event.currentTarget;
            if (!element) return;
            if (!hasFocus(element)) return;
            onFocusVisible == null ? void 0 : onFocusVisible(event);
            if (event.defaultPrevented) return;
            element.dataset.focusVisible = "true";
            setFocusVisible(true);
          };
          const onKeyDownCaptureProp = props.onKeyDownCapture;
          const onKeyDownCapture = useEvent$1(event => {
            onKeyDownCaptureProp == null ? void 0 : onKeyDownCaptureProp(event);
            if (event.defaultPrevented) return;
            if (!focusable) return;
            if (focusVisible) return;
            if (event.metaKey) return;
            if (event.altKey) return;
            if (event.ctrlKey) return;
            if (!isSelfTarget(event)) return;
            const element = event.currentTarget;
            const applyFocusVisible = () => handleFocusVisible(event, element);
            queueBeforeEvent(element, "focusout", applyFocusVisible);
          });
          const onFocusCaptureProp = props.onFocusCapture;
          const onFocusCapture = useEvent$1(event => {
            onFocusCaptureProp == null ? void 0 : onFocusCaptureProp(event);
            if (event.defaultPrevented) return;
            if (!focusable) return;
            if (!isSelfTarget(event)) {
              setFocusVisible(false);
              return;
            }
            const element = event.currentTarget;
            const applyFocusVisible = () => handleFocusVisible(event, element);
            if (isKeyboardModality || isAlwaysFocusVisible(event.target)) {
              queueBeforeEvent(event.target, "focusout", applyFocusVisible);
            } else {
              setFocusVisible(false);
            }
          });
          const onBlurProp = props.onBlur;
          const onBlur = useEvent$1(event => {
            onBlurProp == null ? void 0 : onBlurProp(event);
            if (!focusable) return;
            if (!isFocusEventOutside(event)) return;
            event.currentTarget.removeAttribute("data-focus-visible");
            setFocusVisible(false);
          });
          const autoFocusOnShow = reactExports.useContext(FocusableContext);
          const autoFocusRef = useEvent$1(element => {
            if (!focusable) return;
            if (!autoFocus) return;
            if (!element) return;
            if (!autoFocusOnShow) return;
            queueMicrotask(() => {
              if (hasFocus(element)) return;
              if (!isFocusable(element)) return;
              element.focus();
            });
          });
          const tagName = useTagName(ref);
          const nativeTabbable = focusable && isNativeTabbable(tagName);
          const supportsDisabled = focusable && supportsDisabledAttribute(tagName);
          const styleProp = props.style;
          const style = reactExports.useMemo(() => {
            if (trulyDisabled) {
              return __spreadValues$1({
                pointerEvents: "none"
              }, styleProp);
            }
            return styleProp;
          }, [trulyDisabled, styleProp]);
          props = __spreadProps$1(__spreadValues$1({
            "data-focus-visible": focusable && focusVisible || void 0,
            "data-autofocus": autoFocus || void 0,
            "aria-disabled": disabled || void 0
          }, props), {
            ref: useMergeRefs(ref, autoFocusRef, props.ref),
            style,
            tabIndex: getTabIndex(focusable, trulyDisabled, nativeTabbable, supportsDisabled, props.tabIndex),
            disabled: supportsDisabled && trulyDisabled ? true : void 0,
            // TODO: Test Focusable contentEditable.
            contentEditable: disabled ? void 0 : props.contentEditable,
            onKeyPressCapture,
            onClickCapture,
            onMouseDownCapture,
            onMouseDown,
            onKeyDownCapture,
            onFocusCapture,
            onBlur
          });
          return removeUndefinedValues(props);
        });
        forwardRef2(function Focusable2(props) {
          const htmlProps = useFocusable(props);
          return createElement(TagName$j, htmlProps);
        });
        var TagName$i = "button";
        function isNativeClick(event) {
          if (!event.isTrusted) return false;
          const element = event.currentTarget;
          if (event.key === "Enter") {
            return isButton(element) || element.tagName === "SUMMARY" || element.tagName === "A";
          }
          if (event.key === " ") {
            return isButton(element) || element.tagName === "SUMMARY" || element.tagName === "INPUT" || element.tagName === "SELECT";
          }
          return false;
        }
        var symbol = Symbol("command");
        var useCommand = createHook(function useCommand2(_a) {
          var _b = _a,
            {
              clickOnEnter = true,
              clickOnSpace = true
            } = _b,
            props = __objRest$1(_b, ["clickOnEnter", "clickOnSpace"]);
          const ref = reactExports.useRef(null);
          const [isNativeButton, setIsNativeButton] = reactExports.useState(false);
          reactExports.useEffect(() => {
            if (!ref.current) return;
            setIsNativeButton(isButton(ref.current));
          }, []);
          const [active, setActive] = reactExports.useState(false);
          const activeRef = reactExports.useRef(false);
          const disabled = disabledFromProps(props);
          const [isDuplicate, metadataProps] = useMetadataProps(props, symbol, true);
          const onKeyDownProp = props.onKeyDown;
          const onKeyDown = useEvent$1(event => {
            onKeyDownProp == null ? void 0 : onKeyDownProp(event);
            const element = event.currentTarget;
            if (event.defaultPrevented) return;
            if (isDuplicate) return;
            if (disabled) return;
            if (!isSelfTarget(event)) return;
            if (isTextField(element)) return;
            if (element.isContentEditable) return;
            const isEnter = clickOnEnter && event.key === "Enter";
            const isSpace = clickOnSpace && event.key === " ";
            const shouldPreventEnter = event.key === "Enter" && !clickOnEnter;
            const shouldPreventSpace = event.key === " " && !clickOnSpace;
            if (shouldPreventEnter || shouldPreventSpace) {
              event.preventDefault();
              return;
            }
            if (isEnter || isSpace) {
              const nativeClick = isNativeClick(event);
              if (isEnter) {
                if (!nativeClick) {
                  event.preventDefault();
                  const _a2 = event,
                    {
                      view
                    } = _a2,
                    eventInit = __objRest$1(_a2, ["view"]);
                  const click = () => fireClickEvent(element, eventInit);
                  if (isFirefox()) {
                    queueBeforeEvent(element, "keyup", click);
                  } else {
                    queueMicrotask(click);
                  }
                }
              } else if (isSpace) {
                activeRef.current = true;
                if (!nativeClick) {
                  event.preventDefault();
                  setActive(true);
                }
              }
            }
          });
          const onKeyUpProp = props.onKeyUp;
          const onKeyUp = useEvent$1(event => {
            onKeyUpProp == null ? void 0 : onKeyUpProp(event);
            if (event.defaultPrevented) return;
            if (isDuplicate) return;
            if (disabled) return;
            if (event.metaKey) return;
            const isSpace = clickOnSpace && event.key === " ";
            if (activeRef.current && isSpace) {
              activeRef.current = false;
              if (!isNativeClick(event)) {
                event.preventDefault();
                setActive(false);
                const element = event.currentTarget;
                const _a2 = event,
                  {
                    view
                  } = _a2,
                  eventInit = __objRest$1(_a2, ["view"]);
                queueMicrotask(() => fireClickEvent(element, eventInit));
              }
            }
          });
          props = __spreadProps$1(__spreadValues$1(__spreadValues$1({
            "data-active": active || void 0,
            type: isNativeButton ? "button" : void 0
          }, metadataProps), props), {
            ref: useMergeRefs(ref, props.ref),
            onKeyDown,
            onKeyUp
          });
          props = useFocusable(props);
          return props;
        });
        forwardRef2(function Command2(props) {
          const htmlProps = useCommand(props);
          return createElement(TagName$i, htmlProps);
        });
        var TagName$h = "button";
        function isEditableElement(element) {
          if (isTextbox(element)) return true;
          return element.tagName === "INPUT" && !isButton(element);
        }
        function getNextPageOffset(scrollingElement, pageUp = false) {
          const height = scrollingElement.clientHeight;
          const {
            top
          } = scrollingElement.getBoundingClientRect();
          const pageSize = Math.max(height * 0.875, height - 40) * 1.5;
          const pageOffset = pageUp ? height - pageSize + top : pageSize + top;
          if (scrollingElement.tagName === "HTML") {
            return pageOffset + scrollingElement.scrollTop;
          }
          return pageOffset;
        }
        function getItemOffset(itemElement, pageUp = false) {
          const {
            top
          } = itemElement.getBoundingClientRect();
          if (pageUp) {
            return top + itemElement.clientHeight;
          }
          return top;
        }
        function findNextPageItemId(element, store, next, pageUp = false) {
          var _a;
          if (!store) return;
          if (!next) return;
          const {
            renderedItems
          } = store.getState();
          const scrollingElement = getScrollingElement(element);
          if (!scrollingElement) return;
          const nextPageOffset = getNextPageOffset(scrollingElement, pageUp);
          let id;
          let prevDifference;
          for (let i = 0; i < renderedItems.length; i += 1) {
            const previousId = id;
            id = next(i);
            if (!id) break;
            if (id === previousId) continue;
            const itemElement = (_a = getEnabledItem(store, id)) == null ? void 0 : _a.element;
            if (!itemElement) continue;
            const itemOffset = getItemOffset(itemElement, pageUp);
            const difference = itemOffset - nextPageOffset;
            const absDifference = Math.abs(difference);
            if (pageUp && difference <= 0 || !pageUp && difference >= 0) {
              if (prevDifference !== void 0 && prevDifference < absDifference) {
                id = previousId;
              }
              break;
            }
            prevDifference = absDifference;
          }
          return id;
        }
        function targetIsAnotherItem(event, store) {
          if (isSelfTarget(event)) return false;
          return isItem(store, event.target);
        }
        var useCompositeItem = createHook(function useCompositeItem2(_a) {
          var _b = _a,
            {
              store,
              rowId: rowIdProp,
              preventScrollOnKeyDown = false,
              moveOnKeyPress = true,
              tabbable = false,
              getItem: getItemProp,
              "aria-setsize": ariaSetSizeProp,
              "aria-posinset": ariaPosInSetProp
            } = _b,
            props = __objRest$1(_b, ["store", "rowId", "preventScrollOnKeyDown", "moveOnKeyPress", "tabbable", "getItem", "aria-setsize", "aria-posinset"]);
          const context = useCompositeContext();
          store = store || context;
          const id = useId(props.id);
          const ref = reactExports.useRef(null);
          const row = reactExports.useContext(CompositeRowContext);
          const disabled = disabledFromProps(props);
          const trulyDisabled = disabled && !props.accessibleWhenDisabled;
          const {
            rowId,
            baseElement,
            isActiveItem,
            ariaSetSize,
            ariaPosInSet,
            isTabbable
          } = useStoreStateObject(store, {
            rowId(state) {
              if (rowIdProp) return rowIdProp;
              if (!state) return;
              if (!(row == null ? void 0 : row.baseElement)) return;
              if (row.baseElement !== state.baseElement) return;
              return row.id;
            },
            baseElement(state) {
              return (state == null ? void 0 : state.baseElement) || void 0;
            },
            isActiveItem(state) {
              return !!state && state.activeId === id;
            },
            ariaSetSize(state) {
              if (ariaSetSizeProp != null) return ariaSetSizeProp;
              if (!state) return;
              if (!(row == null ? void 0 : row.ariaSetSize)) return;
              if (row.baseElement !== state.baseElement) return;
              return row.ariaSetSize;
            },
            ariaPosInSet(state) {
              if (ariaPosInSetProp != null) return ariaPosInSetProp;
              if (!state) return;
              if (!(row == null ? void 0 : row.ariaPosInSet)) return;
              if (row.baseElement !== state.baseElement) return;
              const itemsInRow = state.renderedItems.filter(item => item.rowId === rowId);
              return row.ariaPosInSet + itemsInRow.findIndex(item => item.id === id);
            },
            isTabbable(state) {
              if (!(state == null ? void 0 : state.renderedItems.length)) return true;
              if (state.virtualFocus) return false;
              if (tabbable) return true;
              if (state.activeId === null) return false;
              const item = store == null ? void 0 : store.item(state.activeId);
              if (item == null ? void 0 : item.disabled) return true;
              if (!(item == null ? void 0 : item.element)) return true;
              return state.activeId === id;
            }
          });
          const getItem = reactExports.useCallback(item => {
            var _a2;
            const nextItem = __spreadProps$1(__spreadValues$1({}, item), {
              id: id || item.id,
              rowId,
              disabled: !!trulyDisabled,
              children: (_a2 = item.element) == null ? void 0 : _a2.textContent
            });
            if (getItemProp) {
              return getItemProp(nextItem);
            }
            return nextItem;
          }, [id, rowId, trulyDisabled, getItemProp]);
          const onFocusProp = props.onFocus;
          const hasFocusedComposite = reactExports.useRef(false);
          const onFocus = useEvent$1(event => {
            onFocusProp == null ? void 0 : onFocusProp(event);
            if (event.defaultPrevented) return;
            if (isPortalEvent(event)) return;
            if (!id) return;
            if (!store) return;
            if (targetIsAnotherItem(event, store)) return;
            const {
              virtualFocus,
              baseElement: baseElement2
            } = store.getState();
            store.setActiveId(id);
            if (isTextbox(event.currentTarget)) {
              selectTextField(event.currentTarget);
            }
            if (!virtualFocus) return;
            if (!isSelfTarget(event)) return;
            if (isEditableElement(event.currentTarget)) return;
            if (!(baseElement2 == null ? void 0 : baseElement2.isConnected)) return;
            if (isSafari() && event.currentTarget.hasAttribute("data-autofocus")) {
              event.currentTarget.scrollIntoView({
                block: "nearest",
                inline: "nearest"
              });
            }
            hasFocusedComposite.current = true;
            const fromComposite = event.relatedTarget === baseElement2 || isItem(store, event.relatedTarget);
            if (fromComposite) {
              focusSilently(baseElement2);
            } else {
              baseElement2.focus();
            }
          });
          const onBlurCaptureProp = props.onBlurCapture;
          const onBlurCapture = useEvent$1(event => {
            onBlurCaptureProp == null ? void 0 : onBlurCaptureProp(event);
            if (event.defaultPrevented) return;
            const state = store == null ? void 0 : store.getState();
            if ((state == null ? void 0 : state.virtualFocus) && hasFocusedComposite.current) {
              hasFocusedComposite.current = false;
              event.preventDefault();
              event.stopPropagation();
            }
          });
          const onKeyDownProp = props.onKeyDown;
          const preventScrollOnKeyDownProp = useBooleanEvent(preventScrollOnKeyDown);
          const moveOnKeyPressProp = useBooleanEvent(moveOnKeyPress);
          const onKeyDown = useEvent$1(event => {
            onKeyDownProp == null ? void 0 : onKeyDownProp(event);
            if (event.defaultPrevented) return;
            if (!isSelfTarget(event)) return;
            if (!store) return;
            const {
              currentTarget
            } = event;
            const state = store.getState();
            const item = store.item(id);
            const isGrid = !!(item == null ? void 0 : item.rowId);
            const isVertical = state.orientation !== "horizontal";
            const isHorizontal = state.orientation !== "vertical";
            const canHomeEnd = () => {
              if (isGrid) return true;
              if (isHorizontal) return true;
              if (!state.baseElement) return true;
              if (!isTextField(state.baseElement)) return true;
              return false;
            };
            const keyMap = {
              ArrowUp: (isGrid || isVertical) && store.up,
              ArrowRight: (isGrid || isHorizontal) && store.next,
              ArrowDown: (isGrid || isVertical) && store.down,
              ArrowLeft: (isGrid || isHorizontal) && store.previous,
              Home: () => {
                if (!canHomeEnd()) return;
                if (!isGrid || event.ctrlKey) {
                  return store == null ? void 0 : store.first();
                }
                return store == null ? void 0 : store.previous(-1);
              },
              End: () => {
                if (!canHomeEnd()) return;
                if (!isGrid || event.ctrlKey) {
                  return store == null ? void 0 : store.last();
                }
                return store == null ? void 0 : store.next(-1);
              },
              PageUp: () => {
                return findNextPageItemId(currentTarget, store, store == null ? void 0 : store.up, true);
              },
              PageDown: () => {
                return findNextPageItemId(currentTarget, store, store == null ? void 0 : store.down);
              }
            };
            const action = keyMap[event.key];
            if (action) {
              if (isTextbox(currentTarget)) {
                const selection = getTextboxSelection(currentTarget);
                const isLeft = isHorizontal && event.key === "ArrowLeft";
                const isRight = isHorizontal && event.key === "ArrowRight";
                const isUp = isVertical && event.key === "ArrowUp";
                const isDown = isVertical && event.key === "ArrowDown";
                if (isRight || isDown) {
                  const {
                    length: valueLength
                  } = getTextboxValue(currentTarget);
                  if (selection.end !== valueLength) return;
                } else if ((isLeft || isUp) && selection.start !== 0) return;
              }
              const nextId = action();
              if (preventScrollOnKeyDownProp(event) || nextId !== void 0) {
                if (!moveOnKeyPressProp(event)) return;
                event.preventDefault();
                store.move(nextId);
              }
            }
          });
          const providerValue = reactExports.useMemo(() => ({
            id,
            baseElement
          }), [id, baseElement]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(CompositeItemContext.Provider, {
            value: providerValue,
            children: element
          }), [providerValue]);
          props = __spreadProps$1(__spreadValues$1({
            id,
            "data-active-item": isActiveItem || void 0
          }, props), {
            ref: useMergeRefs(ref, props.ref),
            tabIndex: isTabbable ? props.tabIndex : -1,
            onFocus,
            onBlurCapture,
            onKeyDown
          });
          props = useCommand(props);
          props = useCollectionItem(__spreadProps$1(__spreadValues$1({
            store
          }, props), {
            getItem,
            shouldRegisterItem: id ? props.shouldRegisterItem : false
          }));
          return removeUndefinedValues(__spreadProps$1(__spreadValues$1({}, props), {
            "aria-setsize": ariaSetSize,
            "aria-posinset": ariaPosInSet
          }));
        });
        var CompositeItem = memo2(forwardRef2(function CompositeItem2(props) {
          const htmlProps = useCompositeItem(props);
          return createElement(TagName$h, htmlProps);
        }));
        var TagName$g = "button";
        var useTab = createHook(function useTab2(_a) {
          var _b = _a,
            {
              store,
              getItem: getItemProp
            } = _b,
            props = __objRest$1(_b, ["store", "getItem"]);
          var _a2;
          const context = useTabScopedContext();
          store = store || context;
          invariant(store, false);
          const defaultId = useId();
          const id = props.id || defaultId;
          const dimmed = disabledFromProps(props);
          const getItem = reactExports.useCallback(item => {
            const nextItem = __spreadProps$1(__spreadValues$1({}, item), {
              dimmed
            });
            if (getItemProp) {
              return getItemProp(nextItem);
            }
            return nextItem;
          }, [dimmed, getItemProp]);
          const onClickProp = props.onClick;
          const onClick = useEvent$1(event => {
            onClickProp == null ? void 0 : onClickProp(event);
            if (event.defaultPrevented) return;
            store == null ? void 0 : store.setSelectedId(id);
          });
          const panelId = store.panels.useState(state => {
            var _a3;
            return (_a3 = state.items.find(item => item.tabId === id)) == null ? void 0 : _a3.id;
          });
          const shouldRegisterItem = defaultId ? props.shouldRegisterItem : false;
          const isActive = store.useState(state => !!id && state.activeId === id);
          const selected = store.useState(state => !!id && state.selectedId === id);
          const hasActiveItem = store.useState(state => !!store.item(state.activeId));
          const canRegisterComposedItem = isActive || selected && !hasActiveItem;
          const accessibleWhenDisabled = selected || ((_a2 = props.accessibleWhenDisabled) != null ? _a2 : true);
          const isWithinVirtualFocusComposite = useStoreState(store.combobox || store.composite, "virtualFocus");
          if (isWithinVirtualFocusComposite) {
            props = __spreadProps$1(__spreadValues$1({}, props), {
              tabIndex: -1
            });
          }
          props = __spreadProps$1(__spreadValues$1({
            id,
            role: "tab",
            "aria-selected": selected,
            "aria-controls": panelId || void 0
          }, props), {
            onClick
          });
          if (store.composite) {
            const defaultProps = {
              id,
              accessibleWhenDisabled,
              store: store.composite,
              shouldRegisterItem: canRegisterComposedItem && shouldRegisterItem,
              rowId: props.rowId,
              render: props.render
            };
            props = __spreadProps$1(__spreadValues$1({}, props), {
              render: /* @__PURE__ */jsxRuntimeExports.jsx(CompositeItem, __spreadProps$1(__spreadValues$1({}, defaultProps), {
                render: store.combobox && store.composite !== store.combobox ? /* @__PURE__ */jsxRuntimeExports.jsx(CompositeItem, __spreadProps$1(__spreadValues$1({}, defaultProps), {
                  store: store.combobox
                })) : defaultProps.render
              }))
            });
          }
          props = useCompositeItem(__spreadProps$1(__spreadValues$1({
            store
          }, props), {
            accessibleWhenDisabled,
            getItem,
            shouldRegisterItem
          }));
          return props;
        });
        var Tab = memo2(forwardRef2(function Tab2(props) {
          const htmlProps = useTab(props);
          return createElement(TagName$g, htmlProps);
        }));
        var TagName$f = "div";
        function isGrid(items) {
          return items.some(item => !!item.rowId);
        }
        function isPrintableKey(event) {
          const target = event.target;
          if (target && !isTextField(target)) return false;
          return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
        }
        function isModifierKey(event) {
          return event.key === "Shift" || event.key === "Control" || event.key === "Alt" || event.key === "Meta";
        }
        function useKeyboardEventProxy(store, onKeyboardEvent, previousElementRef) {
          return useEvent$1(event => {
            var _a;
            onKeyboardEvent == null ? void 0 : onKeyboardEvent(event);
            if (event.defaultPrevented) return;
            if (event.isPropagationStopped()) return;
            if (!isSelfTarget(event)) return;
            if (isModifierKey(event)) return;
            if (isPrintableKey(event)) return;
            const state = store.getState();
            const activeElement = (_a = getEnabledItem(store, state.activeId)) == null ? void 0 : _a.element;
            if (!activeElement) return;
            const _b = event,
              {
                view
              } = _b,
              eventInit = __objRest$1(_b, ["view"]);
            const previousElement = previousElementRef == null ? void 0 : previousElementRef.current;
            if (activeElement !== previousElement) {
              activeElement.focus();
            }
            if (!fireKeyboardEvent(activeElement, event.type, eventInit)) {
              event.preventDefault();
            }
            if (event.currentTarget.contains(activeElement)) {
              event.stopPropagation();
            }
          });
        }
        function findFirstEnabledItemInTheLastRow(items) {
          return findFirstEnabledItem(flatten2DArray(reverseArray(groupItemsByRows(items))));
        }
        function useScheduleFocus(store) {
          const [scheduled, setScheduled] = reactExports.useState(false);
          const schedule = reactExports.useCallback(() => setScheduled(true), []);
          const activeItem = store.useState(state => getEnabledItem(store, state.activeId));
          reactExports.useEffect(() => {
            const activeElement = activeItem == null ? void 0 : activeItem.element;
            if (!scheduled) return;
            if (!activeElement) return;
            setScheduled(false);
            activeElement.focus({
              preventScroll: true
            });
          }, [activeItem, scheduled]);
          return schedule;
        }
        var useComposite = createHook(function useComposite2(_a) {
          var _b = _a,
            {
              store,
              composite = true,
              focusOnMove = composite,
              moveOnKeyPress = true
            } = _b,
            props = __objRest$1(_b, ["store", "composite", "focusOnMove", "moveOnKeyPress"]);
          const context = useCompositeProviderContext();
          store = store || context;
          invariant(store, false);
          const ref = reactExports.useRef(null);
          const previousElementRef = reactExports.useRef(null);
          const scheduleFocus = useScheduleFocus(store);
          const moves = store.useState("moves");
          const [, setBaseElement] = useTransactionState(composite ? store.setBaseElement : null);
          reactExports.useEffect(() => {
            var _a2;
            if (!store) return;
            if (!moves) return;
            if (!composite) return;
            if (!focusOnMove) return;
            const {
              activeId: activeId2
            } = store.getState();
            const itemElement = (_a2 = getEnabledItem(store, activeId2)) == null ? void 0 : _a2.element;
            if (!itemElement) return;
            focusIntoView(itemElement);
          }, [store, moves, composite, focusOnMove]);
          useSafeLayoutEffect(() => {
            if (!store) return;
            if (!moves) return;
            if (!composite) return;
            const {
              baseElement,
              activeId: activeId2
            } = store.getState();
            const isSelfAcive = activeId2 === null;
            if (!isSelfAcive) return;
            if (!baseElement) return;
            const previousElement = previousElementRef.current;
            previousElementRef.current = null;
            if (previousElement) {
              fireBlurEvent(previousElement, {
                relatedTarget: baseElement
              });
            }
            if (!hasFocus(baseElement)) {
              baseElement.focus();
            }
          }, [store, moves, composite]);
          const activeId = store.useState("activeId");
          const virtualFocus = store.useState("virtualFocus");
          useSafeLayoutEffect(() => {
            var _a2;
            if (!store) return;
            if (!composite) return;
            if (!virtualFocus) return;
            const previousElement = previousElementRef.current;
            previousElementRef.current = null;
            if (!previousElement) return;
            const activeElement = (_a2 = getEnabledItem(store, activeId)) == null ? void 0 : _a2.element;
            const relatedTarget = activeElement || getActiveElement(previousElement);
            if (relatedTarget === previousElement) return;
            fireBlurEvent(previousElement, {
              relatedTarget
            });
          }, [store, activeId, virtualFocus, composite]);
          const onKeyDownCapture = useKeyboardEventProxy(store, props.onKeyDownCapture, previousElementRef);
          const onKeyUpCapture = useKeyboardEventProxy(store, props.onKeyUpCapture, previousElementRef);
          const onFocusCaptureProp = props.onFocusCapture;
          const onFocusCapture = useEvent$1(event => {
            onFocusCaptureProp == null ? void 0 : onFocusCaptureProp(event);
            if (event.defaultPrevented) return;
            if (!store) return;
            const {
              virtualFocus: virtualFocus2
            } = store.getState();
            if (!virtualFocus2) return;
            const previousActiveElement = event.relatedTarget;
            const isSilentlyFocused = silentlyFocused(event.currentTarget);
            if (isSelfTarget(event) && isSilentlyFocused) {
              event.stopPropagation();
              previousElementRef.current = previousActiveElement;
            }
          });
          const onFocusProp = props.onFocus;
          const onFocus = useEvent$1(event => {
            onFocusProp == null ? void 0 : onFocusProp(event);
            if (event.defaultPrevented) return;
            if (!composite) return;
            if (!store) return;
            const {
              relatedTarget
            } = event;
            const {
              virtualFocus: virtualFocus2
            } = store.getState();
            if (virtualFocus2) {
              if (isSelfTarget(event) && !isItem(store, relatedTarget)) {
                queueMicrotask(scheduleFocus);
              }
            } else if (isSelfTarget(event)) {
              store.setActiveId(null);
            }
          });
          const onBlurCaptureProp = props.onBlurCapture;
          const onBlurCapture = useEvent$1(event => {
            var _a2;
            onBlurCaptureProp == null ? void 0 : onBlurCaptureProp(event);
            if (event.defaultPrevented) return;
            if (!store) return;
            const {
              virtualFocus: virtualFocus2,
              activeId: activeId2
            } = store.getState();
            if (!virtualFocus2) return;
            const activeElement = (_a2 = getEnabledItem(store, activeId2)) == null ? void 0 : _a2.element;
            const nextActiveElement = event.relatedTarget;
            const nextActiveElementIsItem = isItem(store, nextActiveElement);
            const previousElement = previousElementRef.current;
            previousElementRef.current = null;
            if (isSelfTarget(event) && nextActiveElementIsItem) {
              if (nextActiveElement === activeElement) {
                if (previousElement && previousElement !== nextActiveElement) {
                  fireBlurEvent(previousElement, event);
                }
              } else if (activeElement) {
                fireBlurEvent(activeElement, event);
              } else if (previousElement) {
                fireBlurEvent(previousElement, event);
              }
              event.stopPropagation();
            } else {
              const targetIsItem = isItem(store, event.target);
              if (!targetIsItem && activeElement) {
                fireBlurEvent(activeElement, event);
              }
            }
          });
          const onKeyDownProp = props.onKeyDown;
          const moveOnKeyPressProp = useBooleanEvent(moveOnKeyPress);
          const onKeyDown = useEvent$1(event => {
            var _a2;
            onKeyDownProp == null ? void 0 : onKeyDownProp(event);
            if (event.nativeEvent.isComposing) return;
            if (event.defaultPrevented) return;
            if (!store) return;
            if (!isSelfTarget(event)) return;
            const {
              orientation,
              renderedItems,
              activeId: activeId2
            } = store.getState();
            const activeItem = getEnabledItem(store, activeId2);
            if ((_a2 = activeItem == null ? void 0 : activeItem.element) == null ? void 0 : _a2.isConnected) return;
            const isVertical = orientation !== "horizontal";
            const isHorizontal = orientation !== "vertical";
            const grid = isGrid(renderedItems);
            const isHorizontalKey = event.key === "ArrowLeft" || event.key === "ArrowRight" || event.key === "Home" || event.key === "End";
            if (isHorizontalKey && isTextField(event.currentTarget)) return;
            const up = () => {
              if (grid) {
                const item = findFirstEnabledItemInTheLastRow(renderedItems);
                return item == null ? void 0 : item.id;
              }
              return store == null ? void 0 : store.last();
            };
            const keyMap = {
              ArrowUp: (grid || isVertical) && up,
              ArrowRight: (grid || isHorizontal) && store.first,
              ArrowDown: (grid || isVertical) && store.first,
              ArrowLeft: (grid || isHorizontal) && store.last,
              Home: store.first,
              End: store.last,
              PageUp: store.first,
              PageDown: store.last
            };
            const action = keyMap[event.key];
            if (action) {
              const id = action();
              if (id !== void 0) {
                if (!moveOnKeyPressProp(event)) return;
                event.preventDefault();
                store.move(id);
              }
            }
          });
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(CompositeContextProvider, {
            value: store,
            children: element
          }), [store]);
          const activeDescendant = store.useState(state => {
            var _a2;
            if (!store) return;
            if (!composite) return;
            if (!state.virtualFocus) return;
            return (_a2 = getEnabledItem(store, state.activeId)) == null ? void 0 : _a2.id;
          });
          props = __spreadProps$1(__spreadValues$1({
            "aria-activedescendant": activeDescendant
          }, props), {
            ref: useMergeRefs(ref, setBaseElement, props.ref),
            onKeyDownCapture,
            onKeyUpCapture,
            onFocusCapture,
            onFocus,
            onBlurCapture,
            onKeyDown
          });
          const focusable = store.useState(state => composite && (state.virtualFocus || state.activeId === null));
          props = useFocusable(__spreadValues$1({
            focusable
          }, props));
          return props;
        });
        forwardRef2(function Composite2(props) {
          const htmlProps = useComposite(props);
          return createElement(TagName$f, htmlProps);
        });
        var TagName$e = "div";
        var useTabList = createHook(function useTabList2(_a) {
          var _b = _a,
            {
              store
            } = _b,
            props = __objRest$1(_b, ["store"]);
          const context = useTabProviderContext();
          store = store || context;
          invariant(store, false);
          const orientation = store.useState(state => state.orientation === "both" ? void 0 : state.orientation);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(TabScopedContextProvider, {
            value: store,
            children: element
          }), [store]);
          if (store.composite) {
            props = __spreadValues$1({
              focusable: false
            }, props);
          }
          props = __spreadValues$1({
            role: "tablist",
            "aria-orientation": orientation
          }, props);
          props = useComposite(__spreadValues$1({
            store
          }, props));
          return props;
        });
        var TabList = forwardRef2(function TabList2(props) {
          const htmlProps = useTabList(props);
          return createElement(TagName$e, htmlProps);
        });
        var TagName$d = "div";
        function afterTimeout(timeoutMs, cb) {
          const timeoutId = setTimeout(cb, timeoutMs);
          return () => clearTimeout(timeoutId);
        }
        function afterPaint(cb) {
          let raf = requestAnimationFrame(() => {
            raf = requestAnimationFrame(cb);
          });
          return () => cancelAnimationFrame(raf);
        }
        function parseCSSTime(...times) {
          return times.join(", ").split(", ").reduce((longestTime, currentTimeString) => {
            const multiplier = currentTimeString.endsWith("ms") ? 1 : 1e3;
            const currentTime = Number.parseFloat(currentTimeString || "0s") * multiplier;
            if (currentTime > longestTime) return currentTime;
            return longestTime;
          }, 0);
        }
        function isHidden(mounted, hidden, alwaysVisible) {
          return !alwaysVisible && hidden !== false && (!mounted || !!hidden);
        }
        var useDisclosureContent = createHook(function useDisclosureContent2(_a) {
          var _b = _a,
            {
              store,
              alwaysVisible
            } = _b,
            props = __objRest$1(_b, ["store", "alwaysVisible"]);
          const context = useDisclosureProviderContext();
          store = store || context;
          invariant(store, false);
          const ref = reactExports.useRef(null);
          const id = useId(props.id);
          const [transition, setTransition] = reactExports.useState(null);
          const open = store.useState("open");
          const mounted = store.useState("mounted");
          const animated = store.useState("animated");
          const contentElement = store.useState("contentElement");
          const otherElement = useStoreState(store.disclosure, "contentElement");
          useSafeLayoutEffect(() => {
            if (!ref.current) return;
            store == null ? void 0 : store.setContentElement(ref.current);
          }, [store]);
          useSafeLayoutEffect(() => {
            let previousAnimated;
            store == null ? void 0 : store.setState("animated", animated2 => {
              previousAnimated = animated2;
              return true;
            });
            return () => {
              if (previousAnimated === void 0) return;
              store == null ? void 0 : store.setState("animated", previousAnimated);
            };
          }, [store]);
          useSafeLayoutEffect(() => {
            if (!animated) return;
            if (!(contentElement == null ? void 0 : contentElement.isConnected)) {
              setTransition(null);
              return;
            }
            return afterPaint(() => {
              setTransition(open ? "enter" : mounted ? "leave" : null);
            });
          }, [animated, contentElement, open, mounted]);
          useSafeLayoutEffect(() => {
            if (!store) return;
            if (!animated) return;
            if (!transition) return;
            if (!contentElement) return;
            const stopAnimation = () => store == null ? void 0 : store.setState("animating", false);
            const stopAnimationSync = () => reactDomExports.flushSync(stopAnimation);
            if (transition === "leave" && open) return;
            if (transition === "enter" && !open) return;
            if (typeof animated === "number") {
              const timeout2 = animated;
              return afterTimeout(timeout2, stopAnimationSync);
            }
            const {
              transitionDuration,
              animationDuration,
              transitionDelay,
              animationDelay
            } = getComputedStyle(contentElement);
            const {
              transitionDuration: transitionDuration2 = "0",
              animationDuration: animationDuration2 = "0",
              transitionDelay: transitionDelay2 = "0",
              animationDelay: animationDelay2 = "0"
            } = otherElement ? getComputedStyle(otherElement) : {};
            const delay = parseCSSTime(transitionDelay, animationDelay, transitionDelay2, animationDelay2);
            const duration = parseCSSTime(transitionDuration, animationDuration, transitionDuration2, animationDuration2);
            const timeout = delay + duration;
            if (!timeout) {
              if (transition === "enter") {
                store.setState("animated", false);
              }
              stopAnimation();
              return;
            }
            const frameRate = 1e3 / 60;
            const maxTimeout = Math.max(timeout - frameRate, 0);
            return afterTimeout(maxTimeout, stopAnimationSync);
          }, [store, animated, contentElement, otherElement, open, transition]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(DialogScopedContextProvider, {
            value: store,
            children: element
          }), [store]);
          const hidden = isHidden(mounted, props.hidden, alwaysVisible);
          const styleProp = props.style;
          const style = reactExports.useMemo(() => {
            if (hidden) {
              return __spreadProps$1(__spreadValues$1({}, styleProp), {
                display: "none"
              });
            }
            return styleProp;
          }, [hidden, styleProp]);
          props = __spreadProps$1(__spreadValues$1({
            id,
            "data-open": open || void 0,
            "data-enter": transition === "enter" || void 0,
            "data-leave": transition === "leave" || void 0,
            hidden
          }, props), {
            ref: useMergeRefs(id ? store.setContentElement : null, ref, props.ref),
            style
          });
          return removeUndefinedValues(props);
        });
        var DisclosureContentImpl = forwardRef2(function DisclosureContentImpl2(props) {
          const htmlProps = useDisclosureContent(props);
          return createElement(TagName$d, htmlProps);
        });
        forwardRef2(function DisclosureContent2(_a) {
          var _b = _a,
            {
              unmountOnHide
            } = _b,
            props = __objRest$1(_b, ["unmountOnHide"]);
          const context = useDisclosureProviderContext();
          const store = props.store || context;
          const mounted = useStoreState(store, state => !unmountOnHide || (state == null ? void 0 : state.mounted));
          if (mounted === false) return null;
          return /* @__PURE__ */jsxRuntimeExports.jsx(DisclosureContentImpl, __spreadValues$1({}, props));
        });

        // src/disclosure/disclosure-store.ts
        function createDisclosureStore(props = {}) {
          const store = mergeStore(props.store, omit2(props.disclosure, ["contentElement", "disclosureElement"]));
          const syncState = store == null ? void 0 : store.getState();
          const open = defaultValue$3(props.open, syncState == null ? void 0 : syncState.open, props.defaultOpen, false);
          const animated = defaultValue$3(props.animated, syncState == null ? void 0 : syncState.animated, false);
          const initialState = {
            open,
            animated,
            animating: !!animated && open,
            mounted: open,
            contentElement: defaultValue$3(syncState == null ? void 0 : syncState.contentElement, null),
            disclosureElement: defaultValue$3(syncState == null ? void 0 : syncState.disclosureElement, null)
          };
          const disclosure = createStore(initialState, store);
          setup(disclosure, () => sync(disclosure, ["animated", "animating"], state => {
            if (state.animated) return;
            disclosure.setState("animating", false);
          }));
          setup(disclosure, () => subscribe(disclosure, ["open"], () => {
            if (!disclosure.getState().animated) return;
            disclosure.setState("animating", true);
          }));
          setup(disclosure, () => sync(disclosure, ["open", "animating"], state => {
            disclosure.setState("mounted", state.open || state.animating);
          }));
          return __spreadProps(__spreadValues({}, disclosure), {
            disclosure: props.disclosure,
            setOpen: value => disclosure.setState("open", value),
            show: () => disclosure.setState("open", true),
            hide: () => disclosure.setState("open", false),
            toggle: () => disclosure.setState("open", open2 => !open2),
            stopAnimation: () => disclosure.setState("animating", false),
            setContentElement: value => disclosure.setState("contentElement", value),
            setDisclosureElement: value => disclosure.setState("disclosureElement", value)
          });
        }
        function useDisclosureStoreProps(store, update, props) {
          useUpdateEffect$1(update, [props.store, props.disclosure]);
          useStoreProps(store, props, "open", "setOpen");
          useStoreProps(store, props, "mounted", "setMounted");
          useStoreProps(store, props, "animated");
          return Object.assign(store, {
            disclosure: props.disclosure
          });
        }
        function useDisclosureStore(props = {}) {
          const [store, update] = useStore(createDisclosureStore, props);
          return useDisclosureStoreProps(store, update, props);
        }
        var TagName$c = "div";
        var useTabPanel = createHook(function useTabPanel2(_a) {
          var _b = _a,
            {
              store,
              unmountOnHide,
              tabId: tabIdProp,
              getItem: getItemProp,
              scrollRestoration,
              scrollElement
            } = _b,
            props = __objRest$1(_b, ["store", "unmountOnHide", "tabId", "getItem", "scrollRestoration", "scrollElement"]);
          const context = useTabProviderContext();
          store = store || context;
          invariant(store, false);
          const ref = reactExports.useRef(null);
          const id = useId(props.id);
          const tabId = useStoreState(store.panels, () => {
            var _a2;
            return tabIdProp || ((_a2 = store == null ? void 0 : store.panels.item(id)) == null ? void 0 : _a2.tabId);
          });
          const open = useStoreState(store, state => !!tabId && state.selectedId === tabId);
          const disclosure = useDisclosureStore({
            open
          });
          const mounted = useStoreState(disclosure, "mounted");
          const scrollPositionRef = reactExports.useRef(/* @__PURE__ */new Map());
          const getScrollElement = useEvent$1(() => {
            const panelElement = ref.current;
            if (!panelElement) return null;
            if (!scrollElement) return panelElement;
            if (typeof scrollElement === "function") {
              return scrollElement(panelElement);
            }
            if ("current" in scrollElement) {
              return scrollElement.current;
            }
            return scrollElement;
          });
          reactExports.useEffect(() => {
            var _a2, _b2;
            if (!scrollRestoration) return;
            if (!mounted) return;
            const element = getScrollElement();
            if (!element) return;
            if (scrollRestoration === "reset") {
              element.scroll(0, 0);
              return;
            }
            if (!tabId) return;
            const position = scrollPositionRef.current.get(tabId);
            element.scroll((_a2 = position == null ? void 0 : position.x) != null ? _a2 : 0, (_b2 = position == null ? void 0 : position.y) != null ? _b2 : 0);
            const onScroll = () => {
              scrollPositionRef.current.set(tabId, {
                x: element.scrollLeft,
                y: element.scrollTop
              });
            };
            element.addEventListener("scroll", onScroll);
            return () => {
              element.removeEventListener("scroll", onScroll);
            };
          }, [scrollRestoration, mounted, tabId, getScrollElement, store]);
          const [hasTabbableChildren, setHasTabbableChildren] = reactExports.useState(false);
          reactExports.useEffect(() => {
            const element = ref.current;
            if (!element) return;
            const tabbable = getAllTabbableIn(element);
            setHasTabbableChildren(!!tabbable.length);
          }, []);
          const getItem = reactExports.useCallback(item => {
            const nextItem = __spreadProps$1(__spreadValues$1({}, item), {
              id: id || item.id,
              tabId: tabIdProp
            });
            if (getItemProp) {
              return getItemProp(nextItem);
            }
            return nextItem;
          }, [id, tabIdProp, getItemProp]);
          const onKeyDownProp = props.onKeyDown;
          const onKeyDown = useEvent$1(event => {
            onKeyDownProp == null ? void 0 : onKeyDownProp(event);
            if (event.defaultPrevented) return;
            if (!(store == null ? void 0 : store.composite)) return;
            const keyMap = {
              ArrowLeft: store.previous,
              ArrowRight: store.next,
              Home: store.first,
              End: store.last
            };
            const action = keyMap[event.key];
            if (!action) return;
            const {
              selectedId
            } = store.getState();
            const nextId = action({
              activeId: selectedId
            });
            if (!nextId) return;
            event.preventDefault();
            store.move(nextId);
          });
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(TabScopedContextProvider, {
            value: store,
            children: element
          }), [store]);
          props = __spreadProps$1(__spreadValues$1({
            id,
            role: "tabpanel",
            "aria-labelledby": tabId || void 0
          }, props), {
            children: unmountOnHide && !mounted ? null : props.children,
            ref: useMergeRefs(ref, props.ref),
            onKeyDown
          });
          props = useFocusable(__spreadValues$1({
            // If the tab panel is rendered as part of another composite widget such
            // as combobox, it should not be focusable.
            focusable: !store.composite && !hasTabbableChildren
          }, props));
          props = useDisclosureContent(__spreadValues$1({
            store: disclosure
          }, props));
          props = useCollectionItem(__spreadProps$1(__spreadValues$1({
            store: store.panels
          }, props), {
            getItem
          }));
          return props;
        });
        var TabPanel$1 = forwardRef2(function TabPanel2(props) {
          const htmlProps = useTabPanel(props);
          return createElement(TagName$c, htmlProps);
        });

        // src/separator/separator.tsx
        var TagName$b = "hr";
        var useSeparator = createHook(function useSeparator2(_a) {
          var _b = _a,
            {
              orientation = "horizontal"
            } = _b,
            props = __objRest$1(_b, ["orientation"]);
          props = __spreadValues$1({
            role: "separator",
            "aria-orientation": orientation
          }, props);
          return props;
        });
        var Separator = forwardRef2(function Separator2(props) {
          const htmlProps = useSeparator(props);
          return createElement(TagName$b, htmlProps);
        });

        // src/dialog/dialog-store.ts
        function createDialogStore(props = {}) {
          return createDisclosureStore(props);
        }
        function useDialogStoreProps(store, update, props) {
          return useDisclosureStoreProps(store, update, props);
        }
        function useDialogStore(props = {}) {
          const [store, update] = useStore(createDialogStore, props);
          return useDialogStoreProps(store, update, props);
        }

        // src/popover/popover-store.ts
        function createPopoverStore(_a = {}) {
          var _b = _a,
            {
              popover: otherPopover
            } = _b,
            props = __objRest(_b, ["popover"]);
          const store = mergeStore(props.store, omit2(otherPopover, ["arrowElement", "anchorElement", "contentElement", "popoverElement", "disclosureElement"]));
          const syncState = store == null ? void 0 : store.getState();
          const dialog = createDialogStore(__spreadProps(__spreadValues({}, props), {
            store
          }));
          const placement = defaultValue$3(props.placement, syncState == null ? void 0 : syncState.placement, "bottom");
          const initialState = __spreadProps(__spreadValues({}, dialog.getState()), {
            placement,
            currentPlacement: placement,
            anchorElement: defaultValue$3(syncState == null ? void 0 : syncState.anchorElement, null),
            popoverElement: defaultValue$3(syncState == null ? void 0 : syncState.popoverElement, null),
            arrowElement: defaultValue$3(syncState == null ? void 0 : syncState.arrowElement, null),
            rendered: Symbol("rendered")
          });
          const popover = createStore(initialState, dialog, store);
          return __spreadProps(__spreadValues(__spreadValues({}, dialog), popover), {
            setAnchorElement: element => popover.setState("anchorElement", element),
            setPopoverElement: element => popover.setState("popoverElement", element),
            setArrowElement: element => popover.setState("arrowElement", element),
            render: () => popover.setState("rendered", Symbol("rendered"))
          });
        }
        function usePopoverStoreProps(store, update, props) {
          useUpdateEffect$1(update, [props.popover]);
          useStoreProps(store, props, "placement");
          return useDialogStoreProps(store, update, props);
        }

        // src/hovercard/hovercard-store.ts
        function createHovercardStore(props = {}) {
          var _a;
          const syncState = (_a = props.store) == null ? void 0 : _a.getState();
          const popover = createPopoverStore(__spreadProps(__spreadValues({}, props), {
            placement: defaultValue$3(props.placement, syncState == null ? void 0 : syncState.placement, "bottom")
          }));
          const timeout = defaultValue$3(props.timeout, syncState == null ? void 0 : syncState.timeout, 500);
          const initialState = __spreadProps(__spreadValues({}, popover.getState()), {
            timeout,
            showTimeout: defaultValue$3(props.showTimeout, syncState == null ? void 0 : syncState.showTimeout),
            hideTimeout: defaultValue$3(props.hideTimeout, syncState == null ? void 0 : syncState.hideTimeout),
            autoFocusOnShow: defaultValue$3(syncState == null ? void 0 : syncState.autoFocusOnShow, false)
          });
          const hovercard = createStore(initialState, popover, props.store);
          return __spreadProps(__spreadValues(__spreadValues({}, popover), hovercard), {
            setAutoFocusOnShow: value => hovercard.setState("autoFocusOnShow", value)
          });
        }
        function useHovercardStoreProps(store, update, props) {
          useStoreProps(store, props, "timeout");
          useStoreProps(store, props, "showTimeout");
          useStoreProps(store, props, "hideTimeout");
          return usePopoverStoreProps(store, update, props);
        }
        function createTooltipStore(props = {}) {
          var _a;
          const syncState = (_a = props.store) == null ? void 0 : _a.getState();
          const hovercard = createHovercardStore(__spreadProps(__spreadValues({}, props), {
            placement: defaultValue$3(props.placement, syncState == null ? void 0 : syncState.placement, "top"),
            hideTimeout: defaultValue$3(props.hideTimeout, syncState == null ? void 0 : syncState.hideTimeout, 0)
          }));
          const initialState = __spreadProps(__spreadValues({}, hovercard.getState()), {
            type: defaultValue$3(props.type, syncState == null ? void 0 : syncState.type, "description"),
            skipTimeout: defaultValue$3(props.skipTimeout, syncState == null ? void 0 : syncState.skipTimeout, 300)
          });
          const tooltip = createStore(initialState, hovercard, props.store);
          return __spreadValues(__spreadValues({}, hovercard), tooltip);
        }
        function useTooltipStoreProps(store, update, props) {
          useStoreProps(store, props, "type");
          useStoreProps(store, props, "skipTimeout");
          return useHovercardStoreProps(store, update, props);
        }
        function useTooltipStore(props = {}) {
          const [store, update] = useStore(createTooltipStore, props);
          return useTooltipStoreProps(store, update, props);
        }

        // src/hovercard/hovercard-context.tsx
        var ctx$1 = createStoreContext([PopoverContextProvider], [PopoverScopedContextProvider]);
        var useHovercardProviderContext = ctx$1.useProviderContext;
        var HovercardContextProvider = ctx$1.ContextProvider;
        var HovercardScopedContextProvider = ctx$1.ScopedContextProvider;

        // src/tooltip/tooltip-context.tsx
        var ctx = createStoreContext([HovercardContextProvider], [HovercardScopedContextProvider]);
        var useTooltipProviderContext = ctx.useProviderContext;
        var TooltipScopedContextProvider = ctx.ScopedContextProvider;

        // src/hovercard/utils/polygon.ts
        function getEventPoint(event) {
          return [event.clientX, event.clientY];
        }
        function isPointInPolygon(point, polygon) {
          const [x, y] = point;
          let inside = false;
          const length = polygon.length;
          for (let l = length, i = 0, j = l - 1; i < l; j = i++) {
            const [xi, yi] = polygon[i];
            const [xj, yj] = polygon[j];
            const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [0, 0];
            const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);
            if (yj < yi) {
              if (y >= yj && y < yi) {
                if (where === 0) return true;
                if (where > 0) {
                  if (y === yj) {
                    if (y > vy) {
                      inside = !inside;
                    }
                  } else {
                    inside = !inside;
                  }
                }
              }
            } else if (yi < yj) {
              if (y > yi && y <= yj) {
                if (where === 0) return true;
                if (where < 0) {
                  if (y === yj) {
                    if (y < vy) {
                      inside = !inside;
                    }
                  } else {
                    inside = !inside;
                  }
                }
              }
            } else if (y === yi && (x >= xj && x <= xi || x >= xi && x <= xj)) {
              return true;
            }
          }
          return inside;
        }
        function getEnterPointPlacement(enterPoint, rect) {
          const {
            top,
            right,
            bottom,
            left
          } = rect;
          const [x, y] = enterPoint;
          const placementX = x < left ? "left" : x > right ? "right" : null;
          const placementY = y < top ? "top" : y > bottom ? "bottom" : null;
          return [placementX, placementY];
        }
        function getElementPolygon(element, enterPoint) {
          const rect = element.getBoundingClientRect();
          const {
            top,
            right,
            bottom,
            left
          } = rect;
          const [x, y] = getEnterPointPlacement(enterPoint, rect);
          const polygon = [enterPoint];
          if (x) {
            if (y !== "top") {
              polygon.push([x === "left" ? left : right, top]);
            }
            polygon.push([x === "left" ? right : left, top]);
            polygon.push([x === "left" ? right : left, bottom]);
            if (y !== "bottom") {
              polygon.push([x === "left" ? left : right, bottom]);
            }
          } else if (y === "top") {
            polygon.push([left, top]);
            polygon.push([left, bottom]);
            polygon.push([right, bottom]);
            polygon.push([right, top]);
          } else {
            polygon.push([left, bottom]);
            polygon.push([left, top]);
            polygon.push([right, top]);
            polygon.push([right, bottom]);
          }
          return polygon;
        }
        var PortalContext = reactExports.createContext(null);

        // src/visually-hidden/visually-hidden.tsx
        var TagName$a = "span";
        var useVisuallyHidden = createHook(function useVisuallyHidden2(props) {
          props = __spreadProps$1(__spreadValues$1({}, props), {
            style: __spreadValues$1({
              border: 0,
              clip: "rect(0 0 0 0)",
              height: "1px",
              margin: "-1px",
              overflow: "hidden",
              padding: 0,
              position: "absolute",
              whiteSpace: "nowrap",
              width: "1px"
            }, props.style)
          });
          return props;
        });
        forwardRef2(function VisuallyHidden2(props) {
          const htmlProps = useVisuallyHidden(props);
          return createElement(TagName$a, htmlProps);
        });

        // src/focus-trap/focus-trap.tsx
        var TagName$9 = "span";
        var useFocusTrap = createHook(function useFocusTrap2(props) {
          props = __spreadProps$1(__spreadValues$1({
            "data-focus-trap": "",
            tabIndex: 0,
            "aria-hidden": true
          }, props), {
            style: __spreadValues$1({
              // Prevents unintended scroll jumps.
              position: "fixed",
              top: 0,
              left: 0
            }, props.style)
          });
          props = useVisuallyHidden(props);
          return props;
        });
        var FocusTrap = forwardRef2(function FocusTrap2(props) {
          const htmlProps = useFocusTrap(props);
          return createElement(TagName$9, htmlProps);
        });
        var TagName$8 = "div";
        function getRootElement(element) {
          return getDocument(element).body;
        }
        function getPortalElement(element, portalElement) {
          if (!portalElement) {
            return getDocument(element).createElement("div");
          }
          if (typeof portalElement === "function") {
            return portalElement(element);
          }
          return portalElement;
        }
        function getRandomId(prefix = "id") {
          return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).slice(2, 8)}`;
        }
        function queueFocus(element) {
          queueMicrotask(() => {
            element == null ? void 0 : element.focus();
          });
        }
        var usePortal = createHook(function usePortal2(_a) {
          var _b = _a,
            {
              preserveTabOrder,
              preserveTabOrderAnchor,
              portalElement,
              portalRef,
              portal = true
            } = _b,
            props = __objRest$1(_b, ["preserveTabOrder", "preserveTabOrderAnchor", "portalElement", "portalRef", "portal"]);
          const ref = reactExports.useRef(null);
          const refProp = useMergeRefs(ref, props.ref);
          const context = reactExports.useContext(PortalContext);
          const [portalNode, setPortalNode] = reactExports.useState(null);
          const [anchorPortalNode, setAnchorPortalNode] = reactExports.useState(null);
          const outerBeforeRef = reactExports.useRef(null);
          const innerBeforeRef = reactExports.useRef(null);
          const innerAfterRef = reactExports.useRef(null);
          const outerAfterRef = reactExports.useRef(null);
          useSafeLayoutEffect(() => {
            const element = ref.current;
            if (!element || !portal) {
              setPortalNode(null);
              return;
            }
            const portalEl = getPortalElement(element, portalElement);
            if (!portalEl) {
              setPortalNode(null);
              return;
            }
            const isPortalInDocument = portalEl.isConnected;
            if (!isPortalInDocument) {
              const rootElement = context || getRootElement(element);
              rootElement.appendChild(portalEl);
            }
            if (!portalEl.id) {
              portalEl.id = element.id ? `portal/${element.id}` : getRandomId();
            }
            setPortalNode(portalEl);
            setRef(portalRef, portalEl);
            if (isPortalInDocument) return;
            return () => {
              portalEl.remove();
              setRef(portalRef, null);
            };
          }, [portal, portalElement, context, portalRef]);
          useSafeLayoutEffect(() => {
            if (!portal) return;
            if (!preserveTabOrder) return;
            if (!preserveTabOrderAnchor) return;
            const doc = getDocument(preserveTabOrderAnchor);
            const element = doc.createElement("span");
            element.style.position = "fixed";
            preserveTabOrderAnchor.insertAdjacentElement("afterend", element);
            setAnchorPortalNode(element);
            return () => {
              element.remove();
              setAnchorPortalNode(null);
            };
          }, [portal, preserveTabOrder, preserveTabOrderAnchor]);
          reactExports.useEffect(() => {
            if (!portalNode) return;
            if (!preserveTabOrder) return;
            let raf = 0;
            const onFocus = event => {
              if (!isFocusEventOutside(event)) return;
              const focusing = event.type === "focusin";
              cancelAnimationFrame(raf);
              if (focusing) {
                return restoreFocusIn(portalNode);
              }
              raf = requestAnimationFrame(() => {
                disableFocusIn(portalNode, true);
              });
            };
            portalNode.addEventListener("focusin", onFocus, true);
            portalNode.addEventListener("focusout", onFocus, true);
            return () => {
              cancelAnimationFrame(raf);
              portalNode.removeEventListener("focusin", onFocus, true);
              portalNode.removeEventListener("focusout", onFocus, true);
            };
          }, [portalNode, preserveTabOrder]);
          props = useWrapElement(props, element => {
            element =
            // While the portal node is not in the DOM, we need to pass the
            // current context to the portal context, otherwise it's going to
            // reset to the body element on nested portals.
            /* @__PURE__ */
            jsxRuntimeExports.jsx(PortalContext.Provider, {
              value: portalNode || context,
              children: element
            });
            if (!portal) return element;
            if (!portalNode) {
              return /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                ref: refProp,
                id: props.id,
                style: {
                  position: "fixed"
                },
                hidden: true
              });
            }
            element = /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [preserveTabOrder && portalNode && /* @__PURE__ */jsxRuntimeExports.jsx(FocusTrap, {
                ref: innerBeforeRef,
                "data-focus-trap": props.id,
                className: "__focus-trap-inner-before",
                onFocus: event => {
                  if (isFocusEventOutside(event, portalNode)) {
                    queueFocus(getNextTabbable());
                  } else {
                    queueFocus(outerBeforeRef.current);
                  }
                }
              }), element, preserveTabOrder && portalNode && /* @__PURE__ */jsxRuntimeExports.jsx(FocusTrap, {
                ref: innerAfterRef,
                "data-focus-trap": props.id,
                className: "__focus-trap-inner-after",
                onFocus: event => {
                  if (isFocusEventOutside(event, portalNode)) {
                    queueFocus(getPreviousTabbable());
                  } else {
                    queueFocus(outerAfterRef.current);
                  }
                }
              })]
            });
            if (portalNode) {
              element = reactDomExports.createPortal(element, portalNode);
            }
            let preserveTabOrderElement = /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [preserveTabOrder && portalNode && /* @__PURE__ */jsxRuntimeExports.jsx(FocusTrap, {
                ref: outerBeforeRef,
                "data-focus-trap": props.id,
                className: "__focus-trap-outer-before",
                onFocus: event => {
                  const fromOuter = event.relatedTarget === outerAfterRef.current;
                  if (!fromOuter && isFocusEventOutside(event, portalNode)) {
                    queueFocus(innerBeforeRef.current);
                  } else {
                    queueFocus(getPreviousTabbable());
                  }
                }
              }), preserveTabOrder &&
              // We're using position: fixed here so that the browser doesn't
              // add margin to the element when setting gap on a parent element.
              /* @__PURE__ */
              jsxRuntimeExports.jsx("span", {
                "aria-owns": portalNode == null ? void 0 : portalNode.id,
                style: {
                  position: "fixed"
                }
              }), preserveTabOrder && portalNode && /* @__PURE__ */jsxRuntimeExports.jsx(FocusTrap, {
                ref: outerAfterRef,
                "data-focus-trap": props.id,
                className: "__focus-trap-outer-after",
                onFocus: event => {
                  if (isFocusEventOutside(event, portalNode)) {
                    queueFocus(innerAfterRef.current);
                  } else {
                    const nextTabbable = getNextTabbable();
                    if (nextTabbable === innerBeforeRef.current) {
                      requestAnimationFrame(() => {
                        var _a2;
                        return (_a2 = getNextTabbable()) == null ? void 0 : _a2.focus();
                      });
                      return;
                    }
                    queueFocus(nextTabbable);
                  }
                }
              })]
            });
            if (anchorPortalNode && preserveTabOrder) {
              preserveTabOrderElement = reactDomExports.createPortal(preserveTabOrderElement, anchorPortalNode);
            }
            return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [preserveTabOrderElement, element]
            });
          }, [portalNode, context, portal, props.id, preserveTabOrder, anchorPortalNode]);
          props = __spreadProps$1(__spreadValues$1({}, props), {
            ref: refProp
          });
          return props;
        });
        forwardRef2(function Portal2(props) {
          const htmlProps = usePortal(props);
          return createElement(TagName$8, htmlProps);
        });
        var HeadingContext = reactExports.createContext(0);
        function HeadingLevel({
          level,
          children
        }) {
          const contextLevel = reactExports.useContext(HeadingContext);
          const nextLevel = Math.max(Math.min(level || contextLevel + 1, 6), 1);
          return /* @__PURE__ */jsxRuntimeExports.jsx(HeadingContext.Provider, {
            value: nextLevel,
            children
          });
        }
        var TagName$7 = "div";
        var useFocusableContainer = createHook(function useFocusableContainer2(_a) {
          var _b = _a,
            {
              autoFocusOnShow = true
            } = _b,
            props = __objRest$1(_b, ["autoFocusOnShow"]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(FocusableContext.Provider, {
            value: autoFocusOnShow,
            children: element
          }), [autoFocusOnShow]);
          return props;
        });
        forwardRef2(function FocusableContainer2(props) {
          const htmlProps = useFocusableContainer(props);
          return createElement(TagName$7, htmlProps);
        });
        function prependHiddenDismiss(container, onClick) {
          const document = getDocument(container);
          const button = document.createElement("button");
          button.type = "button";
          button.tabIndex = -1;
          button.textContent = "Dismiss popup";
          Object.assign(button.style, {
            border: "0px",
            clip: "rect(0 0 0 0)",
            height: "1px",
            margin: "-1px",
            overflow: "hidden",
            padding: "0px",
            position: "absolute",
            whiteSpace: "nowrap",
            width: "1px"
          });
          button.addEventListener("click", onClick);
          container.prepend(button);
          const removeHiddenDismiss = () => {
            button.removeEventListener("click", onClick);
            button.remove();
          };
          return removeHiddenDismiss;
        }
        function usePreviousMouseDownRef(enabled) {
          const previousMouseDownRef = reactExports.useRef();
          reactExports.useEffect(() => {
            if (!enabled) {
              previousMouseDownRef.current = null;
              return;
            }
            const onMouseDown = event => {
              previousMouseDownRef.current = event.target;
            };
            return addGlobalEventListener("mousedown", onMouseDown, true);
          }, [enabled]);
          return previousMouseDownRef;
        }

        // src/dialog/utils/orchestrate.ts
        var cleanups = /* @__PURE__ */new WeakMap();
        function orchestrate(element, key, setup) {
          if (!cleanups.has(element)) {
            cleanups.set(element, /* @__PURE__ */new Map());
          }
          const elementCleanups = cleanups.get(element);
          const prevCleanup = elementCleanups.get(key);
          if (!prevCleanup) {
            elementCleanups.set(key, setup());
            return () => {
              var _a;
              (_a = elementCleanups.get(key)) == null ? void 0 : _a();
              elementCleanups.delete(key);
            };
          }
          const cleanup = setup();
          const nextCleanup = () => {
            cleanup();
            prevCleanup();
            elementCleanups.delete(key);
          };
          elementCleanups.set(key, nextCleanup);
          return () => {
            const isCurrent = elementCleanups.get(key) === nextCleanup;
            if (!isCurrent) return;
            cleanup();
            elementCleanups.set(key, prevCleanup);
          };
        }
        function setAttribute(element, attr, value) {
          const setup = () => {
            const previousValue = element.getAttribute(attr);
            element.setAttribute(attr, value);
            return () => {
              if (previousValue == null) {
                element.removeAttribute(attr);
              } else {
                element.setAttribute(attr, previousValue);
              }
            };
          };
          return orchestrate(element, attr, setup);
        }
        function setProperty(element, property, value) {
          const setup = () => {
            const exists = property in element;
            const previousValue = element[property];
            element[property] = value;
            return () => {
              if (!exists) {
                delete element[property];
              } else {
                element[property] = previousValue;
              }
            };
          };
          return orchestrate(element, property, setup);
        }
        function assignStyle(element, style) {
          if (!element) return () => {};
          const setup = () => {
            const prevStyle = element.style.cssText;
            Object.assign(element.style, style);
            return () => {
              element.style.cssText = prevStyle;
            };
          };
          return orchestrate(element, "style", setup);
        }
        function setCSSProperty(element, property, value) {
          if (!element) return () => {};
          const setup = () => {
            const previousValue = element.style.getPropertyValue(property);
            element.style.setProperty(property, value);
            return () => {
              if (previousValue) {
                element.style.setProperty(property, previousValue);
              } else {
                element.style.removeProperty(property);
              }
            };
          };
          return orchestrate(element, property, setup);
        }
        var ignoreTags = ["SCRIPT", "STYLE"];
        function getSnapshotPropertyName(id) {
          return `__ariakit-dialog-snapshot-${id}`;
        }
        function inSnapshot(id, element) {
          const doc = getDocument(element);
          const propertyName = getSnapshotPropertyName(id);
          if (!doc.body[propertyName]) return true;
          do {
            if (element === doc.body) return false;
            if (element[propertyName]) return true;
            if (!element.parentElement) return false;
            element = element.parentElement;
          } while (true);
        }
        function isValidElement(id, element, ignoredElements) {
          if (ignoreTags.includes(element.tagName)) return false;
          if (!inSnapshot(id, element)) return false;
          return !ignoredElements.some(enabledElement => enabledElement && contains(element, enabledElement));
        }
        function walkTreeOutside(id, elements, callback, ancestorCallback) {
          for (let element of elements) {
            if (!(element == null ? void 0 : element.isConnected)) continue;
            const hasAncestorAlready = elements.some(maybeAncestor => {
              if (!maybeAncestor) return false;
              if (maybeAncestor === element) return false;
              return maybeAncestor.contains(element);
            });
            const doc = getDocument(element);
            const originalElement = element;
            while (element.parentElement && element !== doc.body) {
              ancestorCallback == null ? void 0 : ancestorCallback(element.parentElement, originalElement);
              if (!hasAncestorAlready) {
                for (const child of element.parentElement.children) {
                  if (isValidElement(id, child, elements)) {
                    callback(child, originalElement);
                  }
                }
              }
              element = element.parentElement;
            }
          }
        }
        function createWalkTreeSnapshot(id, elements) {
          const {
            body
          } = getDocument(elements[0]);
          const cleanups = [];
          const markElement = element => {
            cleanups.push(setProperty(element, getSnapshotPropertyName(id), true));
          };
          walkTreeOutside(id, elements, markElement);
          return chain$1(setProperty(body, getSnapshotPropertyName(id), true), () => {
            for (const cleanup of cleanups) {
              cleanup();
            }
          });
        }

        // src/dialog/utils/is-backdrop.ts
        function isBackdrop(element, ...ids) {
          if (!element) return false;
          const backdrop = element.getAttribute("data-backdrop");
          if (backdrop == null) return false;
          if (backdrop === "") return true;
          if (backdrop === "true") return true;
          if (!ids.length) return true;
          return ids.some(id => backdrop === id);
        }
        function getPropertyName(id = "", ancestor = false) {
          return `__ariakit-dialog-${ancestor ? "ancestor" : "outside"}${id ? `-${id}` : ""}`;
        }
        function markElement(element, id = "") {
          return chain$1(setProperty(element, getPropertyName(), true), setProperty(element, getPropertyName(id), true));
        }
        function markAncestor(element, id = "") {
          return chain$1(setProperty(element, getPropertyName("", true), true), setProperty(element, getPropertyName(id, true), true));
        }
        function isElementMarked(element, id) {
          const ancestorProperty = getPropertyName(id, true);
          if (element[ancestorProperty]) return true;
          const elementProperty = getPropertyName(id);
          do {
            if (element[elementProperty]) return true;
            if (!element.parentElement) return false;
            element = element.parentElement;
          } while (true);
        }
        function markTreeOutside(id, elements) {
          const cleanups = [];
          const ids = elements.map(el => el == null ? void 0 : el.id);
          walkTreeOutside(id, elements, element => {
            if (isBackdrop(element, ...ids)) return;
            cleanups.unshift(markElement(element, id));
          }, (ancestor, element) => {
            const isAnotherDialogAncestor = element.hasAttribute("data-dialog") && element.id !== id;
            if (isAnotherDialogAncestor) return;
            cleanups.unshift(markAncestor(ancestor, id));
          });
          const restoreAccessibilityTree = () => {
            for (const cleanup of cleanups) {
              cleanup();
            }
          };
          return restoreAccessibilityTree;
        }
        function isInDocument(target) {
          if (target.tagName === "HTML") return true;
          return contains(getDocument(target).body, target);
        }
        function isDisclosure(disclosure, target) {
          if (!disclosure) return false;
          if (contains(disclosure, target)) return true;
          const activeId = target.getAttribute("aria-activedescendant");
          if (activeId) {
            const activeElement = getDocument(disclosure).getElementById(activeId);
            if (activeElement) {
              return contains(disclosure, activeElement);
            }
          }
          return false;
        }
        function isMouseEventOnDialog(event, dialog) {
          if (!("clientY" in event)) return false;
          const rect = dialog.getBoundingClientRect();
          if (rect.width === 0 || rect.height === 0) return false;
          return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
        }
        function useEventOutside({
          store,
          type,
          listener,
          capture,
          domReady
        }) {
          const callListener = useEvent$1(listener);
          const open = useStoreState(store, "open");
          const focusedRef = reactExports.useRef(false);
          useSafeLayoutEffect(() => {
            if (!open) return;
            if (!domReady) return;
            const {
              contentElement
            } = store.getState();
            if (!contentElement) return;
            const onFocus = () => {
              focusedRef.current = true;
            };
            contentElement.addEventListener("focusin", onFocus, true);
            return () => contentElement.removeEventListener("focusin", onFocus, true);
          }, [store, open, domReady]);
          reactExports.useEffect(() => {
            if (!open) return;
            const onEvent = event => {
              const {
                contentElement,
                disclosureElement
              } = store.getState();
              const target = event.target;
              if (!contentElement) return;
              if (!target) return;
              if (!isInDocument(target)) return;
              if (contains(contentElement, target)) return;
              if (isDisclosure(disclosureElement, target)) return;
              if (target.hasAttribute("data-focus-trap")) return;
              if (isMouseEventOnDialog(event, contentElement)) return;
              const focused = focusedRef.current;
              if (focused && !isElementMarked(target, contentElement.id)) return;
              if (isSafariFocusAncestor(target)) return;
              callListener(event);
            };
            return addGlobalEventListener(type, onEvent, capture);
          }, [open, capture]);
        }
        function shouldHideOnInteractOutside(hideOnInteractOutside, event) {
          if (typeof hideOnInteractOutside === "function") {
            return hideOnInteractOutside(event);
          }
          return !!hideOnInteractOutside;
        }
        function useHideOnInteractOutside(store, hideOnInteractOutside, domReady) {
          const open = useStoreState(store, "open");
          const previousMouseDownRef = usePreviousMouseDownRef(open);
          const props = {
            store,
            domReady,
            capture: true
          };
          useEventOutside(__spreadProps$1(__spreadValues$1({}, props), {
            type: "click",
            listener: event => {
              const {
                contentElement
              } = store.getState();
              const previousMouseDown = previousMouseDownRef.current;
              if (!previousMouseDown) return;
              if (!isVisible(previousMouseDown)) return;
              if (!isElementMarked(previousMouseDown, contentElement == null ? void 0 : contentElement.id)) return;
              if (!shouldHideOnInteractOutside(hideOnInteractOutside, event)) return;
              store.hide();
            }
          }));
          useEventOutside(__spreadProps$1(__spreadValues$1({}, props), {
            type: "focusin",
            listener: event => {
              const {
                contentElement
              } = store.getState();
              if (!contentElement) return;
              if (event.target === getDocument(contentElement)) return;
              if (!shouldHideOnInteractOutside(hideOnInteractOutside, event)) return;
              store.hide();
            }
          }));
          useEventOutside(__spreadProps$1(__spreadValues$1({}, props), {
            type: "contextmenu",
            listener: event => {
              if (!shouldHideOnInteractOutside(hideOnInteractOutside, event)) return;
              store.hide();
            }
          }));
        }
        var NestedDialogsContext = reactExports.createContext({});
        function useNestedDialogs(store) {
          const context = reactExports.useContext(NestedDialogsContext);
          const [dialogs, setDialogs] = reactExports.useState([]);
          const add = reactExports.useCallback(dialog => {
            var _a;
            setDialogs(dialogs2 => [...dialogs2, dialog]);
            return chain$1((_a = context.add) == null ? void 0 : _a.call(context, dialog), () => {
              setDialogs(dialogs2 => dialogs2.filter(d => d !== dialog));
            });
          }, [context]);
          useSafeLayoutEffect(() => {
            return sync(store, ["open", "contentElement"], state => {
              var _a;
              if (!state.open) return;
              if (!state.contentElement) return;
              return (_a = context.add) == null ? void 0 : _a.call(context, store);
            });
          }, [store, context]);
          const providerValue = reactExports.useMemo(() => ({
            store,
            add
          }), [store, add]);
          const wrapElement = reactExports.useCallback(element => /* @__PURE__ */jsxRuntimeExports.jsx(NestedDialogsContext.Provider, {
            value: providerValue,
            children: element
          }), [providerValue]);
          return {
            wrapElement,
            nestedDialogs: dialogs
          };
        }
        function useRootDialog({
          attribute,
          contentId,
          contentElement,
          enabled
        }) {
          const [updated, retry] = useForceUpdate();
          const isRootDialog = reactExports.useCallback(() => {
            if (!enabled) return false;
            if (!contentElement) return false;
            const {
              body
            } = getDocument(contentElement);
            const id = body.getAttribute(attribute);
            return !id || id === contentId;
          }, [updated, enabled, contentElement, attribute, contentId]);
          reactExports.useEffect(() => {
            if (!enabled) return;
            if (!contentId) return;
            if (!contentElement) return;
            const {
              body
            } = getDocument(contentElement);
            if (isRootDialog()) {
              body.setAttribute(attribute, contentId);
              return () => body.removeAttribute(attribute);
            }
            const observer = new MutationObserver(() => reactDomExports.flushSync(retry));
            observer.observe(body, {
              attributeFilter: [attribute]
            });
            return () => observer.disconnect();
          }, [updated, enabled, contentId, contentElement, isRootDialog, attribute]);
          return isRootDialog;
        }
        function getPaddingProperty(documentElement) {
          const documentLeft = documentElement.getBoundingClientRect().left;
          const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
          return scrollbarX ? "paddingLeft" : "paddingRight";
        }
        function usePreventBodyScroll(contentElement, contentId, enabled) {
          const isRootDialog = useRootDialog({
            attribute: "data-dialog-prevent-body-scroll",
            contentElement,
            contentId,
            enabled
          });
          reactExports.useEffect(() => {
            if (!isRootDialog()) return;
            if (!contentElement) return;
            const doc = getDocument(contentElement);
            const win = getWindow$2(contentElement);
            const {
              documentElement,
              body
            } = doc;
            const cssScrollbarWidth = documentElement.style.getPropertyValue("--scrollbar-width");
            const scrollbarWidth = cssScrollbarWidth ? Number.parseInt(cssScrollbarWidth) : win.innerWidth - documentElement.clientWidth;
            const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
            const paddingProperty = getPaddingProperty(documentElement);
            const setStyle = () => assignStyle(body, {
              overflow: "hidden",
              [paddingProperty]: `${scrollbarWidth}px`
            });
            const setIOSStyle = () => {
              var _a, _b;
              const {
                scrollX,
                scrollY,
                visualViewport
              } = win;
              const offsetLeft = (_a = visualViewport == null ? void 0 : visualViewport.offsetLeft) != null ? _a : 0;
              const offsetTop = (_b = visualViewport == null ? void 0 : visualViewport.offsetTop) != null ? _b : 0;
              const restoreStyle = assignStyle(body, {
                position: "fixed",
                overflow: "hidden",
                top: `${-(scrollY - Math.floor(offsetTop))}px`,
                left: `${-(scrollX - Math.floor(offsetLeft))}px`,
                right: "0",
                [paddingProperty]: `${scrollbarWidth}px`
              });
              return () => {
                restoreStyle();
                {
                  win.scrollTo({
                    left: scrollX,
                    top: scrollY,
                    behavior: "instant"
                  });
                }
              };
            };
            const isIOS = isApple() && !isMac();
            return chain$1(setScrollbarWidthProperty(), isIOS ? setIOSStyle() : setStyle());
          }, [isRootDialog, contentElement]);
        }

        // src/dialog/utils/is-focus-trap.ts
        function isFocusTrap(element, ...ids) {
          if (!element) return false;
          const attr = element.getAttribute("data-focus-trap");
          if (attr == null) return false;
          if (!ids.length) return true;
          if (attr === "") return false;
          return ids.some(id => attr === id);
        }

        // src/dialog/utils/supports-inert.ts
        function supportsInert() {
          return "inert" in HTMLElement.prototype;
        }

        // src/dialog/utils/disable-accessibility-tree-outside.ts
        function hideElementFromAccessibilityTree(element) {
          return setAttribute(element, "aria-hidden", "true");
        }
        function disableTree(element, ignoredElements) {
          if (!("style" in element)) return noop$8;
          if (supportsInert()) {
            return setProperty(element, "inert", true);
          }
          const tabbableElements = getAllTabbableIn(element, true);
          const enableElements = tabbableElements.map(element2 => {
            if (ignoredElements == null ? void 0 : ignoredElements.some(el => el && contains(el, element2))) return noop$8;
            const restoreFocusMethod = orchestrate(element2, "focus", () => {
              element2.focus = noop$8;
              return () => {
                delete element2.focus;
              };
            });
            return chain$1(setAttribute(element2, "tabindex", "-1"), restoreFocusMethod);
          });
          return chain$1(...enableElements, hideElementFromAccessibilityTree(element), assignStyle(element, {
            pointerEvents: "none",
            userSelect: "none",
            cursor: "default"
          }));
        }
        function disableTreeOutside(id, elements) {
          const cleanups = [];
          const ids = elements.map(el => el == null ? void 0 : el.id);
          walkTreeOutside(id, elements, element => {
            if (isBackdrop(element, ...ids)) return;
            if (isFocusTrap(element, ...ids)) return;
            cleanups.unshift(disableTree(element, elements));
          }, element => {
            if (!element.hasAttribute("role")) return;
            if (elements.some(el => el && contains(el, element))) return;
            cleanups.unshift(setAttribute(element, "role", "none"));
          });
          const restoreTreeOutside = () => {
            for (const cleanup of cleanups) {
              cleanup();
            }
          };
          return restoreTreeOutside;
        }

        // src/role/role.tsx
        var TagName$6 = "div";
        var elements = ["a", "button", "details", "dialog", "div", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "img", "input", "label", "li", "nav", "ol", "p", "section", "select", "span", "summary", "textarea", "ul", "svg"];
        createHook(function useRole2(props) {
          return props;
        });
        var Role = forwardRef2(
        // @ts-expect-error
        function Role2(props) {
          return createElement(TagName$6, props);
        });
        Object.assign(Role, elements.reduce((acc, element) => {
          acc[element] = forwardRef2(function Role3(props) {
            return createElement(element, props);
          });
          return acc;
        }, {}));
        function DialogBackdrop({
          store,
          backdrop,
          alwaysVisible,
          hidden
        }) {
          const ref = reactExports.useRef(null);
          const disclosure = useDisclosureStore({
            disclosure: store
          });
          const contentElement = useStoreState(store, "contentElement");
          reactExports.useEffect(() => {
            const backdrop2 = ref.current;
            const dialog = contentElement;
            if (!backdrop2) return;
            if (!dialog) return;
            backdrop2.style.zIndex = getComputedStyle(dialog).zIndex;
          }, [contentElement]);
          useSafeLayoutEffect(() => {
            const id = contentElement == null ? void 0 : contentElement.id;
            if (!id) return;
            const backdrop2 = ref.current;
            if (!backdrop2) return;
            return markAncestor(backdrop2, id);
          }, [contentElement]);
          const props = useDisclosureContent({
            ref,
            store: disclosure,
            role: "presentation",
            "data-backdrop": (contentElement == null ? void 0 : contentElement.id) || "",
            alwaysVisible,
            hidden: hidden != null ? hidden : void 0,
            style: {
              position: "fixed",
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
            }
          });
          if (!backdrop) return null;
          if (reactExports.isValidElement(backdrop)) {
            return /* @__PURE__ */jsxRuntimeExports.jsx(Role, __spreadProps$1(__spreadValues$1({}, props), {
              render: backdrop
            }));
          }
          const Component = typeof backdrop !== "boolean" ? backdrop : "div";
          return /* @__PURE__ */jsxRuntimeExports.jsx(Role, __spreadProps$1(__spreadValues$1({}, props), {
            render: /* @__PURE__ */jsxRuntimeExports.jsx(Component, {})
          }));
        }
        var TagName$5 = "div";
        var isSafariBrowser = isSafari();
        function isAlreadyFocusingAnotherElement(dialog) {
          const activeElement = getActiveElement();
          if (!activeElement) return false;
          if (dialog && contains(dialog, activeElement)) return false;
          if (isFocusable(activeElement)) return true;
          return false;
        }
        function getElementFromProp(prop, focusable = false) {
          if (!prop) return null;
          const element = "current" in prop ? prop.current : prop;
          if (!element) return null;
          if (focusable) return isFocusable(element) ? element : null;
          return element;
        }
        var useDialog = createHook(function useDialog2(_a) {
          var _b = _a,
            {
              store: storeProp,
              open: openProp,
              onClose,
              focusable = true,
              modal = true,
              portal = !!modal,
              backdrop = !!modal,
              hideOnEscape = true,
              hideOnInteractOutside = true,
              getPersistentElements,
              preventBodyScroll = !!modal,
              autoFocusOnShow = true,
              autoFocusOnHide = true,
              initialFocus,
              finalFocus,
              unmountOnHide,
              unstable_treeSnapshotKey
            } = _b,
            props = __objRest$1(_b, ["store", "open", "onClose", "focusable", "modal", "portal", "backdrop", "hideOnEscape", "hideOnInteractOutside", "getPersistentElements", "preventBodyScroll", "autoFocusOnShow", "autoFocusOnHide", "initialFocus", "finalFocus", "unmountOnHide", "unstable_treeSnapshotKey"]);
          const context = useDialogProviderContext();
          const ref = reactExports.useRef(null);
          const store = useDialogStore({
            store: storeProp || context,
            open: openProp,
            setOpen(open2) {
              if (open2) return;
              const dialog = ref.current;
              if (!dialog) return;
              const event = new Event("close", {
                bubbles: false,
                cancelable: true
              });
              if (onClose) {
                dialog.addEventListener("close", onClose, {
                  once: true
                });
              }
              dialog.dispatchEvent(event);
              if (!event.defaultPrevented) return;
              store.setOpen(true);
            }
          });
          const {
            portalRef,
            domReady
          } = usePortalRef(portal, props.portalRef);
          const preserveTabOrderProp = props.preserveTabOrder;
          const preserveTabOrder = useStoreState(store, state => preserveTabOrderProp && !modal && state.mounted);
          const id = useId(props.id);
          const open = useStoreState(store, "open");
          const mounted = useStoreState(store, "mounted");
          const contentElement = useStoreState(store, "contentElement");
          const hidden = isHidden(mounted, props.hidden, props.alwaysVisible);
          usePreventBodyScroll(contentElement, id, preventBodyScroll && !hidden);
          useHideOnInteractOutside(store, hideOnInteractOutside, domReady);
          const {
            wrapElement,
            nestedDialogs
          } = useNestedDialogs(store);
          props = useWrapElement(props, wrapElement, [wrapElement]);
          useSafeLayoutEffect(() => {
            if (!open) return;
            const dialog = ref.current;
            const activeElement = getActiveElement(dialog, true);
            if (!activeElement) return;
            if (activeElement.tagName === "BODY") return;
            if (dialog && contains(dialog, activeElement)) return;
            store.setDisclosureElement(activeElement);
          }, [store, open]);
          if (isSafariBrowser) {
            reactExports.useEffect(() => {
              if (!mounted) return;
              const {
                disclosureElement
              } = store.getState();
              if (!disclosureElement) return;
              if (!isButton(disclosureElement)) return;
              const onMouseDown = () => {
                let receivedFocus = false;
                const onFocus = () => {
                  receivedFocus = true;
                };
                const options = {
                  capture: true,
                  once: true
                };
                disclosureElement.addEventListener("focusin", onFocus, options);
                queueBeforeEvent(disclosureElement, "mouseup", () => {
                  disclosureElement.removeEventListener("focusin", onFocus, true);
                  if (receivedFocus) return;
                  focusIfNeeded(disclosureElement);
                });
              };
              disclosureElement.addEventListener("mousedown", onMouseDown);
              return () => {
                disclosureElement.removeEventListener("mousedown", onMouseDown);
              };
            }, [store, mounted]);
          }
          reactExports.useEffect(() => {
            if (!mounted) return;
            if (!domReady) return;
            const dialog = ref.current;
            if (!dialog) return;
            const win = getWindow$2(dialog);
            const viewport = win.visualViewport || win;
            const setViewportHeight = () => {
              var _a2, _b2;
              const height = (_b2 = (_a2 = win.visualViewport) == null ? void 0 : _a2.height) != null ? _b2 : win.innerHeight;
              dialog.style.setProperty("--dialog-viewport-height", `${height}px`);
            };
            setViewportHeight();
            viewport.addEventListener("resize", setViewportHeight);
            return () => {
              viewport.removeEventListener("resize", setViewportHeight);
            };
          }, [mounted, domReady]);
          reactExports.useEffect(() => {
            if (!modal) return;
            if (!mounted) return;
            if (!domReady) return;
            const dialog = ref.current;
            if (!dialog) return;
            const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
            if (existingDismiss) return;
            return prependHiddenDismiss(dialog, store.hide);
          }, [store, modal, mounted, domReady]);
          useSafeLayoutEffect(() => {
            if (!supportsInert()) return;
            if (open) return;
            if (!mounted) return;
            if (!domReady) return;
            const dialog = ref.current;
            if (!dialog) return;
            return disableTree(dialog);
          }, [open, mounted, domReady]);
          const canTakeTreeSnapshot = open && domReady;
          useSafeLayoutEffect(() => {
            if (!id) return;
            if (!canTakeTreeSnapshot) return;
            const dialog = ref.current;
            return createWalkTreeSnapshot(id, [dialog]);
          }, [id, canTakeTreeSnapshot, unstable_treeSnapshotKey]);
          const getPersistentElementsProp = useEvent$1(getPersistentElements);
          useSafeLayoutEffect(() => {
            if (!id) return;
            if (!canTakeTreeSnapshot) return;
            const {
              disclosureElement
            } = store.getState();
            const dialog = ref.current;
            const persistentElements = getPersistentElementsProp() || [];
            const allElements = [dialog, ...persistentElements, ...nestedDialogs.map(dialog2 => dialog2.getState().contentElement)];
            if (modal) {
              return chain$1(markTreeOutside(id, allElements), disableTreeOutside(id, allElements));
            }
            return markTreeOutside(id, [disclosureElement, ...allElements]);
          }, [id, store, canTakeTreeSnapshot, getPersistentElementsProp, nestedDialogs, modal, unstable_treeSnapshotKey]);
          const mayAutoFocusOnShow = !!autoFocusOnShow;
          const autoFocusOnShowProp = useBooleanEvent(autoFocusOnShow);
          const [autoFocusEnabled, setAutoFocusEnabled] = reactExports.useState(false);
          reactExports.useEffect(() => {
            if (!open) return;
            if (!mayAutoFocusOnShow) return;
            if (!domReady) return;
            if (!(contentElement == null ? void 0 : contentElement.isConnected)) return;
            const element = getElementFromProp(initialFocus, true) ||
            // If no initial focus is specified, we try to focus the first element
            // with the autofocus attribute. If it's an Ariakit component, the
            // Focusable component will consume the autoFocus prop and add the
            // data-autofocus attribute to the element instead.
            contentElement.querySelector("[data-autofocus=true],[autofocus]") ||
            // We have to fallback to the first focusable element otherwise portaled
            // dialogs with preserveTabOrder set to true will not receive focus
            // properly because the elements aren't tabbable until the dialog receives
            // focus.
            getFirstTabbableIn(contentElement, true, portal && preserveTabOrder) ||
            // Finally, we fallback to the dialog element itself.
            contentElement;
            const isElementFocusable = isFocusable(element);
            if (!autoFocusOnShowProp(isElementFocusable ? element : null)) return;
            setAutoFocusEnabled(true);
            queueMicrotask(() => {
              element.focus();
              if (!isSafariBrowser) return;
              if (!isElementFocusable) return;
              element.scrollIntoView({
                block: "nearest",
                inline: "nearest"
              });
            });
          }, [open, mayAutoFocusOnShow, domReady, contentElement, initialFocus, portal, preserveTabOrder, autoFocusOnShowProp]);
          const mayAutoFocusOnHide = !!autoFocusOnHide;
          const autoFocusOnHideProp = useBooleanEvent(autoFocusOnHide);
          const [hasOpened, setHasOpened] = reactExports.useState(false);
          reactExports.useEffect(() => {
            if (!open) return;
            setHasOpened(true);
            return () => setHasOpened(false);
          }, [open]);
          const focusOnHide = reactExports.useCallback((dialog, retry = true) => {
            const {
              disclosureElement
            } = store.getState();
            if (isAlreadyFocusingAnotherElement(dialog)) return;
            let element = getElementFromProp(finalFocus) || disclosureElement;
            if (element == null ? void 0 : element.id) {
              const doc = getDocument(element);
              const selector = `[aria-activedescendant="${element.id}"]`;
              const composite = doc.querySelector(selector);
              if (composite) {
                element = composite;
              }
            }
            if (element && !isFocusable(element)) {
              const maybeParentDialog = element.closest("[data-dialog]");
              if (maybeParentDialog == null ? void 0 : maybeParentDialog.id) {
                const doc = getDocument(maybeParentDialog);
                const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
                const control = doc.querySelector(selector);
                if (control) {
                  element = control;
                }
              }
            }
            const isElementFocusable = element && isFocusable(element);
            if (!isElementFocusable && retry) {
              requestAnimationFrame(() => focusOnHide(dialog, false));
              return;
            }
            if (!autoFocusOnHideProp(isElementFocusable ? element : null)) return;
            if (!isElementFocusable) return;
            element == null ? void 0 : element.focus({
              preventScroll: true
            });
          }, [store, finalFocus, autoFocusOnHideProp]);
          const focusedOnHideRef = reactExports.useRef(false);
          useSafeLayoutEffect(() => {
            if (open) return;
            if (!hasOpened) return;
            if (!mayAutoFocusOnHide) return;
            const dialog = ref.current;
            focusedOnHideRef.current = true;
            focusOnHide(dialog);
          }, [open, hasOpened, domReady, mayAutoFocusOnHide, focusOnHide]);
          reactExports.useEffect(() => {
            if (!hasOpened) return;
            if (!mayAutoFocusOnHide) return;
            const dialog = ref.current;
            return () => {
              if (focusedOnHideRef.current) {
                focusedOnHideRef.current = false;
                return;
              }
              focusOnHide(dialog);
            };
          }, [hasOpened, mayAutoFocusOnHide, focusOnHide]);
          const hideOnEscapeProp = useBooleanEvent(hideOnEscape);
          reactExports.useEffect(() => {
            if (!domReady) return;
            if (!mounted) return;
            const onKeyDown = event => {
              if (event.key !== "Escape") return;
              if (event.defaultPrevented) return;
              const dialog = ref.current;
              if (!dialog) return;
              if (isElementMarked(dialog)) return;
              const target = event.target;
              if (!target) return;
              const {
                disclosureElement
              } = store.getState();
              const isValidTarget = () => {
                if (target.tagName === "BODY") return true;
                if (contains(dialog, target)) return true;
                if (!disclosureElement) return true;
                if (contains(disclosureElement, target)) return true;
                return false;
              };
              if (!isValidTarget()) return;
              if (!hideOnEscapeProp(event)) return;
              store.hide();
            };
            return addGlobalEventListener("keydown", onKeyDown, true);
          }, [store, domReady, mounted, hideOnEscapeProp]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(HeadingLevel, {
            level: modal ? 1 : void 0,
            children: element
          }), [modal]);
          const hiddenProp = props.hidden;
          const alwaysVisible = props.alwaysVisible;
          props = useWrapElement(props, element => {
            if (!backdrop) return element;
            return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(DialogBackdrop, {
                store,
                backdrop,
                hidden: hiddenProp,
                alwaysVisible
              }), element]
            });
          }, [store, backdrop, hiddenProp, alwaysVisible]);
          const [headingId, setHeadingId] = reactExports.useState();
          const [descriptionId, setDescriptionId] = reactExports.useState();
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(DialogScopedContextProvider, {
            value: store,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(DialogHeadingContext.Provider, {
              value: setHeadingId,
              children: /* @__PURE__ */jsxRuntimeExports.jsx(DialogDescriptionContext.Provider, {
                value: setDescriptionId,
                children: element
              })
            })
          }), [store]);
          props = __spreadProps$1(__spreadValues$1({
            id,
            "data-dialog": "",
            role: "dialog",
            tabIndex: focusable ? -1 : void 0,
            "aria-labelledby": headingId,
            "aria-describedby": descriptionId
          }, props), {
            ref: useMergeRefs(ref, props.ref)
          });
          props = useFocusableContainer(__spreadProps$1(__spreadValues$1({}, props), {
            autoFocusOnShow: autoFocusEnabled
          }));
          props = useDisclosureContent(__spreadValues$1({
            store
          }, props));
          props = useFocusable(__spreadProps$1(__spreadValues$1({}, props), {
            focusable
          }));
          props = usePortal(__spreadProps$1(__spreadValues$1({
            portal
          }, props), {
            portalRef,
            preserveTabOrder
          }));
          return props;
        });
        function createDialogComponent(Component, useProviderContext = useDialogProviderContext) {
          return forwardRef2(function DialogComponent(props) {
            const context = useProviderContext();
            const store = props.store || context;
            const mounted = useStoreState(store, state => !props.unmountOnHide || (state == null ? void 0 : state.mounted) || !!props.open);
            if (!mounted) return null;
            return /* @__PURE__ */jsxRuntimeExports.jsx(Component, __spreadValues$1({}, props));
          });
        }
        createDialogComponent(forwardRef2(function Dialog2(props) {
          const htmlProps = useDialog(props);
          return createElement(TagName$5, htmlProps);
        }), useDialogProviderContext);

        /**
         * Custom positioning reference element.
         * @see https://floating-ui.com/docs/virtual-elements
         */

        const min = Math.min;
        const max = Math.max;
        const round = Math.round;
        const floor = Math.floor;
        const createCoords = v => ({
          x: v,
          y: v
        });
        const oppositeSideMap = {
          left: 'right',
          right: 'left',
          bottom: 'top',
          top: 'bottom'
        };
        const oppositeAlignmentMap = {
          start: 'end',
          end: 'start'
        };
        function clamp$2(start, value, end) {
          return max(start, min(value, end));
        }
        function evaluate(value, param) {
          return typeof value === 'function' ? value(param) : value;
        }
        function getSide(placement) {
          return placement.split('-')[0];
        }
        function getAlignment(placement) {
          return placement.split('-')[1];
        }
        function getOppositeAxis(axis) {
          return axis === 'x' ? 'y' : 'x';
        }
        function getAxisLength(axis) {
          return axis === 'y' ? 'height' : 'width';
        }
        const yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);
        function getSideAxis(placement) {
          return yAxisSides.has(getSide(placement)) ? 'y' : 'x';
        }
        function getAlignmentAxis(placement) {
          return getOppositeAxis(getSideAxis(placement));
        }
        function getAlignmentSides(placement, rects, rtl) {
          if (rtl === void 0) {
            rtl = false;
          }
          const alignment = getAlignment(placement);
          const alignmentAxis = getAlignmentAxis(placement);
          const length = getAxisLength(alignmentAxis);
          let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
          if (rects.reference[length] > rects.floating[length]) {
            mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
          }
          return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
        }
        function getExpandedPlacements(placement) {
          const oppositePlacement = getOppositePlacement(placement);
          return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
        }
        function getOppositeAlignmentPlacement(placement) {
          return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
        }
        const lrPlacement = ['left', 'right'];
        const rlPlacement = ['right', 'left'];
        const tbPlacement = ['top', 'bottom'];
        const btPlacement = ['bottom', 'top'];
        function getSideList(side, isStart, rtl) {
          switch (side) {
            case 'top':
            case 'bottom':
              if (rtl) return isStart ? rlPlacement : lrPlacement;
              return isStart ? lrPlacement : rlPlacement;
            case 'left':
            case 'right':
              return isStart ? tbPlacement : btPlacement;
            default:
              return [];
          }
        }
        function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
          const alignment = getAlignment(placement);
          let list = getSideList(getSide(placement), direction === 'start', rtl);
          if (alignment) {
            list = list.map(side => side + "-" + alignment);
            if (flipAlignment) {
              list = list.concat(list.map(getOppositeAlignmentPlacement));
            }
          }
          return list;
        }
        function getOppositePlacement(placement) {
          return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
        }
        function expandPaddingObject(padding) {
          return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...padding
          };
        }
        function getPaddingObject(padding) {
          return typeof padding !== 'number' ? expandPaddingObject(padding) : {
            top: padding,
            right: padding,
            bottom: padding,
            left: padding
          };
        }
        function rectToClientRect(rect) {
          const {
            x,
            y,
            width,
            height
          } = rect;
          return {
            width,
            height,
            top: y,
            left: x,
            right: x + width,
            bottom: y + height,
            x,
            y
          };
        }
        function computeCoordsFromPlacement(_ref, placement, rtl) {
          let {
            reference,
            floating
          } = _ref;
          const sideAxis = getSideAxis(placement);
          const alignmentAxis = getAlignmentAxis(placement);
          const alignLength = getAxisLength(alignmentAxis);
          const side = getSide(placement);
          const isVertical = sideAxis === 'y';
          const commonX = reference.x + reference.width / 2 - floating.width / 2;
          const commonY = reference.y + reference.height / 2 - floating.height / 2;
          const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
          let coords;
          switch (side) {
            case 'top':
              coords = {
                x: commonX,
                y: reference.y - floating.height
              };
              break;
            case 'bottom':
              coords = {
                x: commonX,
                y: reference.y + reference.height
              };
              break;
            case 'right':
              coords = {
                x: reference.x + reference.width,
                y: commonY
              };
              break;
            case 'left':
              coords = {
                x: reference.x - floating.width,
                y: commonY
              };
              break;
            default:
              coords = {
                x: reference.x,
                y: reference.y
              };
          }
          switch (getAlignment(placement)) {
            case 'start':
              coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
              break;
            case 'end':
              coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
              break;
          }
          return coords;
        }

        /**
         * Computes the `x` and `y` coordinates that will place the floating element
         * next to a given reference element.
         *
         * This export does not have any `platform` interface logic. You will need to
         * write one for the platform you are using Floating UI with.
         */
        const computePosition$1 = async (reference, floating, config) => {
          const {
            placement = 'bottom',
            strategy = 'absolute',
            middleware = [],
            platform
          } = config;
          const validMiddleware = middleware.filter(Boolean);
          const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
          let rects = await platform.getElementRects({
            reference,
            floating,
            strategy
          });
          let {
            x,
            y
          } = computeCoordsFromPlacement(rects, placement, rtl);
          let statefulPlacement = placement;
          let middlewareData = {};
          let resetCount = 0;
          for (let i = 0; i < validMiddleware.length; i++) {
            const {
              name,
              fn
            } = validMiddleware[i];
            const {
              x: nextX,
              y: nextY,
              data,
              reset
            } = await fn({
              x,
              y,
              initialPlacement: placement,
              placement: statefulPlacement,
              strategy,
              middlewareData,
              rects,
              platform,
              elements: {
                reference,
                floating
              }
            });
            x = nextX != null ? nextX : x;
            y = nextY != null ? nextY : y;
            middlewareData = {
              ...middlewareData,
              [name]: {
                ...middlewareData[name],
                ...data
              }
            };
            if (reset && resetCount <= 50) {
              resetCount++;
              if (typeof reset === 'object') {
                if (reset.placement) {
                  statefulPlacement = reset.placement;
                }
                if (reset.rects) {
                  rects = reset.rects === true ? await platform.getElementRects({
                    reference,
                    floating,
                    strategy
                  }) : reset.rects;
                }
                ({
                  x,
                  y
                } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
              }
              i = -1;
            }
          }
          return {
            x,
            y,
            placement: statefulPlacement,
            strategy,
            middlewareData
          };
        };

        /**
         * Resolves with an object of overflow side offsets that determine how much the
         * element is overflowing a given clipping boundary on each side.
         * - positive = overflowing the boundary by that number of pixels
         * - negative = how many pixels left before it will overflow
         * - 0 = lies flush with the boundary
         * @see https://floating-ui.com/docs/detectOverflow
         */
        async function detectOverflow(state, options) {
          var _await$platform$isEle;
          if (options === void 0) {
            options = {};
          }
          const {
            x,
            y,
            platform,
            rects,
            elements,
            strategy
          } = state;
          const {
            boundary = 'clippingAncestors',
            rootBoundary = 'viewport',
            elementContext = 'floating',
            altBoundary = false,
            padding = 0
          } = evaluate(options, state);
          const paddingObject = getPaddingObject(padding);
          const altContext = elementContext === 'floating' ? 'reference' : 'floating';
          const element = elements[altBoundary ? altContext : elementContext];
          const clippingClientRect = rectToClientRect(await platform.getClippingRect({
            element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
            boundary,
            rootBoundary,
            strategy
          }));
          const rect = elementContext === 'floating' ? {
            x,
            y,
            width: rects.floating.width,
            height: rects.floating.height
          } : rects.reference;
          const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
          const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
            x: 1,
            y: 1
          } : {
            x: 1,
            y: 1
          };
          const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements,
            rect,
            offsetParent,
            strategy
          }) : rect);
          return {
            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
          };
        }

        /**
         * Provides data to position an inner element of the floating element so that it
         * appears centered to the reference element.
         * @see https://floating-ui.com/docs/arrow
         */
        const arrow$1 = options => ({
          name: 'arrow',
          options,
          async fn(state) {
            const {
              x,
              y,
              placement,
              rects,
              platform,
              elements,
              middlewareData
            } = state;
            // Since `element` is required, we don't Partial<> the type.
            const {
              element,
              padding = 0
            } = evaluate(options, state) || {};
            if (element == null) {
              return {};
            }
            const paddingObject = getPaddingObject(padding);
            const coords = {
              x,
              y
            };
            const axis = getAlignmentAxis(placement);
            const length = getAxisLength(axis);
            const arrowDimensions = await platform.getDimensions(element);
            const isYAxis = axis === 'y';
            const minProp = isYAxis ? 'top' : 'left';
            const maxProp = isYAxis ? 'bottom' : 'right';
            const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
            const startDiff = coords[axis] - rects.reference[axis];
            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

            // DOM platform can return `window` as the `offsetParent`.
            if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
              clientSize = elements.floating[clientProp] || rects.floating[length];
            }
            const centerToReference = endDiff / 2 - startDiff / 2;

            // If the padding is large enough that it causes the arrow to no longer be
            // centered, modify the padding so that it is centered.
            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
            const minPadding = min(paddingObject[minProp], largestPossiblePadding);
            const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

            // Make sure the arrow doesn't overflow the floating element if the center
            // point is outside the floating element's bounds.
            const min$1 = minPadding;
            const max = clientSize - arrowDimensions[length] - maxPadding;
            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
            const offset = clamp$2(min$1, center, max);

            // If the reference is small enough that the arrow's padding causes it to
            // to point to nothing for an aligned placement, adjust the offset of the
            // floating element itself. To ensure `shift()` continues to take action,
            // a single reset is performed when this is true.
            const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
            return {
              [axis]: coords[axis] + alignmentOffset,
              data: {
                [axis]: offset,
                centerOffset: center - offset - alignmentOffset,
                ...(shouldAddOffset && {
                  alignmentOffset
                })
              },
              reset: shouldAddOffset
            };
          }
        });

        /**
         * Optimizes the visibility of the floating element by flipping the `placement`
         * in order to keep it in view when the preferred placement(s) will overflow the
         * clipping boundary. Alternative to `autoPlacement`.
         * @see https://floating-ui.com/docs/flip
         */
        const flip$1 = function (options) {
          if (options === void 0) {
            options = {};
          }
          return {
            name: 'flip',
            options,
            async fn(state) {
              var _middlewareData$arrow, _middlewareData$flip;
              const {
                placement,
                middlewareData,
                rects,
                initialPlacement,
                platform,
                elements
              } = state;
              const {
                mainAxis: checkMainAxis = true,
                crossAxis: checkCrossAxis = true,
                fallbackPlacements: specifiedFallbackPlacements,
                fallbackStrategy = 'bestFit',
                fallbackAxisSideDirection = 'none',
                flipAlignment = true,
                ...detectOverflowOptions
              } = evaluate(options, state);

              // If a reset by the arrow was caused due to an alignment offset being
              // added, we should skip any logic now since `flip()` has already done its
              // work.
              // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
              if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
              }
              const side = getSide(placement);
              const initialSideAxis = getSideAxis(initialPlacement);
              const isBasePlacement = getSide(initialPlacement) === initialPlacement;
              const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
              const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
              const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
              if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
                fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
              }
              const placements = [initialPlacement, ...fallbackPlacements];
              const overflow = await detectOverflow(state, detectOverflowOptions);
              const overflows = [];
              let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
              if (checkMainAxis) {
                overflows.push(overflow[side]);
              }
              if (checkCrossAxis) {
                const sides = getAlignmentSides(placement, rects, rtl);
                overflows.push(overflow[sides[0]], overflow[sides[1]]);
              }
              overflowsData = [...overflowsData, {
                placement,
                overflows
              }];

              // One or more sides is overflowing.
              if (!overflows.every(side => side <= 0)) {
                var _middlewareData$flip2, _overflowsData$filter;
                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                const nextPlacement = placements[nextIndex];
                if (nextPlacement) {
                  const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;
                  if (!ignoreCrossAxisOverflow ||
                  // We leave the current main axis only if every placement on that axis
                  // overflows the main axis.
                  overflowsData.every(d => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
                    // Try next placement and re-run the lifecycle.
                    return {
                      data: {
                        index: nextIndex,
                        overflows: overflowsData
                      },
                      reset: {
                        placement: nextPlacement
                      }
                    };
                  }
                }

                // First, find the candidates that fit on the mainAxis side of overflow,
                // then find the placement that fits the best on the main crossAxis side.
                let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

                // Otherwise fallback.
                if (!resetPlacement) {
                  switch (fallbackStrategy) {
                    case 'bestFit':
                      {
                        var _overflowsData$filter2;
                        const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                          if (hasFallbackAxisSideDirection) {
                            const currentSideAxis = getSideAxis(d.placement);
                            return currentSideAxis === initialSideAxis ||
                            // Create a bias to the `y` side axis due to horizontal
                            // reading directions favoring greater width.
                            currentSideAxis === 'y';
                          }
                          return true;
                        }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                        if (placement) {
                          resetPlacement = placement;
                        }
                        break;
                      }
                    case 'initialPlacement':
                      resetPlacement = initialPlacement;
                      break;
                  }
                }
                if (placement !== resetPlacement) {
                  return {
                    reset: {
                      placement: resetPlacement
                    }
                  };
                }
              }
              return {};
            }
          };
        };
        const originSides = /*#__PURE__*/new Set(['left', 'top']);

        // For type backwards-compatibility, the `OffsetOptions` type was also
        // Derivable.

        async function convertValueToCoords(state, options) {
          const {
            placement,
            platform,
            elements
          } = state;
          const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isVertical = getSideAxis(placement) === 'y';
          const mainAxisMulti = originSides.has(side) ? -1 : 1;
          const crossAxisMulti = rtl && isVertical ? -1 : 1;
          const rawValue = evaluate(options, state);

          // eslint-disable-next-line prefer-const
          let {
            mainAxis,
            crossAxis,
            alignmentAxis
          } = typeof rawValue === 'number' ? {
            mainAxis: rawValue,
            crossAxis: 0,
            alignmentAxis: null
          } : {
            mainAxis: rawValue.mainAxis || 0,
            crossAxis: rawValue.crossAxis || 0,
            alignmentAxis: rawValue.alignmentAxis
          };
          if (alignment && typeof alignmentAxis === 'number') {
            crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
          }
          return isVertical ? {
            x: crossAxis * crossAxisMulti,
            y: mainAxis * mainAxisMulti
          } : {
            x: mainAxis * mainAxisMulti,
            y: crossAxis * crossAxisMulti
          };
        }

        /**
         * Modifies the placement by translating the floating element along the
         * specified axes.
         * A number (shorthand for `mainAxis` or distance), or an axes configuration
         * object may be passed.
         * @see https://floating-ui.com/docs/offset
         */
        const offset$1 = function (options) {
          if (options === void 0) {
            options = 0;
          }
          return {
            name: 'offset',
            options,
            async fn(state) {
              var _middlewareData$offse, _middlewareData$arrow;
              const {
                x,
                y,
                placement,
                middlewareData
              } = state;
              const diffCoords = await convertValueToCoords(state, options);

              // If the placement is the same and the arrow caused an alignment offset
              // then we don't need to change the positioning coordinates.
              if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return {};
              }
              return {
                x: x + diffCoords.x,
                y: y + diffCoords.y,
                data: {
                  ...diffCoords,
                  placement
                }
              };
            }
          };
        };

        /**
         * Optimizes the visibility of the floating element by shifting it in order to
         * keep it in view when it will overflow the clipping boundary.
         * @see https://floating-ui.com/docs/shift
         */
        const shift$1 = function (options) {
          if (options === void 0) {
            options = {};
          }
          return {
            name: 'shift',
            options,
            async fn(state) {
              const {
                x,
                y,
                placement
              } = state;
              const {
                mainAxis: checkMainAxis = true,
                crossAxis: checkCrossAxis = false,
                limiter = {
                  fn: _ref => {
                    let {
                      x,
                      y
                    } = _ref;
                    return {
                      x,
                      y
                    };
                  }
                },
                ...detectOverflowOptions
              } = evaluate(options, state);
              const coords = {
                x,
                y
              };
              const overflow = await detectOverflow(state, detectOverflowOptions);
              const crossAxis = getSideAxis(getSide(placement));
              const mainAxis = getOppositeAxis(crossAxis);
              let mainAxisCoord = coords[mainAxis];
              let crossAxisCoord = coords[crossAxis];
              if (checkMainAxis) {
                const minSide = mainAxis === 'y' ? 'top' : 'left';
                const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
                const min = mainAxisCoord + overflow[minSide];
                const max = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = clamp$2(min, mainAxisCoord, max);
              }
              if (checkCrossAxis) {
                const minSide = crossAxis === 'y' ? 'top' : 'left';
                const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
                const min = crossAxisCoord + overflow[minSide];
                const max = crossAxisCoord - overflow[maxSide];
                crossAxisCoord = clamp$2(min, crossAxisCoord, max);
              }
              const limitedCoords = limiter.fn({
                ...state,
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
              });
              return {
                ...limitedCoords,
                data: {
                  x: limitedCoords.x - x,
                  y: limitedCoords.y - y,
                  enabled: {
                    [mainAxis]: checkMainAxis,
                    [crossAxis]: checkCrossAxis
                  }
                }
              };
            }
          };
        };
        /**
         * Built-in `limiter` that will stop `shift()` at a certain point.
         */
        const limitShift$1 = function (options) {
          if (options === void 0) {
            options = {};
          }
          return {
            options,
            fn(state) {
              const {
                x,
                y,
                placement,
                rects,
                middlewareData
              } = state;
              const {
                offset = 0,
                mainAxis: checkMainAxis = true,
                crossAxis: checkCrossAxis = true
              } = evaluate(options, state);
              const coords = {
                x,
                y
              };
              const crossAxis = getSideAxis(placement);
              const mainAxis = getOppositeAxis(crossAxis);
              let mainAxisCoord = coords[mainAxis];
              let crossAxisCoord = coords[crossAxis];
              const rawOffset = evaluate(offset, state);
              const computedOffset = typeof rawOffset === 'number' ? {
                mainAxis: rawOffset,
                crossAxis: 0
              } : {
                mainAxis: 0,
                crossAxis: 0,
                ...rawOffset
              };
              if (checkMainAxis) {
                const len = mainAxis === 'y' ? 'height' : 'width';
                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
                if (mainAxisCoord < limitMin) {
                  mainAxisCoord = limitMin;
                } else if (mainAxisCoord > limitMax) {
                  mainAxisCoord = limitMax;
                }
              }
              if (checkCrossAxis) {
                var _middlewareData$offse, _middlewareData$offse2;
                const len = mainAxis === 'y' ? 'width' : 'height';
                const isOriginSide = originSides.has(getSide(placement));
                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
                if (crossAxisCoord < limitMin) {
                  crossAxisCoord = limitMin;
                } else if (crossAxisCoord > limitMax) {
                  crossAxisCoord = limitMax;
                }
              }
              return {
                [mainAxis]: mainAxisCoord,
                [crossAxis]: crossAxisCoord
              };
            }
          };
        };

        /**
         * Provides data that allows you to change the size of the floating element —
         * for instance, prevent it from overflowing the clipping boundary or match the
         * width of the reference element.
         * @see https://floating-ui.com/docs/size
         */
        const size$1 = function (options) {
          if (options === void 0) {
            options = {};
          }
          return {
            name: 'size',
            options,
            async fn(state) {
              var _state$middlewareData, _state$middlewareData2;
              const {
                placement,
                rects,
                platform,
                elements
              } = state;
              const {
                apply = () => {},
                ...detectOverflowOptions
              } = evaluate(options, state);
              const overflow = await detectOverflow(state, detectOverflowOptions);
              const side = getSide(placement);
              const alignment = getAlignment(placement);
              const isYAxis = getSideAxis(placement) === 'y';
              const {
                width,
                height
              } = rects.floating;
              let heightSide;
              let widthSide;
              if (side === 'top' || side === 'bottom') {
                heightSide = side;
                widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
              } else {
                widthSide = side;
                heightSide = alignment === 'end' ? 'top' : 'bottom';
              }
              const maximumClippingHeight = height - overflow.top - overflow.bottom;
              const maximumClippingWidth = width - overflow.left - overflow.right;
              const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
              const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
              const noShift = !state.middlewareData.shift;
              let availableHeight = overflowAvailableHeight;
              let availableWidth = overflowAvailableWidth;
              if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
                availableWidth = maximumClippingWidth;
              }
              if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
                availableHeight = maximumClippingHeight;
              }
              if (noShift && !alignment) {
                const xMin = max(overflow.left, 0);
                const xMax = max(overflow.right, 0);
                const yMin = max(overflow.top, 0);
                const yMax = max(overflow.bottom, 0);
                if (isYAxis) {
                  availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
                } else {
                  availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
                }
              }
              await apply({
                ...state,
                availableWidth,
                availableHeight
              });
              const nextDimensions = await platform.getDimensions(elements.floating);
              if (width !== nextDimensions.width || height !== nextDimensions.height) {
                return {
                  reset: {
                    rects: true
                  }
                };
              }
              return {};
            }
          };
        };
        function hasWindow() {
          return typeof window !== 'undefined';
        }
        function getNodeName(node) {
          if (isNode$1(node)) {
            return (node.nodeName || '').toLowerCase();
          }
          // Mocked nodes in testing environments may not be instances of Node. By
          // returning `#document` an infinite loop won't occur.
          // https://github.com/floating-ui/floating-ui/issues/2317
          return '#document';
        }
        function getWindow$1(node) {
          var _node$ownerDocument;
          return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
        }
        function getDocumentElement(node) {
          var _ref;
          return (_ref = (isNode$1(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
        }
        function isNode$1(value) {
          if (!hasWindow()) {
            return false;
          }
          return value instanceof Node || value instanceof getWindow$1(value).Node;
        }
        function isElement(value) {
          if (!hasWindow()) {
            return false;
          }
          return value instanceof Element || value instanceof getWindow$1(value).Element;
        }
        function isHTMLElement$1(value) {
          if (!hasWindow()) {
            return false;
          }
          return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
        }
        function isShadowRoot(value) {
          if (!hasWindow() || typeof ShadowRoot === 'undefined') {
            return false;
          }
          return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
        }
        const invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);
        function isOverflowElement(element) {
          const {
            overflow,
            overflowX,
            overflowY,
            display
          } = getComputedStyle$1(element);
          return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
        }
        const tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);
        function isTableElement(element) {
          return tableElements.has(getNodeName(element));
        }
        const topLayerSelectors = [':popover-open', ':modal'];
        function isTopLayer(element) {
          return topLayerSelectors.some(selector => {
            try {
              return element.matches(selector);
            } catch (_e) {
              return false;
            }
          });
        }
        const transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];
        const willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];
        const containValues = ['paint', 'layout', 'strict', 'content'];
        function isContainingBlock(elementOrCss) {
          const webkit = isWebKit();
          const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;

          // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
          // https://drafts.csswg.org/css-transforms-2/#individual-transforms
          return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));
        }
        function getContainingBlock(element) {
          let currentNode = getParentNode(element);
          while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
            if (isContainingBlock(currentNode)) {
              return currentNode;
            } else if (isTopLayer(currentNode)) {
              return null;
            }
            currentNode = getParentNode(currentNode);
          }
          return null;
        }
        function isWebKit() {
          if (typeof CSS === 'undefined' || !CSS.supports) return false;
          return CSS.supports('-webkit-backdrop-filter', 'none');
        }
        const lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);
        function isLastTraversableNode(node) {
          return lastTraversableNodeNames.has(getNodeName(node));
        }
        function getComputedStyle$1(element) {
          return getWindow$1(element).getComputedStyle(element);
        }
        function getNodeScroll(element) {
          if (isElement(element)) {
            return {
              scrollLeft: element.scrollLeft,
              scrollTop: element.scrollTop
            };
          }
          return {
            scrollLeft: element.scrollX,
            scrollTop: element.scrollY
          };
        }
        function getParentNode(node) {
          if (getNodeName(node) === 'html') {
            return node;
          }
          const result =
          // Step into the shadow DOM of the parent of a slotted node.
          node.assignedSlot ||
          // DOM Element detected.
          node.parentNode ||
          // ShadowRoot detected.
          isShadowRoot(node) && node.host ||
          // Fallback.
          getDocumentElement(node);
          return isShadowRoot(result) ? result.host : result;
        }
        function getNearestOverflowAncestor(node) {
          const parentNode = getParentNode(node);
          if (isLastTraversableNode(parentNode)) {
            return node.ownerDocument ? node.ownerDocument.body : node.body;
          }
          if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
            return parentNode;
          }
          return getNearestOverflowAncestor(parentNode);
        }
        function getOverflowAncestors(node, list, traverseIframes) {
          var _node$ownerDocument2;
          if (list === void 0) {
            list = [];
          }
          if (traverseIframes === void 0) {
            traverseIframes = true;
          }
          const scrollableAncestor = getNearestOverflowAncestor(node);
          const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
          const win = getWindow$1(scrollableAncestor);
          if (isBody) {
            const frameElement = getFrameElement(win);
            return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
          }
          return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
        }
        function getFrameElement(win) {
          return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
        }
        function getCssDimensions(element) {
          const css = getComputedStyle$1(element);
          // In testing environments, the `width` and `height` properties are empty
          // strings for SVG elements, returning NaN. Fallback to `0` in this case.
          let width = parseFloat(css.width) || 0;
          let height = parseFloat(css.height) || 0;
          const hasOffset = isHTMLElement$1(element);
          const offsetWidth = hasOffset ? element.offsetWidth : width;
          const offsetHeight = hasOffset ? element.offsetHeight : height;
          const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
          if (shouldFallback) {
            width = offsetWidth;
            height = offsetHeight;
          }
          return {
            width,
            height,
            $: shouldFallback
          };
        }
        function unwrapElement(element) {
          return !isElement(element) ? element.contextElement : element;
        }
        function getScale(element) {
          const domElement = unwrapElement(element);
          if (!isHTMLElement$1(domElement)) {
            return createCoords(1);
          }
          const rect = domElement.getBoundingClientRect();
          const {
            width,
            height,
            $
          } = getCssDimensions(domElement);
          let x = ($ ? round(rect.width) : rect.width) / width;
          let y = ($ ? round(rect.height) : rect.height) / height;

          // 0, NaN, or Infinity should always fallback to 1.

          if (!x || !Number.isFinite(x)) {
            x = 1;
          }
          if (!y || !Number.isFinite(y)) {
            y = 1;
          }
          return {
            x,
            y
          };
        }
        const noOffsets = /*#__PURE__*/createCoords(0);
        function getVisualOffsets(element) {
          const win = getWindow$1(element);
          if (!isWebKit() || !win.visualViewport) {
            return noOffsets;
          }
          return {
            x: win.visualViewport.offsetLeft,
            y: win.visualViewport.offsetTop
          };
        }
        function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
          if (isFixed === void 0) {
            isFixed = false;
          }
          if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
            return false;
          }
          return isFixed;
        }
        function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
          if (includeScale === void 0) {
            includeScale = false;
          }
          if (isFixedStrategy === void 0) {
            isFixedStrategy = false;
          }
          const clientRect = element.getBoundingClientRect();
          const domElement = unwrapElement(element);
          let scale = createCoords(1);
          if (includeScale) {
            if (offsetParent) {
              if (isElement(offsetParent)) {
                scale = getScale(offsetParent);
              }
            } else {
              scale = getScale(element);
            }
          }
          const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
          let x = (clientRect.left + visualOffsets.x) / scale.x;
          let y = (clientRect.top + visualOffsets.y) / scale.y;
          let width = clientRect.width / scale.x;
          let height = clientRect.height / scale.y;
          if (domElement) {
            const win = getWindow$1(domElement);
            const offsetWin = offsetParent && isElement(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
            let currentWin = win;
            let currentIFrame = getFrameElement(currentWin);
            while (currentIFrame && offsetParent && offsetWin !== currentWin) {
              const iframeScale = getScale(currentIFrame);
              const iframeRect = currentIFrame.getBoundingClientRect();
              const css = getComputedStyle$1(currentIFrame);
              const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
              const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
              x *= iframeScale.x;
              y *= iframeScale.y;
              width *= iframeScale.x;
              height *= iframeScale.y;
              x += left;
              y += top;
              currentWin = getWindow$1(currentIFrame);
              currentIFrame = getFrameElement(currentWin);
            }
          }
          return rectToClientRect({
            width,
            height,
            x,
            y
          });
        }

        // If <html> has a CSS width greater than the viewport, then this will be
        // incorrect for RTL.
        function getWindowScrollBarX(element, rect) {
          const leftScroll = getNodeScroll(element).scrollLeft;
          if (!rect) {
            return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
          }
          return rect.left + leftScroll;
        }
        function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
          if (ignoreScrollbarX === void 0) {
            ignoreScrollbarX = false;
          }
          const htmlRect = documentElement.getBoundingClientRect();
          const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
          // RTL <body> scrollbar.
          getWindowScrollBarX(documentElement, htmlRect));
          const y = htmlRect.top + scroll.scrollTop;
          return {
            x,
            y
          };
        }
        function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
          let {
            elements,
            rect,
            offsetParent,
            strategy
          } = _ref;
          const isFixed = strategy === 'fixed';
          const documentElement = getDocumentElement(offsetParent);
          const topLayer = elements ? isTopLayer(elements.floating) : false;
          if (offsetParent === documentElement || topLayer && isFixed) {
            return rect;
          }
          let scroll = {
            scrollLeft: 0,
            scrollTop: 0
          };
          let scale = createCoords(1);
          const offsets = createCoords(0);
          const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
          if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
              scroll = getNodeScroll(offsetParent);
            }
            if (isHTMLElement$1(offsetParent)) {
              const offsetRect = getBoundingClientRect(offsetParent);
              scale = getScale(offsetParent);
              offsets.x = offsetRect.x + offsetParent.clientLeft;
              offsets.y = offsetRect.y + offsetParent.clientTop;
            }
          }
          const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
          return {
            width: rect.width * scale.x,
            height: rect.height * scale.y,
            x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
            y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
          };
        }
        function getClientRects(element) {
          return Array.from(element.getClientRects());
        }

        // Gets the entire size of the scrollable document area, even extending outside
        // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
        function getDocumentRect(element) {
          const html = getDocumentElement(element);
          const scroll = getNodeScroll(element);
          const body = element.ownerDocument.body;
          const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
          const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
          let x = -scroll.scrollLeft + getWindowScrollBarX(element);
          const y = -scroll.scrollTop;
          if (getComputedStyle$1(body).direction === 'rtl') {
            x += max(html.clientWidth, body.clientWidth) - width;
          }
          return {
            width,
            height,
            x,
            y
          };
        }
        function getViewportRect(element, strategy) {
          const win = getWindow$1(element);
          const html = getDocumentElement(element);
          const visualViewport = win.visualViewport;
          let width = html.clientWidth;
          let height = html.clientHeight;
          let x = 0;
          let y = 0;
          if (visualViewport) {
            width = visualViewport.width;
            height = visualViewport.height;
            const visualViewportBased = isWebKit();
            if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
              x = visualViewport.offsetLeft;
              y = visualViewport.offsetTop;
            }
          }
          return {
            width,
            height,
            x,
            y
          };
        }
        const absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);
        // Returns the inner client rect, subtracting scrollbars if present.
        function getInnerBoundingClientRect(element, strategy) {
          const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
          const top = clientRect.top + element.clientTop;
          const left = clientRect.left + element.clientLeft;
          const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
          const width = element.clientWidth * scale.x;
          const height = element.clientHeight * scale.y;
          const x = left * scale.x;
          const y = top * scale.y;
          return {
            width,
            height,
            x,
            y
          };
        }
        function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
          let rect;
          if (clippingAncestor === 'viewport') {
            rect = getViewportRect(element, strategy);
          } else if (clippingAncestor === 'document') {
            rect = getDocumentRect(getDocumentElement(element));
          } else if (isElement(clippingAncestor)) {
            rect = getInnerBoundingClientRect(clippingAncestor, strategy);
          } else {
            const visualOffsets = getVisualOffsets(element);
            rect = {
              x: clippingAncestor.x - visualOffsets.x,
              y: clippingAncestor.y - visualOffsets.y,
              width: clippingAncestor.width,
              height: clippingAncestor.height
            };
          }
          return rectToClientRect(rect);
        }
        function hasFixedPositionAncestor(element, stopNode) {
          const parentNode = getParentNode(element);
          if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
            return false;
          }
          return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
        }

        // A "clipping ancestor" is an `overflow` element with the characteristic of
        // clipping (or hiding) child elements. This returns all clipping ancestors
        // of the given element up the tree.
        function getClippingElementAncestors(element, cache) {
          const cachedResult = cache.get(element);
          if (cachedResult) {
            return cachedResult;
          }
          let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
          let currentContainingBlockComputedStyle = null;
          const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
          let currentNode = elementIsFixed ? getParentNode(element) : element;

          // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
          while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
            const computedStyle = getComputedStyle$1(currentNode);
            const currentNodeIsContaining = isContainingBlock(currentNode);
            if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
              currentContainingBlockComputedStyle = null;
            }
            const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
            if (shouldDropCurrentNode) {
              // Drop non-containing blocks.
              result = result.filter(ancestor => ancestor !== currentNode);
            } else {
              // Record last containing block for next iteration.
              currentContainingBlockComputedStyle = computedStyle;
            }
            currentNode = getParentNode(currentNode);
          }
          cache.set(element, result);
          return result;
        }

        // Gets the maximum area that the element is visible in due to any number of
        // clipping ancestors.
        function getClippingRect(_ref) {
          let {
            element,
            boundary,
            rootBoundary,
            strategy
          } = _ref;
          const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
          const clippingAncestors = [...elementClippingAncestors, rootBoundary];
          const firstClippingAncestor = clippingAncestors[0];
          const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
            const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
          }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
          return {
            width: clippingRect.right - clippingRect.left,
            height: clippingRect.bottom - clippingRect.top,
            x: clippingRect.left,
            y: clippingRect.top
          };
        }
        function getDimensions(element) {
          const {
            width,
            height
          } = getCssDimensions(element);
          return {
            width,
            height
          };
        }
        function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
          const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
          const documentElement = getDocumentElement(offsetParent);
          const isFixed = strategy === 'fixed';
          const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
          let scroll = {
            scrollLeft: 0,
            scrollTop: 0
          };
          const offsets = createCoords(0);

          // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
          // Firefox with layout.scrollbar.side = 3 in about:config to test this.
          function setLeftRTLScrollbarOffset() {
            offsets.x = getWindowScrollBarX(documentElement);
          }
          if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
            if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
              scroll = getNodeScroll(offsetParent);
            }
            if (isOffsetParentAnElement) {
              const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
              offsets.x = offsetRect.x + offsetParent.clientLeft;
              offsets.y = offsetRect.y + offsetParent.clientTop;
            } else if (documentElement) {
              setLeftRTLScrollbarOffset();
            }
          }
          if (isFixed && !isOffsetParentAnElement && documentElement) {
            setLeftRTLScrollbarOffset();
          }
          const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
          const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
          const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
          return {
            x,
            y,
            width: rect.width,
            height: rect.height
          };
        }
        function isStaticPositioned(element) {
          return getComputedStyle$1(element).position === 'static';
        }
        function getTrueOffsetParent(element, polyfill) {
          if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === 'fixed') {
            return null;
          }
          if (polyfill) {
            return polyfill(element);
          }
          let rawOffsetParent = element.offsetParent;

          // Firefox returns the <html> element as the offsetParent if it's non-static,
          // while Chrome and Safari return the <body> element. The <body> element must
          // be used to perform the correct calculations even if the <html> element is
          // non-static.
          if (getDocumentElement(element) === rawOffsetParent) {
            rawOffsetParent = rawOffsetParent.ownerDocument.body;
          }
          return rawOffsetParent;
        }

        // Gets the closest ancestor positioned element. Handles some edge cases,
        // such as table ancestors and cross browser bugs.
        function getOffsetParent(element, polyfill) {
          const win = getWindow$1(element);
          if (isTopLayer(element)) {
            return win;
          }
          if (!isHTMLElement$1(element)) {
            let svgOffsetParent = getParentNode(element);
            while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
              if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
                return svgOffsetParent;
              }
              svgOffsetParent = getParentNode(svgOffsetParent);
            }
            return win;
          }
          let offsetParent = getTrueOffsetParent(element, polyfill);
          while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
            offsetParent = getTrueOffsetParent(offsetParent, polyfill);
          }
          if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
            return win;
          }
          return offsetParent || getContainingBlock(element) || win;
        }
        const getElementRects = async function (data) {
          const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
          const getDimensionsFn = this.getDimensions;
          const floatingDimensions = await getDimensionsFn(data.floating);
          return {
            reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
            floating: {
              x: 0,
              y: 0,
              width: floatingDimensions.width,
              height: floatingDimensions.height
            }
          };
        };
        function isRTL(element) {
          return getComputedStyle$1(element).direction === 'rtl';
        }
        const platform = {
          convertOffsetParentRelativeRectToViewportRelativeRect,
          getDocumentElement,
          getClippingRect,
          getOffsetParent,
          getElementRects,
          getClientRects,
          getDimensions,
          getScale,
          isElement,
          isRTL
        };
        function rectsAreEqual(a, b) {
          return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
        }

        // https://samthor.au/2021/observing-dom/
        function observeMove(element, onMove) {
          let io = null;
          let timeoutId;
          const root = getDocumentElement(element);
          function cleanup() {
            var _io;
            clearTimeout(timeoutId);
            (_io = io) == null || _io.disconnect();
            io = null;
          }
          function refresh(skip, threshold) {
            if (skip === void 0) {
              skip = false;
            }
            if (threshold === void 0) {
              threshold = 1;
            }
            cleanup();
            const elementRectForRootMargin = element.getBoundingClientRect();
            const {
              left,
              top,
              width,
              height
            } = elementRectForRootMargin;
            if (!skip) {
              onMove();
            }
            if (!width || !height) {
              return;
            }
            const insetTop = floor(top);
            const insetRight = floor(root.clientWidth - (left + width));
            const insetBottom = floor(root.clientHeight - (top + height));
            const insetLeft = floor(left);
            const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
            const options = {
              rootMargin,
              threshold: max(0, min(1, threshold)) || 1
            };
            let isFirstUpdate = true;
            function handleObserve(entries) {
              const ratio = entries[0].intersectionRatio;
              if (ratio !== threshold) {
                if (!isFirstUpdate) {
                  return refresh();
                }
                if (!ratio) {
                  // If the reference is clipped, the ratio is 0. Throttle the refresh
                  // to prevent an infinite loop of updates.
                  timeoutId = setTimeout(() => {
                    refresh(false, 1e-7);
                  }, 1000);
                } else {
                  refresh(false, ratio);
                }
              }
              if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
                // It's possible that even though the ratio is reported as 1, the
                // element is not actually fully within the IntersectionObserver's root
                // area anymore. This can happen under performance constraints. This may
                // be a bug in the browser's IntersectionObserver implementation. To
                // work around this, we compare the element's bounding rect now with
                // what it was at the time we created the IntersectionObserver. If they
                // are not equal then the element moved, so we refresh.
                refresh();
              }
              isFirstUpdate = false;
            }

            // Older browsers don't support a `document` as the root and will throw an
            // error.
            try {
              io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
              });
            } catch (_e) {
              io = new IntersectionObserver(handleObserve, options);
            }
            io.observe(element);
          }
          refresh(true);
          return cleanup;
        }

        /**
         * Automatically updates the position of the floating element when necessary.
         * Should only be called when the floating element is mounted on the DOM or
         * visible on the screen.
         * @returns cleanup function that should be invoked when the floating element is
         * removed from the DOM or hidden from the screen.
         * @see https://floating-ui.com/docs/autoUpdate
         */
        function autoUpdate(reference, floating, update, options) {
          if (options === void 0) {
            options = {};
          }
          const {
            ancestorScroll = true,
            ancestorResize = true,
            elementResize = typeof ResizeObserver === 'function',
            layoutShift = typeof IntersectionObserver === 'function',
            animationFrame = false
          } = options;
          const referenceEl = unwrapElement(reference);
          const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
          ancestors.forEach(ancestor => {
            ancestorScroll && ancestor.addEventListener('scroll', update, {
              passive: true
            });
            ancestorResize && ancestor.addEventListener('resize', update);
          });
          const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
          let reobserveFrame = -1;
          let resizeObserver = null;
          if (elementResize) {
            resizeObserver = new ResizeObserver(_ref => {
              let [firstEntry] = _ref;
              if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(() => {
                  var _resizeObserver;
                  (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
              }
              update();
            });
            if (referenceEl && !animationFrame) {
              resizeObserver.observe(referenceEl);
            }
            resizeObserver.observe(floating);
          }
          let frameId;
          let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
          if (animationFrame) {
            frameLoop();
          }
          function frameLoop() {
            const nextRefRect = getBoundingClientRect(reference);
            if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
              update();
            }
            prevRefRect = nextRefRect;
            frameId = requestAnimationFrame(frameLoop);
          }
          update();
          return () => {
            var _resizeObserver2;
            ancestors.forEach(ancestor => {
              ancestorScroll && ancestor.removeEventListener('scroll', update);
              ancestorResize && ancestor.removeEventListener('resize', update);
            });
            cleanupIo == null || cleanupIo();
            (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
            resizeObserver = null;
            if (animationFrame) {
              cancelAnimationFrame(frameId);
            }
          };
        }

        /**
         * Modifies the placement by translating the floating element along the
         * specified axes.
         * A number (shorthand for `mainAxis` or distance), or an axes configuration
         * object may be passed.
         * @see https://floating-ui.com/docs/offset
         */
        const offset = offset$1;

        /**
         * Optimizes the visibility of the floating element by shifting it in order to
         * keep it in view when it will overflow the clipping boundary.
         * @see https://floating-ui.com/docs/shift
         */
        const shift = shift$1;

        /**
         * Optimizes the visibility of the floating element by flipping the `placement`
         * in order to keep it in view when the preferred placement(s) will overflow the
         * clipping boundary. Alternative to `autoPlacement`.
         * @see https://floating-ui.com/docs/flip
         */
        const flip = flip$1;

        /**
         * Provides data that allows you to change the size of the floating element —
         * for instance, prevent it from overflowing the clipping boundary or match the
         * width of the reference element.
         * @see https://floating-ui.com/docs/size
         */
        const size = size$1;

        /**
         * Provides data to position an inner element of the floating element so that it
         * appears centered to the reference element.
         * @see https://floating-ui.com/docs/arrow
         */
        const arrow = arrow$1;

        /**
         * Built-in `limiter` that will stop `shift()` at a certain point.
         */
        const limitShift = limitShift$1;

        /**
         * Computes the `x` and `y` coordinates that will place the floating element
         * next to a given reference element.
         */
        const computePosition = (reference, floating, options) => {
          // This caches the expensive `getClippingElementAncestors` function so that
          // multiple lifecycle resets re-use the same result. It only lives for a
          // single call. If other functions become expensive, we can add them as well.
          const cache = new Map();
          const mergedOptions = {
            platform,
            ...options
          };
          const platformWithCache = {
            ...mergedOptions.platform,
            _c: cache
          };
          return computePosition$1(reference, floating, {
            ...mergedOptions,
            platform: platformWithCache
          });
        };
        var TagName$4 = "div";
        function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
          if (typeof DOMRect === "function") {
            return new DOMRect(x, y, width, height);
          }
          const rect = {
            x,
            y,
            width,
            height,
            top: y,
            right: x + width,
            bottom: y + height,
            left: x
          };
          return __spreadProps$1(__spreadValues$1({}, rect), {
            toJSON: () => rect
          });
        }
        function getDOMRect(anchorRect) {
          if (!anchorRect) return createDOMRect();
          const {
            x,
            y,
            width,
            height
          } = anchorRect;
          return createDOMRect(x, y, width, height);
        }
        function getAnchorElement(anchorElement, getAnchorRect) {
          const contextElement = anchorElement || void 0;
          return {
            contextElement,
            getBoundingClientRect: () => {
              const anchor = anchorElement;
              const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
              if (anchorRect || !anchor) {
                return getDOMRect(anchorRect);
              }
              return anchor.getBoundingClientRect();
            }
          };
        }
        function isValidPlacement(flip2) {
          return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip2);
        }
        function roundByDPR(value) {
          const dpr = window.devicePixelRatio || 1;
          return Math.round(value * dpr) / dpr;
        }
        function getOffsetMiddleware(arrowElement, props) {
          return offset(({
            placement
          }) => {
            var _a;
            const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
            const finalGutter = typeof props.gutter === "number" ? props.gutter + arrowOffset : (_a = props.gutter) != null ? _a : arrowOffset;
            const hasAlignment = !!placement.split("-")[1];
            return {
              crossAxis: !hasAlignment ? props.shift : void 0,
              mainAxis: finalGutter,
              alignmentAxis: props.shift
            };
          });
        }
        function getFlipMiddleware(props) {
          if (props.flip === false) return;
          const fallbackPlacements = typeof props.flip === "string" ? props.flip.split(" ") : void 0;
          invariant(!fallbackPlacements || fallbackPlacements.every(isValidPlacement), false);
          return flip({
            padding: props.overflowPadding,
            fallbackPlacements
          });
        }
        function getShiftMiddleware(props) {
          if (!props.slide && !props.overlap) return;
          return shift({
            mainAxis: props.slide,
            crossAxis: props.overlap,
            padding: props.overflowPadding,
            limiter: limitShift()
          });
        }
        function getSizeMiddleware(props) {
          return size({
            padding: props.overflowPadding,
            apply({
              elements,
              availableWidth,
              availableHeight,
              rects
            }) {
              const wrapper = elements.floating;
              const referenceWidth = Math.round(rects.reference.width);
              availableWidth = Math.floor(availableWidth);
              availableHeight = Math.floor(availableHeight);
              wrapper.style.setProperty("--popover-anchor-width", `${referenceWidth}px`);
              wrapper.style.setProperty("--popover-available-width", `${availableWidth}px`);
              wrapper.style.setProperty("--popover-available-height", `${availableHeight}px`);
              if (props.sameWidth) {
                wrapper.style.width = `${referenceWidth}px`;
              }
              if (props.fitViewport) {
                wrapper.style.maxWidth = `${availableWidth}px`;
                wrapper.style.maxHeight = `${availableHeight}px`;
              }
            }
          });
        }
        function getArrowMiddleware(arrowElement, props) {
          if (!arrowElement) return;
          return arrow({
            element: arrowElement,
            padding: props.arrowPadding
          });
        }
        var usePopover = createHook(function usePopover2(_a) {
          var _b = _a,
            {
              store,
              modal = false,
              portal = !!modal,
              preserveTabOrder = true,
              autoFocusOnShow = true,
              wrapperProps,
              fixed = false,
              flip: flip2 = true,
              shift: shift2 = 0,
              slide = true,
              overlap = false,
              sameWidth = false,
              fitViewport = false,
              gutter,
              arrowPadding = 4,
              overflowPadding = 8,
              getAnchorRect,
              updatePosition
            } = _b,
            props = __objRest$1(_b, ["store", "modal", "portal", "preserveTabOrder", "autoFocusOnShow", "wrapperProps", "fixed", "flip", "shift", "slide", "overlap", "sameWidth", "fitViewport", "gutter", "arrowPadding", "overflowPadding", "getAnchorRect", "updatePosition"]);
          const context = usePopoverProviderContext();
          store = store || context;
          invariant(store, false);
          const arrowElement = store.useState("arrowElement");
          const anchorElement = store.useState("anchorElement");
          const disclosureElement = store.useState("disclosureElement");
          const popoverElement = store.useState("popoverElement");
          const contentElement = store.useState("contentElement");
          const placement = store.useState("placement");
          const mounted = store.useState("mounted");
          const rendered = store.useState("rendered");
          const defaultArrowElementRef = reactExports.useRef(null);
          const [positioned, setPositioned] = reactExports.useState(false);
          const {
            portalRef,
            domReady
          } = usePortalRef(portal, props.portalRef);
          const getAnchorRectProp = useEvent$1(getAnchorRect);
          const updatePositionProp = useEvent$1(updatePosition);
          const hasCustomUpdatePosition = !!updatePosition;
          useSafeLayoutEffect(() => {
            if (!(popoverElement == null ? void 0 : popoverElement.isConnected)) return;
            popoverElement.style.setProperty("--popover-overflow-padding", `${overflowPadding}px`);
            const anchor = getAnchorElement(anchorElement, getAnchorRectProp);
            const updatePosition2 = async () => {
              if (!mounted) return;
              if (!arrowElement) {
                defaultArrowElementRef.current = defaultArrowElementRef.current || document.createElement("div");
              }
              const arrow2 = arrowElement || defaultArrowElementRef.current;
              const middleware = [getOffsetMiddleware(arrow2, {
                gutter,
                shift: shift2
              }), getFlipMiddleware({
                flip: flip2,
                overflowPadding
              }), getShiftMiddleware({
                slide,
                overlap,
                overflowPadding
              }), getArrowMiddleware(arrow2, {
                arrowPadding
              }), getSizeMiddleware({
                sameWidth,
                fitViewport,
                overflowPadding
              })];
              const pos = await computePosition(anchor, popoverElement, {
                placement,
                strategy: fixed ? "fixed" : "absolute",
                middleware
              });
              store == null ? void 0 : store.setState("currentPlacement", pos.placement);
              setPositioned(true);
              const x = roundByDPR(pos.x);
              const y = roundByDPR(pos.y);
              Object.assign(popoverElement.style, {
                top: "0",
                left: "0",
                transform: `translate3d(${x}px,${y}px,0)`
              });
              if (arrow2 && pos.middlewareData.arrow) {
                const {
                  x: arrowX,
                  y: arrowY
                } = pos.middlewareData.arrow;
                const side = pos.placement.split("-")[0];
                const centerX = arrow2.clientWidth / 2;
                const centerY = arrow2.clientHeight / 2;
                const originX = arrowX != null ? arrowX + centerX : -centerX;
                const originY = arrowY != null ? arrowY + centerY : -centerY;
                popoverElement.style.setProperty("--popover-transform-origin", {
                  top: `${originX}px calc(100% + ${centerY}px)`,
                  bottom: `${originX}px ${-centerY}px`,
                  left: `calc(100% + ${centerX}px) ${originY}px`,
                  right: `${-centerX}px ${originY}px`
                }[side]);
                Object.assign(arrow2.style, {
                  left: arrowX != null ? `${arrowX}px` : "",
                  top: arrowY != null ? `${arrowY}px` : "",
                  [side]: "100%"
                });
              }
            };
            const update = async () => {
              if (hasCustomUpdatePosition) {
                await updatePositionProp({
                  updatePosition: updatePosition2
                });
                setPositioned(true);
              } else {
                await updatePosition2();
              }
            };
            const cancelAutoUpdate = autoUpdate(anchor, popoverElement, update, {
              // JSDOM doesn't support ResizeObserver
              elementResize: typeof ResizeObserver === "function"
            });
            return () => {
              setPositioned(false);
              cancelAutoUpdate();
            };
          }, [store, rendered, popoverElement, arrowElement, anchorElement, popoverElement, placement, mounted, domReady, fixed, flip2, shift2, slide, overlap, sameWidth, fitViewport, gutter, arrowPadding, overflowPadding, getAnchorRectProp, hasCustomUpdatePosition, updatePositionProp]);
          useSafeLayoutEffect(() => {
            if (!mounted) return;
            if (!domReady) return;
            if (!(popoverElement == null ? void 0 : popoverElement.isConnected)) return;
            if (!(contentElement == null ? void 0 : contentElement.isConnected)) return;
            const applyZIndex = () => {
              popoverElement.style.zIndex = getComputedStyle(contentElement).zIndex;
            };
            applyZIndex();
            let raf = requestAnimationFrame(() => {
              raf = requestAnimationFrame(applyZIndex);
            });
            return () => cancelAnimationFrame(raf);
          }, [mounted, domReady, popoverElement, contentElement]);
          const position = fixed ? "fixed" : "absolute";
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx("div", __spreadProps$1(__spreadValues$1({}, wrapperProps), {
            style: __spreadValues$1({
              // https://floating-ui.com/docs/computeposition#initial-layout
              position,
              top: 0,
              left: 0,
              width: "max-content"
            }, wrapperProps == null ? void 0 : wrapperProps.style),
            ref: store == null ? void 0 : store.setPopoverElement,
            children: element
          })), [store, position, wrapperProps]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(PopoverScopedContextProvider, {
            value: store,
            children: element
          }), [store]);
          props = __spreadProps$1(__spreadValues$1({
            // data-placing is not part of the public API. We're setting this here so
            // we can wait for the popover to be positioned before other components
            // move focus into it. For example, this attribute is observed by the
            // Combobox component with the autoSelect behavior.
            "data-placing": !positioned || void 0
          }, props), {
            style: __spreadValues$1({
              position: "relative"
            }, props.style)
          });
          props = useDialog(__spreadProps$1(__spreadValues$1({
            store,
            modal,
            portal,
            preserveTabOrder,
            preserveTabOrderAnchor: disclosureElement || anchorElement,
            autoFocusOnShow: positioned && autoFocusOnShow
          }, props), {
            portalRef
          }));
          return props;
        });
        createDialogComponent(forwardRef2(function Popover2(props) {
          const htmlProps = usePopover(props);
          return createElement(TagName$4, htmlProps);
        }), usePopoverProviderContext);
        var TagName$3 = "div";
        function isMovingOnHovercard(target, card, anchor, nested) {
          if (hasFocusWithin(card)) return true;
          if (!target) return false;
          if (contains(card, target)) return true;
          if (anchor && contains(anchor, target)) return true;
          if (nested == null ? void 0 : nested.some(card2 => isMovingOnHovercard(target, card2, anchor))) {
            return true;
          }
          return false;
        }
        function useAutoFocusOnHide(_a) {
          var _b = _a,
            {
              store
            } = _b,
            props = __objRest$1(_b, ["store"]);
          const [autoFocusOnHide, setAutoFocusOnHide] = reactExports.useState(false);
          const mounted = store.useState("mounted");
          reactExports.useEffect(() => {
            if (!mounted) {
              setAutoFocusOnHide(false);
            }
          }, [mounted]);
          const onFocusProp = props.onFocus;
          const onFocus = useEvent$1(event => {
            onFocusProp == null ? void 0 : onFocusProp(event);
            if (event.defaultPrevented) return;
            setAutoFocusOnHide(true);
          });
          const finalFocusRef = reactExports.useRef(null);
          reactExports.useEffect(() => {
            return sync(store, ["anchorElement"], state => {
              finalFocusRef.current = state.anchorElement;
            });
          }, []);
          props = __spreadProps$1(__spreadValues$1({
            autoFocusOnHide,
            finalFocus: finalFocusRef
          }, props), {
            onFocus
          });
          return props;
        }
        var NestedHovercardContext = reactExports.createContext(null);
        var useHovercard = createHook(function useHovercard2(_a) {
          var _b = _a,
            {
              store,
              modal = false,
              portal = !!modal,
              hideOnEscape = true,
              hideOnHoverOutside = true,
              disablePointerEventsOnApproach = !!hideOnHoverOutside
            } = _b,
            props = __objRest$1(_b, ["store", "modal", "portal", "hideOnEscape", "hideOnHoverOutside", "disablePointerEventsOnApproach"]);
          const context = useHovercardProviderContext();
          store = store || context;
          invariant(store, false);
          const ref = reactExports.useRef(null);
          const [nestedHovercards, setNestedHovercards] = reactExports.useState([]);
          const hideTimeoutRef = reactExports.useRef(0);
          const enterPointRef = reactExports.useRef(null);
          const {
            portalRef,
            domReady
          } = usePortalRef(portal, props.portalRef);
          const isMouseMoving = useIsMouseMoving();
          const mayHideOnHoverOutside = !!hideOnHoverOutside;
          const hideOnHoverOutsideProp = useBooleanEvent(hideOnHoverOutside);
          const mayDisablePointerEvents = !!disablePointerEventsOnApproach;
          const disablePointerEventsProp = useBooleanEvent(disablePointerEventsOnApproach);
          const open = store.useState("open");
          const mounted = store.useState("mounted");
          reactExports.useEffect(() => {
            if (!domReady) return;
            if (!mounted) return;
            if (!mayHideOnHoverOutside && !mayDisablePointerEvents) return;
            const element = ref.current;
            if (!element) return;
            const onMouseMove = event => {
              if (!store) return;
              if (!isMouseMoving()) return;
              const {
                anchorElement,
                hideTimeout,
                timeout
              } = store.getState();
              const enterPoint = enterPointRef.current;
              const [target] = event.composedPath();
              const anchor = anchorElement;
              if (isMovingOnHovercard(target, element, anchor, nestedHovercards)) {
                enterPointRef.current = target && anchor && contains(anchor, target) ? getEventPoint(event) : null;
                window.clearTimeout(hideTimeoutRef.current);
                hideTimeoutRef.current = 0;
                return;
              }
              if (hideTimeoutRef.current) return;
              if (enterPoint) {
                const currentPoint = getEventPoint(event);
                const polygon = getElementPolygon(element, enterPoint);
                if (isPointInPolygon(currentPoint, polygon)) {
                  enterPointRef.current = currentPoint;
                  if (!disablePointerEventsProp(event)) return;
                  event.preventDefault();
                  event.stopPropagation();
                  return;
                }
              }
              if (!hideOnHoverOutsideProp(event)) return;
              hideTimeoutRef.current = window.setTimeout(() => {
                hideTimeoutRef.current = 0;
                store == null ? void 0 : store.hide();
              }, hideTimeout != null ? hideTimeout : timeout);
            };
            return chain$1(addGlobalEventListener("mousemove", onMouseMove, true), () => clearTimeout(hideTimeoutRef.current));
          }, [store, isMouseMoving, domReady, mounted, mayHideOnHoverOutside, mayDisablePointerEvents, nestedHovercards, disablePointerEventsProp, hideOnHoverOutsideProp]);
          reactExports.useEffect(() => {
            if (!domReady) return;
            if (!mounted) return;
            if (!mayDisablePointerEvents) return;
            const disableEvent = event => {
              const element = ref.current;
              if (!element) return;
              const enterPoint = enterPointRef.current;
              if (!enterPoint) return;
              const polygon = getElementPolygon(element, enterPoint);
              if (isPointInPolygon(getEventPoint(event), polygon)) {
                if (!disablePointerEventsProp(event)) return;
                event.preventDefault();
                event.stopPropagation();
              }
            };
            return chain$1(
            // Note: we may need to add pointer events here in the future.
            addGlobalEventListener("mouseenter", disableEvent, true), addGlobalEventListener("mouseover", disableEvent, true), addGlobalEventListener("mouseout", disableEvent, true), addGlobalEventListener("mouseleave", disableEvent, true));
          }, [domReady, mounted, mayDisablePointerEvents, disablePointerEventsProp]);
          reactExports.useEffect(() => {
            if (!domReady) return;
            if (open) return;
            store == null ? void 0 : store.setAutoFocusOnShow(false);
          }, [store, domReady, open]);
          const openRef = useLiveRef(open);
          reactExports.useEffect(() => {
            if (!domReady) return;
            return () => {
              if (!openRef.current) {
                store == null ? void 0 : store.setAutoFocusOnShow(false);
              }
            };
          }, [store, domReady]);
          const registerOnParent = reactExports.useContext(NestedHovercardContext);
          useSafeLayoutEffect(() => {
            if (modal) return;
            if (!portal) return;
            if (!mounted) return;
            if (!domReady) return;
            const element = ref.current;
            if (!element) return;
            return registerOnParent == null ? void 0 : registerOnParent(element);
          }, [modal, portal, mounted, domReady]);
          const registerNestedHovercard = reactExports.useCallback(element => {
            setNestedHovercards(prevElements => [...prevElements, element]);
            const parentUnregister = registerOnParent == null ? void 0 : registerOnParent(element);
            return () => {
              setNestedHovercards(prevElements => prevElements.filter(item => item !== element));
              parentUnregister == null ? void 0 : parentUnregister();
            };
          }, [registerOnParent]);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(HovercardScopedContextProvider, {
            value: store,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(NestedHovercardContext.Provider, {
              value: registerNestedHovercard,
              children: element
            })
          }), [store, registerNestedHovercard]);
          props = __spreadProps$1(__spreadValues$1({}, props), {
            ref: useMergeRefs(ref, props.ref)
          });
          props = useAutoFocusOnHide(__spreadValues$1({
            store
          }, props));
          const autoFocusOnShow = store.useState(state => modal || state.autoFocusOnShow);
          props = usePopover(__spreadProps$1(__spreadValues$1({
            store,
            modal,
            portal,
            autoFocusOnShow
          }, props), {
            portalRef,
            hideOnEscape(event) {
              if (isFalsyBooleanCallback(hideOnEscape, event)) return false;
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  store == null ? void 0 : store.hide();
                });
              });
              return true;
            }
          }));
          return props;
        });
        createDialogComponent(forwardRef2(function Hovercard2(props) {
          const htmlProps = useHovercard(props);
          return createElement(TagName$3, htmlProps);
        }), useHovercardProviderContext);
        var TagName$2 = "div";
        var useTooltip = createHook(function useTooltip2(_a) {
          var _b = _a,
            {
              store,
              portal = true,
              gutter = 8,
              preserveTabOrder = false,
              hideOnHoverOutside = true,
              hideOnInteractOutside = true
            } = _b,
            props = __objRest$1(_b, ["store", "portal", "gutter", "preserveTabOrder", "hideOnHoverOutside", "hideOnInteractOutside"]);
          const context = useTooltipProviderContext();
          store = store || context;
          invariant(store, false);
          props = useWrapElement(props, element => /* @__PURE__ */jsxRuntimeExports.jsx(TooltipScopedContextProvider, {
            value: store,
            children: element
          }), [store]);
          const role = store.useState(state => state.type === "description" ? "tooltip" : "none");
          props = __spreadValues$1({
            role
          }, props);
          props = useHovercard(__spreadProps$1(__spreadValues$1({}, props), {
            store,
            portal,
            gutter,
            preserveTabOrder,
            hideOnHoverOutside(event) {
              if (isFalsyBooleanCallback(hideOnHoverOutside, event)) return false;
              const anchorElement = store == null ? void 0 : store.getState().anchorElement;
              if (!anchorElement) return true;
              if ("focusVisible" in anchorElement.dataset) return false;
              return true;
            },
            hideOnInteractOutside: event => {
              if (isFalsyBooleanCallback(hideOnInteractOutside, event)) return false;
              const anchorElement = store == null ? void 0 : store.getState().anchorElement;
              if (!anchorElement) return true;
              if (contains(anchorElement, event.target)) return false;
              return true;
            }
          }));
          return props;
        });
        var Tooltip$2 = createDialogComponent(forwardRef2(function Tooltip2(props) {
          const htmlProps = useTooltip(props);
          return createElement(TagName$2, htmlProps);
        }), useTooltipProviderContext);
        var TagName$1 = "a";
        var useHovercardAnchor = createHook(function useHovercardAnchor2(_a) {
          var _b = _a,
            {
              store,
              showOnHover = true
            } = _b,
            props = __objRest$1(_b, ["store", "showOnHover"]);
          const context = useHovercardProviderContext();
          store = store || context;
          invariant(store, false);
          const disabled = disabledFromProps(props);
          const showTimeoutRef = reactExports.useRef(0);
          reactExports.useEffect(() => () => window.clearTimeout(showTimeoutRef.current), []);
          reactExports.useEffect(() => {
            const onMouseLeave = event => {
              if (!store) return;
              const {
                anchorElement
              } = store.getState();
              if (!anchorElement) return;
              if (event.target !== anchorElement) return;
              window.clearTimeout(showTimeoutRef.current);
              showTimeoutRef.current = 0;
            };
            return addGlobalEventListener("mouseleave", onMouseLeave, true);
          }, [store]);
          const onMouseMoveProp = props.onMouseMove;
          const showOnHoverProp = useBooleanEvent(showOnHover);
          const isMouseMoving = useIsMouseMoving();
          const onMouseMove = useEvent$1(event => {
            onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
            if (disabled) return;
            if (!store) return;
            if (event.defaultPrevented) return;
            if (showTimeoutRef.current) return;
            if (!isMouseMoving()) return;
            if (!showOnHoverProp(event)) return;
            const element = event.currentTarget;
            store.setAnchorElement(element);
            store.setDisclosureElement(element);
            const {
              showTimeout,
              timeout
            } = store.getState();
            const showHovercard = () => {
              showTimeoutRef.current = 0;
              if (!isMouseMoving()) return;
              store == null ? void 0 : store.setAnchorElement(element);
              store == null ? void 0 : store.show();
              queueMicrotask(() => {
                store == null ? void 0 : store.setDisclosureElement(element);
              });
            };
            const timeoutMs = showTimeout != null ? showTimeout : timeout;
            if (timeoutMs === 0) {
              showHovercard();
            } else {
              showTimeoutRef.current = window.setTimeout(showHovercard, timeoutMs);
            }
          });
          const onClickProp = props.onClick;
          const onClick = useEvent$1(event => {
            onClickProp == null ? void 0 : onClickProp(event);
            if (!store) return;
            window.clearTimeout(showTimeoutRef.current);
            showTimeoutRef.current = 0;
          });
          const ref = reactExports.useCallback(element => {
            if (!store) return;
            const {
              anchorElement
            } = store.getState();
            if (anchorElement == null ? void 0 : anchorElement.isConnected) return;
            store.setAnchorElement(element);
          }, [store]);
          props = __spreadProps$1(__spreadValues$1({}, props), {
            ref: useMergeRefs(ref, props.ref),
            onMouseMove,
            onClick
          });
          props = useFocusable(props);
          return props;
        });
        forwardRef2(function HovercardAnchor2(props) {
          const htmlProps = useHovercardAnchor(props);
          return createElement(TagName$1, htmlProps);
        });
        var TagName = "div";
        var globalStore = createStore({
          activeStore: null
        });
        function createRemoveStoreCallback(store) {
          return () => {
            const {
              activeStore
            } = globalStore.getState();
            if (activeStore !== store) return;
            globalStore.setState("activeStore", null);
          };
        }
        var useTooltipAnchor = createHook(function useTooltipAnchor2(_a) {
          var _b = _a,
            {
              store,
              showOnHover = true
            } = _b,
            props = __objRest$1(_b, ["store", "showOnHover"]);
          const context = useTooltipProviderContext();
          store = store || context;
          invariant(store, false);
          const canShowOnHoverRef = reactExports.useRef(false);
          reactExports.useEffect(() => {
            return sync(store, ["mounted"], state => {
              if (state.mounted) return;
              canShowOnHoverRef.current = false;
            });
          }, [store]);
          reactExports.useEffect(() => {
            if (!store) return;
            return chain$1(
            // Immediately remove the current store from the global store when
            // the component unmounts. This is useful, for example, to avoid
            // showing tooltips immediately on serial tests.
            createRemoveStoreCallback(store), sync(store, ["mounted", "skipTimeout"], state => {
              if (!store) return;
              if (state.mounted) {
                const {
                  activeStore
                } = globalStore.getState();
                if (activeStore !== store) {
                  activeStore == null ? void 0 : activeStore.hide();
                }
                return globalStore.setState("activeStore", store);
              }
              const id = setTimeout(createRemoveStoreCallback(store), state.skipTimeout);
              return () => clearTimeout(id);
            }));
          }, [store]);
          const onMouseEnterProp = props.onMouseEnter;
          const onMouseEnter = useEvent$1(event => {
            onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
            canShowOnHoverRef.current = true;
          });
          const onFocusVisibleProp = props.onFocusVisible;
          const onFocusVisible = useEvent$1(event => {
            onFocusVisibleProp == null ? void 0 : onFocusVisibleProp(event);
            if (event.defaultPrevented) return;
            store == null ? void 0 : store.setAnchorElement(event.currentTarget);
            store == null ? void 0 : store.show();
          });
          const onBlurProp = props.onBlur;
          const onBlur = useEvent$1(event => {
            onBlurProp == null ? void 0 : onBlurProp(event);
            if (event.defaultPrevented) return;
            const {
              activeStore
            } = globalStore.getState();
            canShowOnHoverRef.current = false;
            if (activeStore === store) {
              globalStore.setState("activeStore", null);
            }
          });
          const type = store.useState("type");
          const contentId = store.useState(state => {
            var _a2;
            return (_a2 = state.contentElement) == null ? void 0 : _a2.id;
          });
          props = __spreadProps$1(__spreadValues$1({
            "aria-labelledby": type === "label" ? contentId : void 0
          }, props), {
            onMouseEnter,
            onFocusVisible,
            onBlur
          });
          props = useHovercardAnchor(__spreadValues$1({
            store,
            showOnHover(event) {
              if (!canShowOnHoverRef.current) return false;
              if (isFalsyBooleanCallback(showOnHover, event)) return false;
              const {
                activeStore
              } = globalStore.getState();
              if (!activeStore) return true;
              store == null ? void 0 : store.show();
              return false;
            }
          }, props));
          return props;
        });
        var TooltipAnchor = forwardRef2(function TooltipAnchor2(props) {
          const htmlProps = useTooltipAnchor(props);
          return createElement(TagName, htmlProps);
        });

        /**
         * Internal dependencies
         */

        /**
         * Shortcut component is used to display keyboard shortcuts, and it can be customized with a custom display and aria label if needed.
         *
         * ```jsx
         * import { Shortcut } from '@wordpress/components';
         *
         * const MyShortcut = () => {
         * 	return (
         * 		<Shortcut shortcut={{ display: 'Ctrl + S', ariaLabel: 'Save' }} />
         * 	);
         * };
         * ```
         */
        function Shortcut(props) {
          const {
            shortcut,
            className
          } = props;
          if (!shortcut) {
            return null;
          }
          let displayText;
          let ariaLabel;
          if (typeof shortcut === 'string') {
            displayText = shortcut;
          }
          if (shortcut !== null && typeof shortcut === 'object') {
            displayText = shortcut.display;
            ariaLabel = shortcut.ariaLabel;
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx("span", {
            className: className,
            "aria-label": ariaLabel,
            children: displayText
          });
        }

        /**
         * External dependencies
         */

        /**
         * Internal dependencies
         */

        const POSITION_TO_PLACEMENT = {
          bottom: 'bottom',
          top: 'top',
          'middle left': 'left',
          'middle right': 'right',
          'bottom left': 'bottom-end',
          'bottom center': 'bottom',
          'bottom right': 'bottom-start',
          'top left': 'top-end',
          'top center': 'top',
          'top right': 'top-start',
          'middle left left': 'left',
          'middle left right': 'left',
          'middle left bottom': 'left-end',
          'middle left top': 'left-start',
          'middle right left': 'right',
          'middle right right': 'right',
          'middle right bottom': 'right-end',
          'middle right top': 'right-start',
          'bottom left left': 'bottom-end',
          'bottom left right': 'bottom-end',
          'bottom left bottom': 'bottom-end',
          'bottom left top': 'bottom-end',
          'bottom center left': 'bottom',
          'bottom center right': 'bottom',
          'bottom center bottom': 'bottom',
          'bottom center top': 'bottom',
          'bottom right left': 'bottom-start',
          'bottom right right': 'bottom-start',
          'bottom right bottom': 'bottom-start',
          'bottom right top': 'bottom-start',
          'top left left': 'top-end',
          'top left right': 'top-end',
          'top left bottom': 'top-end',
          'top left top': 'top-end',
          'top center left': 'top',
          'top center right': 'top',
          'top center bottom': 'top',
          'top center top': 'top',
          'top right left': 'top-start',
          'top right right': 'top-start',
          'top right bottom': 'top-start',
          'top right top': 'top-start',
          // `middle`/`middle center [corner?]` positions are associated to a fallback
          // `bottom` placement because there aren't any corresponding placement values.
          middle: 'bottom',
          'middle center': 'bottom',
          'middle center bottom': 'bottom',
          'middle center left': 'bottom',
          'middle center right': 'bottom',
          'middle center top': 'bottom'
        };

        /**
         * Converts the `Popover`'s legacy "position" prop to the new "placement" prop
         * (used by `floating-ui`).
         *
         * @param position The legacy position
         * @return The corresponding placement
         */
        const positionToPlacement = position => {
          var _POSITION_TO_PLACEMEN;
          return (_POSITION_TO_PLACEMEN = POSITION_TO_PLACEMENT[position]) !== null && _POSITION_TO_PLACEMEN !== void 0 ? _POSITION_TO_PLACEMEN : 'bottom';
        };
        const TooltipInternalContext = reactExports.createContext({
          isNestedInTooltip: false
        });
        const TOOLTIP_DELAY = 700;
        const CONTEXT_VALUE = {
          isNestedInTooltip: true
        };
        function UnforwardedTooltip(props, ref) {
          const {
            children,
            className,
            delay = TOOLTIP_DELAY,
            hideOnClick = true,
            placement,
            position,
            shortcut,
            text,
            ...restProps
          } = props;
          const {
            isNestedInTooltip
          } = reactExports.useContext(TooltipInternalContext);
          const baseId = useInstanceId(Tooltip$1, "tooltip");
          const describedById = text || shortcut ? baseId : void 0;
          const isOnlyChild = reactExports.Children.count(children) === 1;
          let computedPlacement;
          if (placement !== void 0) {
            computedPlacement = placement;
          } else if (position !== void 0) {
            computedPlacement = positionToPlacement(position);
            deprecated("`position` prop in wp.components.tooltip", {
              since: "6.4",
              alternative: "`placement` prop"
            });
          }
          computedPlacement = computedPlacement || "bottom";
          const tooltipStore = useTooltipStore({
            placement: computedPlacement,
            showTimeout: delay
          });
          const mounted = useStoreState(tooltipStore, "mounted");
          if (isNestedInTooltip) {
            return isOnlyChild ? /* @__PURE__ */jsxRuntimeExports.jsx(Role, {
              ...restProps,
              render: children
            }) : children;
          }
          function addDescribedById(element) {
            return describedById && mounted && element.props["aria-describedby"] === void 0 && element.props["aria-label"] !== text ? reactExports.cloneElement(element, {
              "aria-describedby": describedById
            }) : element;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs(TooltipInternalContext.Provider, {
            value: CONTEXT_VALUE,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(TooltipAnchor, {
              onClick: hideOnClick ? tooltipStore.hide : void 0,
              store: tooltipStore,
              render: isOnlyChild ? addDescribedById(children) : void 0,
              ref,
              children: isOnlyChild ? void 0 : children
            }), isOnlyChild && (text || shortcut) && /* @__PURE__ */jsxRuntimeExports.jsxs(Tooltip$2, {
              ...restProps,
              className: clsx("components-tooltip", className),
              unmountOnHide: true,
              gutter: 4,
              id: describedById,
              overflowPadding: 0.5,
              store: tooltipStore,
              children: [text, shortcut && /* @__PURE__ */jsxRuntimeExports.jsx(Shortcut, {
                className: text ? "components-tooltip__shortcut" : "",
                shortcut
              })]
            })]
          });
        }
        const Tooltip$1 = reactExports.forwardRef(UnforwardedTooltip);
        var isMergeableObject = function isMergeableObject(value) {
          return isNonNullObject(value) && !isSpecial(value);
        };
        function isNonNullObject(value) {
          return !!value && typeof value === 'object';
        }
        function isSpecial(value) {
          var stringValue = Object.prototype.toString.call(value);
          return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
        }

        // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
        var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
        function isReactElement(value) {
          return value.$$typeof === REACT_ELEMENT_TYPE;
        }
        function emptyTarget(val) {
          return Array.isArray(val) ? [] : {};
        }
        function cloneUnlessOtherwiseSpecified(value, options) {
          return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
        }
        function defaultArrayMerge(target, source, options) {
          return target.concat(source).map(function (element) {
            return cloneUnlessOtherwiseSpecified(element, options);
          });
        }
        function getMergeFunction(key, options) {
          if (!options.customMerge) {
            return deepmerge;
          }
          var customMerge = options.customMerge(key);
          return typeof customMerge === 'function' ? customMerge : deepmerge;
        }
        function getEnumerableOwnPropertySymbols(target) {
          return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
            return Object.propertyIsEnumerable.call(target, symbol);
          }) : [];
        }
        function getKeys(target) {
          return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
        }
        function propertyIsOnObject(object, property) {
          try {
            return property in object;
          } catch (_) {
            return false;
          }
        }

        // Protects from prototype poisoning and unexpected merging up the prototype chain.
        function propertyIsUnsafe(target, key) {
          return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
          && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
          && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
        }
        function mergeObject(target, source, options) {
          var destination = {};
          if (options.isMergeableObject(target)) {
            getKeys(target).forEach(function (key) {
              destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
            });
          }
          getKeys(source).forEach(function (key) {
            if (propertyIsUnsafe(target, key)) {
              return;
            }
            if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
              destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
            } else {
              destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
            }
          });
          return destination;
        }
        function deepmerge(target, source, options) {
          options = options || {};
          options.arrayMerge = options.arrayMerge || defaultArrayMerge;
          options.isMergeableObject = options.isMergeableObject || isMergeableObject;
          // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
          // implementations can use it. The caller may not replace it.
          options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
          var sourceIsArray = Array.isArray(source);
          var targetIsArray = Array.isArray(target);
          var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
          if (!sourceAndTargetTypesMatch) {
            return cloneUnlessOtherwiseSpecified(source, options);
          } else if (sourceIsArray) {
            return options.arrayMerge(target, source, options);
          } else {
            return mergeObject(target, source, options);
          }
        }
        deepmerge.all = function deepmergeAll(array, options) {
          if (!Array.isArray(array)) {
            throw new Error('first argument should be an array');
          }
          return array.reduce(function (prev, next) {
            return deepmerge(prev, next, options);
          }, {});
        };
        var deepmerge_1 = deepmerge;
        var cjs = deepmerge_1;
        const deepmerge$1 = /*@__PURE__*/getDefaultExportFromCjs(cjs);
        var es6 = function equal(a, b) {
          if (a === b) return true;
          if (a && b && typeof a == 'object' && typeof b == 'object') {
            if (a.constructor !== b.constructor) return false;
            var length, i, keys;
            if (Array.isArray(a)) {
              length = a.length;
              if (length != b.length) return false;
              for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
              return true;
            }
            if (a instanceof Map && b instanceof Map) {
              if (a.size !== b.size) return false;
              for (i of a.entries()) if (!b.has(i[0])) return false;
              for (i of a.entries()) if (!equal(i[1], b.get(i[0]))) return false;
              return true;
            }
            if (a instanceof Set && b instanceof Set) {
              if (a.size !== b.size) return false;
              for (i of a.entries()) if (!b.has(i[0])) return false;
              return true;
            }
            if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
              length = a.length;
              if (length != b.length) return false;
              for (i = length; i-- !== 0;) if (a[i] !== b[i]) return false;
              return true;
            }
            if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
            if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
            if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
            keys = Object.keys(a);
            length = keys.length;
            if (length !== Object.keys(b).length) return false;
            for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
            for (i = length; i-- !== 0;) {
              var key = keys[i];
              if (!equal(a[key], b[key])) return false;
            }
            return true;
          }

          // true if both NaN, false otherwise
          return a !== a && b !== b;
        };
        const fastDeepEqual = /*@__PURE__*/getDefaultExportFromCjs(es6);

        /**
         * Object map tracking messages which have been logged, for use in ensuring a
         * message is only logged once.
         */
        const logged = new Set();

        /**
         * Internal dependencies
         */
        function isDev() {
          // eslint-disable-next-line @wordpress/wp-global-usage
          return globalThis.SCRIPT_DEBUG === true;
        }

        /**
         * Shows a warning with `message` if environment is not `production`.
         *
         * @param message Message to show in the warning.
         *
         * @example
         * ```js
         * import warning from '@wordpress/warning';
         *
         * function MyComponent( props ) {
         *   if ( ! props.title ) {
         *     warning( '`props.title` was not passed' );
         *   }
         *   ...
         * }
         * ```
         */
        function warning(message) {
          if (!isDev()) {
            return;
          }

          // Skip if already logged.
          if (logged.has(message)) {
            return;
          }

          // eslint-disable-next-line no-console
          console.warn(message);

          // Throwing an error and catching it immediately to improve debugging
          // A consumer can use 'pause on caught exceptions'
          // https://github.com/facebook/react/issues/4216
          try {
            throw Error(message);
          } catch (x) {
            // Do nothing.
          }
          logged.add(message);
        }

        /* eslint-disable jsdoc/valid-types */
        /**
         * Determines if a value is null or undefined.
         *
         * @template T
         *
         * @param {T} value The value to check.
         * @return {value is Exclude<T, null | undefined>} Whether value is not null or undefined.
         */
        function isValueDefined(value) {
          return value !== undefined && value !== null;
        }
        /* eslint-enable jsdoc/valid-types */

        /* eslint-disable jsdoc/valid-types */
        /**
         * Determines if a value is empty, null, or undefined.
         *
         * @param {string | number | null | undefined} value The value to check.
         * @return {value is ("" | null | undefined)} Whether value is empty.
         */
        function isValueEmpty(value) {
          const isEmptyString = value === '';
          return !isValueDefined(value) || isEmptyString;
        }
        /* eslint-enable jsdoc/valid-types */

        /**
         * Get the first defined/non-null value from an array.
         *
         * @template T
         *
         * @param {Array<T | null | undefined>} values        Values to derive from.
         * @param {T}                           fallbackValue Fallback value if there are no defined values.
         * @return {T} A defined value or the fallback value.
         */
        function getDefinedValue(values = [], fallbackValue) {
          var _values$find;
          return (_values$find = values.find(isValueDefined)) !== null && _values$find !== void 0 ? _values$find : fallbackValue;
        }

        /**
         * Converts a string to a number.
         *
         * @param {string} value
         * @return {number} String as a number.
         */
        const stringToNumber = value => {
          return parseFloat(value);
        };

        /**
         * Regardless of the input being a string or a number, returns a number.
         *
         * Returns `undefined` in case the string is `undefined` or not a valid numeric value.
         *
         * @param {string | number} value
         * @return {number} The parsed number.
         */
        const ensureNumber = value => {
          return typeof value === 'string' ? stringToNumber(value) : value;
        };

        /**
         * WordPress dependencies
         */

        /**
         * @template T
         * @typedef Options
         * @property {T}      [initial] Initial value
         * @property {T | ""} fallback  Fallback value
         */

        /** @type {Readonly<{ initial: undefined, fallback: '' }>} */
        const defaultOptions$1 = {
          initial: undefined,
          /**
           * Defaults to empty string, as that is preferred for usage with
           * <input />, <textarea />, and <select /> form elements.
           */
          fallback: ''
        };

        /**
         * Custom hooks for "controlled" components to track and consolidate internal
         * state and incoming values. This is useful for components that render
         * `input`, `textarea`, or `select` HTML elements.
         *
         * https://reactjs.org/docs/forms.html#controlled-components
         *
         * At first, a component using useControlledState receives an initial prop
         * value, which is used as initial internal state.
         *
         * This internal state can be maintained and updated without
         * relying on new incoming prop values.
         *
         * Unlike the basic useState hook, useControlledState's state can
         * be updated if a new incoming prop value is changed.
         *
         * @template T
         *
         * @param {T | undefined} currentState             The current value.
         * @param {Options<T>}    [options=defaultOptions] Additional options for the hook.
         *
         * @return {[T | "", (nextState: T) => void]} The controlled value and the value setter.
         */
        function useControlledState(currentState, options = defaultOptions$1) {
          const {
            initial,
            fallback
          } = {
            ...defaultOptions$1,
            ...options
          };
          const [internalState, setInternalState] = reactExports.useState(currentState);
          const hasCurrentState = isValueDefined(currentState);

          /*
           * Resets internal state if value every changes from uncontrolled <-> controlled.
           */
          reactExports.useEffect(() => {
            if (hasCurrentState && internalState) {
              setInternalState(undefined);
            }
          }, [hasCurrentState, internalState]);
          const state = getDefinedValue([currentState, internalState, initial], fallback);

          /* eslint-disable jsdoc/no-undefined-types */
          /** @type {(nextState: T) => void} */
          const setState = reactExports.useCallback(nextState => {
            if (!hasCurrentState) {
              setInternalState(nextState);
            }
          }, [hasCurrentState]);
          /* eslint-enable jsdoc/no-undefined-types */

          return [state, setState];
        }

        /**
         * WordPress dependencies
         */

        /**
         * A `React.useEffect` that will not run on the first render.
         * Source:
         * https://github.com/ariakit/ariakit/blob/main/packages/ariakit-react-core/src/utils/hooks.ts
         *
         * @param {import('react').EffectCallback} effect
         * @param {import('react').DependencyList} deps
         */
        function useUpdateEffect(effect, deps) {
          const mountedRef = reactExports.useRef(false);
          reactExports.useEffect(() => {
            if (mountedRef.current) {
              return effect();
            }
            mountedRef.current = true;
            return undefined;
            // 1. This hook needs to pass a dep list that isn't an array literal
            // 2. `effect` is missing from the array, and will need to be added carefully to avoid additional warnings
            // see https://github.com/WordPress/gutenberg/pull/41166
          }, deps);
          reactExports.useEffect(() => () => {
            mountedRef.current = false;
          }, []);
        }

        /**
         * WordPress dependencies
         */
        /**
         * Simplified and improved implementation of useControlledState.
         *
         * @param props
         * @param props.defaultValue
         * @param props.value
         * @param props.onChange
         * @return The controlled value and the value setter.
         */
        function useControlledValue({
          defaultValue,
          onChange,
          value: valueProp
        }) {
          const hasValue = typeof valueProp !== 'undefined';
          const initialValue = hasValue ? valueProp : defaultValue;
          const [state, setState] = reactExports.useState(initialValue);
          const value = hasValue ? valueProp : state;
          let setValue;
          if (hasValue && typeof onChange === 'function') {
            setValue = onChange;
          } else if (!hasValue && typeof onChange === 'function') {
            setValue = nextValue => {
              onChange(nextValue);
              setState(nextValue);
            };
          } else {
            setValue = setState;
          }
          return [value, setValue];
        }

        /*
        	Based off glamor's StyleSheet, thanks Sunil ❤️
        	high performance StyleSheet for css-in-js systems
        	- uses multiple style tags behind the scenes for millions of rules
        - uses `insertRule` for appending in production for *much* faster performance
        	// usage
        	import { StyleSheet } from '@emotion/sheet'
        	let styleSheet = new StyleSheet({ key: '', container: document.head })
        	styleSheet.insert('#box { border: 1px solid red; }')
        - appends a css rule into the stylesheet
        	styleSheet.flush()
        - empties the stylesheet of all its contents
        	*/

        function sheetForTag(tag) {
          if (tag.sheet) {
            return tag.sheet;
          } // this weirdness brought to you by firefox

          /* istanbul ignore next */

          for (var i = 0; i < document.styleSheets.length; i++) {
            if (document.styleSheets[i].ownerNode === tag) {
              return document.styleSheets[i];
            }
          } // this function should always return with a value
          // TS can't understand it though so we make it stop complaining here

          return undefined;
        }
        function createStyleElement(options) {
          var tag = document.createElement('style');
          tag.setAttribute('data-emotion', options.key);
          if (options.nonce !== undefined) {
            tag.setAttribute('nonce', options.nonce);
          }
          tag.appendChild(document.createTextNode(''));
          tag.setAttribute('data-s', '');
          return tag;
        }
        var StyleSheet = /*#__PURE__*/function () {
          // Using Node instead of HTMLElement since container may be a ShadowRoot
          function StyleSheet(options) {
            var _this = this;
            this._insertTag = function (tag) {
              var before;
              if (_this.tags.length === 0) {
                if (_this.insertionPoint) {
                  before = _this.insertionPoint.nextSibling;
                } else if (_this.prepend) {
                  before = _this.container.firstChild;
                } else {
                  before = _this.before;
                }
              } else {
                before = _this.tags[_this.tags.length - 1].nextSibling;
              }
              _this.container.insertBefore(tag, before);
              _this.tags.push(tag);
            };
            this.isSpeedy = options.speedy === undefined ? true : options.speedy;
            this.tags = [];
            this.ctr = 0;
            this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

            this.key = options.key;
            this.container = options.container;
            this.prepend = options.prepend;
            this.insertionPoint = options.insertionPoint;
            this.before = null;
          }
          var _proto = StyleSheet.prototype;
          _proto.hydrate = function hydrate(nodes) {
            nodes.forEach(this._insertTag);
          };
          _proto.insert = function insert(rule) {
            // the max length is how many rules we have per style tag, it's 65000 in speedy mode
            // it's 1 in dev because we insert source maps that map a single rule to a location
            // and you can only have one source map per style tag
            if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
              this._insertTag(createStyleElement(this));
            }
            var tag = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
              var sheet = sheetForTag(tag);
              try {
                // this is the ultrafast version, works across browsers
                // the big drawback is that the css won't be editable in devtools
                sheet.insertRule(rule, sheet.cssRules.length);
              } catch (e) {}
            } else {
              tag.appendChild(document.createTextNode(rule));
            }
            this.ctr++;
          };
          _proto.flush = function flush() {
            this.tags.forEach(function (tag) {
              var _tag$parentNode;
              return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
            });
            this.tags = [];
            this.ctr = 0;
          };
          return StyleSheet;
        }();
        var MS$1 = '-ms-';
        var MOZ$1 = '-moz-';
        var WEBKIT$1 = '-webkit-';
        var COMMENT$1 = 'comm';
        var RULESET$1 = 'rule';
        var DECLARATION$1 = 'decl';
        var IMPORT$1 = '@import';
        var KEYFRAMES$1 = '@keyframes';
        var LAYER$1 = '@layer';

        /**
         * @param {number}
         * @return {number}
         */
        var abs$1 = Math.abs;

        /**
         * @param {number}
         * @return {string}
         */
        var from$1 = String.fromCharCode;

        /**
         * @param {object}
         * @return {object}
         */
        var assign$1 = Object.assign;

        /**
         * @param {string} value
         * @param {number} length
         * @return {number}
         */
        function hash$1(value, length) {
          return charat$1(value, 0) ^ 45 ? (((length << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
        }

        /**
         * @param {string} value
         * @return {string}
         */
        function trim$1(value) {
          return value.trim();
        }

        /**
         * @param {string} value
         * @param {RegExp} pattern
         * @return {string?}
         */
        function match$1(value, pattern) {
          return (value = pattern.exec(value)) ? value[0] : value;
        }

        /**
         * @param {string} value
         * @param {(string|RegExp)} pattern
         * @param {string} replacement
         * @return {string}
         */
        function replace$1(value, pattern, replacement) {
          return value.replace(pattern, replacement);
        }

        /**
         * @param {string} value
         * @param {string} search
         * @return {number}
         */
        function indexof$1(value, search) {
          return value.indexOf(search);
        }

        /**
         * @param {string} value
         * @param {number} index
         * @return {number}
         */
        function charat$1(value, index) {
          return value.charCodeAt(index) | 0;
        }

        /**
         * @param {string} value
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function substr$1(value, begin, end) {
          return value.slice(begin, end);
        }

        /**
         * @param {string} value
         * @return {number}
         */
        function strlen$1(value) {
          return value.length;
        }

        /**
         * @param {any[]} value
         * @return {number}
         */
        function sizeof$1(value) {
          return value.length;
        }

        /**
         * @param {any} value
         * @param {any[]} array
         * @return {any}
         */
        function append$1(value, array) {
          return array.push(value), value;
        }

        /**
         * @param {string[]} array
         * @param {function} callback
         * @return {string}
         */
        function combine$1(array, callback) {
          return array.map(callback).join('');
        }
        var line$1 = 1;
        var column$1 = 1;
        var length$1 = 0;
        var position$1 = 0;
        var character$1 = 0;
        var characters$1 = '';

        /**
         * @param {string} value
         * @param {object | null} root
         * @param {object | null} parent
         * @param {string} type
         * @param {string[] | string} props
         * @param {object[] | string} children
         * @param {number} length
         */
        function node$1(value, root, parent, type, props, children, length) {
          return {
            value: value,
            root: root,
            parent: parent,
            type: type,
            props: props,
            children: children,
            line: line$1,
            column: column$1,
            length: length,
            return: ''
          };
        }

        /**
         * @param {object} root
         * @param {object} props
         * @return {object}
         */
        function copy$2(root, props) {
          return assign$1(node$1('', null, null, '', null, null, 0), root, {
            length: -root.length
          }, props);
        }

        /**
         * @return {number}
         */
        function char$1() {
          return character$1;
        }

        /**
         * @return {number}
         */
        function prev$1() {
          character$1 = position$1 > 0 ? charat$1(characters$1, --position$1) : 0;
          if (column$1--, character$1 === 10) column$1 = 1, line$1--;
          return character$1;
        }

        /**
         * @return {number}
         */
        function next$1() {
          character$1 = position$1 < length$1 ? charat$1(characters$1, position$1++) : 0;
          if (column$1++, character$1 === 10) column$1 = 1, line$1++;
          return character$1;
        }

        /**
         * @return {number}
         */
        function peek$1() {
          return charat$1(characters$1, position$1);
        }

        /**
         * @return {number}
         */
        function caret$1() {
          return position$1;
        }

        /**
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function slice$1(begin, end) {
          return substr$1(characters$1, begin, end);
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function token$1(type) {
          switch (type) {
            // \0 \t \n \r \s whitespace token
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
              return 5;
            // ! + , / > @ ~ isolate token
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            // ; { } breakpoint token
            case 59:
            case 123:
            case 125:
              return 4;
            // : accompanied token
            case 58:
              return 3;
            // " ' ( [ opening delimit token
            case 34:
            case 39:
            case 40:
            case 91:
              return 2;
            // ) ] closing delimit token
            case 41:
            case 93:
              return 1;
          }
          return 0;
        }

        /**
         * @param {string} value
         * @return {any[]}
         */
        function alloc$1(value) {
          return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$1 = 0, [];
        }

        /**
         * @param {any} value
         * @return {any}
         */
        function dealloc$1(value) {
          return characters$1 = '', value;
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function delimit$1(type) {
          return trim$1(slice$1(position$1 - 1, delimiter$1(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function whitespace$1(type) {
          while (character$1 = peek$1()) if (character$1 < 33) next$1();else break;
          return token$1(type) > 2 || token$1(character$1) > 3 ? '' : ' ';
        }

        /**
         * @param {number} index
         * @param {number} count
         * @return {string}
         */
        function escaping$1(index, count) {
          while (--count && next$1())
          // not 0-9 A-F a-f
          if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97) break;
          return slice$1(index, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function delimiter$1(type) {
          while (next$1()) switch (character$1) {
            // ] ) " '
            case type:
              return position$1;
            // " '
            case 34:
            case 39:
              if (type !== 34 && type !== 39) delimiter$1(character$1);
              break;
            // (
            case 40:
              if (type === 41) delimiter$1(type);
              break;
            // \
            case 92:
              next$1();
              break;
          }
          return position$1;
        }

        /**
         * @param {number} type
         * @param {number} index
         * @return {number}
         */
        function commenter$1(type, index) {
          while (next$1())
          // //
          if (type + character$1 === 47 + 10) break;
          // /*
          else if (type + character$1 === 42 + 42 && peek$1() === 47) break;
          return '/*' + slice$1(index, position$1 - 1) + '*' + from$1(type === 47 ? type : next$1());
        }

        /**
         * @param {number} index
         * @return {string}
         */
        function identifier$1(index) {
          while (!token$1(peek$1())) next$1();
          return slice$1(index, position$1);
        }

        /**
         * @param {string} value
         * @return {object[]}
         */
        function compile$1(value) {
          return dealloc$1(parse$2('', null, null, null, [''], value = alloc$1(value), 0, [0], value));
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {string[]} rule
         * @param {string[]} rules
         * @param {string[]} rulesets
         * @param {number[]} pseudo
         * @param {number[]} points
         * @param {string[]} declarations
         * @return {object}
         */
        function parse$2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
          var index = 0;
          var offset = 0;
          var length = pseudo;
          var atrule = 0;
          var property = 0;
          var previous = 0;
          var variable = 1;
          var scanning = 1;
          var ampersand = 1;
          var character = 0;
          var type = '';
          var props = rules;
          var children = rulesets;
          var reference = rule;
          var characters = type;
          while (scanning) switch (previous = character, character = next$1()) {
            // (
            case 40:
              if (previous != 108 && charat$1(characters, length - 1) == 58) {
                if (indexof$1(characters += replace$1(delimit$1(character), '&', '&\f'), '&\f') != -1) ampersand = -1;
                break;
              }
            // " ' [
            case 34:
            case 39:
            case 91:
              characters += delimit$1(character);
              break;
            // \t \n \r \s
            case 9:
            case 10:
            case 13:
            case 32:
              characters += whitespace$1(previous);
              break;
            // \
            case 92:
              characters += escaping$1(caret$1() - 1, 7);
              continue;
            // /
            case 47:
              switch (peek$1()) {
                case 42:
                case 47:
                  append$1(comment$1(commenter$1(next$1(), caret$1()), root, parent), declarations);
                  break;
                default:
                  characters += '/';
              }
              break;
            // {
            case 123 * variable:
              points[index++] = strlen$1(characters) * ampersand;
            // } ; \0
            case 125 * variable:
            case 59:
            case 0:
              switch (character) {
                // \0 }
                case 0:
                case 125:
                  scanning = 0;
                // ;
                case 59 + offset:
                  if (ampersand == -1) characters = replace$1(characters, /\f/g, '');
                  if (property > 0 && strlen$1(characters) - length) append$1(property > 32 ? declaration$1(characters + ';', rule, parent, length - 1) : declaration$1(replace$1(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
                  break;
                // @ ;
                case 59:
                  characters += ';';
                // { rule/at-rule
                default:
                  append$1(reference = ruleset$1(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
                  if (character === 123) if (offset === 0) parse$2(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule === 99 && charat$1(characters, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse$2(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                      break;
                    default:
                      parse$2(characters, reference, reference, reference, [''], children, 0, points, children);
                  }
              }
              index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
              break;
            // :
            case 58:
              length = 1 + strlen$1(characters), property = previous;
            default:
              if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev$1() == 125) continue;
              switch (characters += from$1(character), character * variable) {
                // &
                case 38:
                  ampersand = offset > 0 ? 1 : (characters += '\f', -1);
                  break;
                // ,
                case 44:
                  points[index++] = (strlen$1(characters) - 1) * ampersand, ampersand = 1;
                  break;
                // @
                case 64:
                  // -
                  if (peek$1() === 45) characters += delimit$1(next$1());
                  atrule = peek$1(), offset = length = strlen$1(type = characters += identifier$1(caret$1())), character++;
                  break;
                // -
                case 45:
                  if (previous === 45 && strlen$1(characters) == 2) variable = 0;
              }
          }
          return rulesets;
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} index
         * @param {number} offset
         * @param {string[]} rules
         * @param {number[]} points
         * @param {string} type
         * @param {string[]} props
         * @param {string[]} children
         * @param {number} length
         * @return {object}
         */
        function ruleset$1(value, root, parent, index, offset, rules, points, type, props, children, length) {
          var post = offset - 1;
          var rule = offset === 0 ? rules : [''];
          var size = sizeof$1(rule);
          for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr$1(value, post + 1, post = abs$1(j = points[i])), z = value; x < size; ++x) if (z = trim$1(j > 0 ? rule[x] + ' ' + y : replace$1(y, /&\f/g, rule[x]))) props[k++] = z;
          return node$1(value, root, parent, offset === 0 ? RULESET$1 : type, props, children, length);
        }

        /**
         * @param {number} value
         * @param {object} root
         * @param {object?} parent
         * @return {object}
         */
        function comment$1(value, root, parent) {
          return node$1(value, root, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0);
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} length
         * @return {object}
         */
        function declaration$1(value, root, parent, length) {
          return node$1(value, root, parent, DECLARATION$1, substr$1(value, 0, length), substr$1(value, length + 1, -1), length);
        }

        /**
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function serialize$1(children, callback) {
          var output = '';
          var length = sizeof$1(children);
          for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';
          return output;
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function stringify$1(element, index, children, callback) {
          switch (element.type) {
            case LAYER$1:
              if (element.children.length) break;
            case IMPORT$1:
            case DECLARATION$1:
              return element.return = element.return || element.value;
            case COMMENT$1:
              return '';
            case KEYFRAMES$1:
              return element.return = element.value + '{' + serialize$1(element.children, callback) + '}';
            case RULESET$1:
              element.value = element.props.join(',');
          }
          return strlen$1(children = serialize$1(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
        }

        /**
         * @param {function[]} collection
         * @return {function}
         */
        function middleware$1(collection) {
          var length = sizeof$1(collection);
          return function (element, index, children, callback) {
            var output = '';
            for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
            return output;
          };
        }

        /**
         * @param {function} callback
         * @return {function}
         */
        function rulesheet$1(callback) {
          return function (element) {
            if (!element.root) if (element = element.return) callback(element);
          };
        }
        function memoize(fn) {
          var cache = Object.create(null);
          return function (arg) {
            if (cache[arg] === undefined) cache[arg] = fn(arg);
            return cache[arg];
          };
        }
        var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
          var previous = 0;
          var character = 0;
          while (true) {
            previous = character;
            character = peek$1(); // &\f

            if (previous === 38 && character === 12) {
              points[index] = 1;
            }
            if (token$1(character)) {
              break;
            }
            next$1();
          }
          return slice$1(begin, position$1);
        };
        var toRules = function toRules(parsed, points) {
          // pretend we've started with a comma
          var index = -1;
          var character = 44;
          do {
            switch (token$1(character)) {
              case 0:
                // &\f
                if (character === 38 && peek$1() === 12) {
                  // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
                  // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
                  // and when it should just concatenate the outer and inner selectors
                  // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
                  points[index] = 1;
                }
                parsed[index] += identifierWithPointTracking(position$1 - 1, points, index);
                break;
              case 2:
                parsed[index] += delimit$1(character);
                break;
              case 4:
                // comma
                if (character === 44) {
                  // colon
                  parsed[++index] = peek$1() === 58 ? '&\f' : '';
                  points[index] = parsed[index].length;
                  break;
                }

              // fallthrough

              default:
                parsed[index] += from$1(character);
            }
          } while (character = next$1());
          return parsed;
        };
        var getRules = function getRules(value, points) {
          return dealloc$1(toRules(alloc$1(value), points));
        }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11

        var fixedElements = /* #__PURE__ */new WeakMap();
        var compat = function compat(element) {
          if (element.type !== 'rule' || !element.parent ||
          // positive .length indicates that this rule contains pseudo
          // negative .length indicates that this rule has been already prefixed
          element.length < 1) {
            return;
          }
          var value = element.value;
          var parent = element.parent;
          var isImplicitRule = element.column === parent.column && element.line === parent.line;
          while (parent.type !== 'rule') {
            parent = parent.parent;
            if (!parent) return;
          } // short-circuit for the simplest case

          if (element.props.length === 1 && value.charCodeAt(0) !== 58
          /* colon */ && !fixedElements.get(parent)) {
            return;
          } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
          // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"

          if (isImplicitRule) {
            return;
          }
          fixedElements.set(element, true);
          var points = [];
          var rules = getRules(value, points);
          var parentRules = parent.props;
          for (var i = 0, k = 0; i < rules.length; i++) {
            for (var j = 0; j < parentRules.length; j++, k++) {
              element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
            }
          }
        };
        var removeLabel = function removeLabel(element) {
          if (element.type === 'decl') {
            var value = element.value;
            if (
            // charcode for l
            value.charCodeAt(0) === 108 &&
            // charcode for b
            value.charCodeAt(2) === 98) {
              // this ignores label
              element["return"] = '';
              element.value = '';
            }
          }
        };

        /* eslint-disable no-fallthrough */

        function prefix$1(value, length) {
          switch (hash$1(value, length)) {
            // color-adjust
            case 5103:
              return WEBKIT$1 + 'print-' + value + value;
            // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return WEBKIT$1 + value + value;
            // appearance, user-select, transform, hyphens, text-size-adjust

            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
            // flex, flex-direction

            case 6828:
            case 4268:
              return WEBKIT$1 + value + MS$1 + value + value;
            // order

            case 6165:
              return WEBKIT$1 + value + MS$1 + 'flex-' + value + value;
            // align-items

            case 5187:
              return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + 'box-$1$2' + MS$1 + 'flex-$1$2') + value;
            // align-self

            case 5443:
              return WEBKIT$1 + value + MS$1 + 'flex-item-' + replace$1(value, /flex-|-self/, '') + value;
            // align-content

            case 4675:
              return WEBKIT$1 + value + MS$1 + 'flex-line-pack' + replace$1(value, /align-content|flex-|-self/, '') + value;
            // flex-shrink

            case 5548:
              return WEBKIT$1 + value + MS$1 + replace$1(value, 'shrink', 'negative') + value;
            // flex-basis

            case 5292:
              return WEBKIT$1 + value + MS$1 + replace$1(value, 'basis', 'preferred-size') + value;
            // flex-grow

            case 6060:
              return WEBKIT$1 + 'box-' + replace$1(value, '-grow', '') + WEBKIT$1 + value + MS$1 + replace$1(value, 'grow', 'positive') + value;
            // transition

            case 4554:
              return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, '$1' + WEBKIT$1 + '$2') + value;
            // cursor

            case 6187:
              return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + '$1'), /(image-set)/, WEBKIT$1 + '$1'), value, '') + value;
            // background, background-image

            case 5495:
            case 3959:
              return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + '$1' + '$`$1');
            // justify-content

            case 4968:
              return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + 'box-pack:$3' + MS$1 + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT$1 + value + value;
            // (margin|padding)-inline-(start|end)

            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + '$1$2') + value;
            // (min|max)?(width|height|inline-size|block-size)

            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              // stretch, max-content, min-content, fill-available
              if (strlen$1(value) - 1 - length > 6) switch (charat$1(value, length + 1)) {
                // (m)ax-content, (m)in-content
                case 109:
                  // -
                  if (charat$1(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content

                case 102:
                  return replace$1(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT$1 + '$2-$3' + '$1' + MOZ$1 + (charat$1(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                // (s)tretch

                case 115:
                  return ~indexof$1(value, 'stretch') ? prefix$1(replace$1(value, 'stretch', 'fill-available'), length) + value : value;
              }
              break;
            // position: sticky

            case 4949:
              // (s)ticky?
              if (charat$1(value, length + 1) !== 115) break;
            // display: (flex|inline-flex)

            case 6444:
              switch (charat$1(value, strlen$1(value) - 3 - (~indexof$1(value, '!important') && 10))) {
                // stic(k)y
                case 107:
                  return replace$1(value, ':', ':' + WEBKIT$1) + value;
                // (inline-)?fl(e)x

                case 101:
                  return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT$1 + (charat$1(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT$1 + '$2$3' + '$1' + MS$1 + '$2box$3') + value;
              }
              break;
            // writing-mode

            case 5936:
              switch (charat$1(value, length + 11)) {
                // vertical-l(r)
                case 114:
                  return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                // vertical-r(l)

                case 108:
                  return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                // horizontal(-)tb

                case 45:
                  return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
              }
              return WEBKIT$1 + value + MS$1 + value + value;
          }
          return value;
        }
        var prefixer$1 = function prefixer(element, index, children, callback) {
          if (element.length > -1) if (!element["return"]) switch (element.type) {
            case DECLARATION$1:
              element["return"] = prefix$1(element.value, element.length);
              break;
            case KEYFRAMES$1:
              return serialize$1([copy$2(element, {
                value: replace$1(element.value, '@', '@' + WEBKIT$1)
              })], callback);
            case RULESET$1:
              if (element.length) return combine$1(element.props, function (value) {
                switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ':read-only':
                  case ':read-write':
                    return serialize$1([copy$2(element, {
                      props: [replace$1(value, /:(read-\w+)/, ':' + MOZ$1 + '$1')]
                    })], callback);
                  // :placeholder

                  case '::placeholder':
                    return serialize$1([copy$2(element, {
                      props: [replace$1(value, /:(plac\w+)/, ':' + WEBKIT$1 + 'input-$1')]
                    }), copy$2(element, {
                      props: [replace$1(value, /:(plac\w+)/, ':' + MOZ$1 + '$1')]
                    }), copy$2(element, {
                      props: [replace$1(value, /:(plac\w+)/, MS$1 + 'input-$1')]
                    })], callback);
                }
                return '';
              });
          }
        };
        var defaultStylisPlugins = [prefixer$1];
        var createCache = function createCache(options) {
          var key = options.key;
          if (key === 'css') {
            var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
            // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
            // note this very very intentionally targets all style elements regardless of the key to ensure
            // that creating a cache works inside of render of a React component

            Array.prototype.forEach.call(ssrStyles, function (node) {
              // we want to only move elements which have a space in the data-emotion attribute value
              // because that indicates that it is an Emotion 11 server-side rendered style elements
              // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
              // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
              // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
              // will not result in the Emotion 10 styles being destroyed
              var dataEmotionAttribute = node.getAttribute('data-emotion');
              if (dataEmotionAttribute.indexOf(' ') === -1) {
                return;
              }
              document.head.appendChild(node);
              node.setAttribute('data-s', '');
            });
          }
          var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
          var inserted = {};
          var container;
          var nodesToHydrate = [];
          {
            container = options.container || document.head;
            Array.prototype.forEach.call(
            // this means we will ignore elements which don't have a space in them which
            // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
            document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
              var attrib = node.getAttribute("data-emotion").split(' ');
              for (var i = 1; i < attrib.length; i++) {
                inserted[attrib[i]] = true;
              }
              nodesToHydrate.push(node);
            });
          }
          var _insert;
          var omnipresentPlugins = [compat, removeLabel];
          {
            var currentSheet;
            var finalizingPlugins = [stringify$1, rulesheet$1(function (rule) {
              currentSheet.insert(rule);
            })];
            var serializer = middleware$1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
            var stylis = function stylis(styles) {
              return serialize$1(compile$1(styles), serializer);
            };
            _insert = function insert(selector, serialized, sheet, shouldCache) {
              currentSheet = sheet;
              stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
              if (shouldCache) {
                cache.inserted[serialized.name] = true;
              }
            };
          }
          var cache = {
            key: key,
            sheet: new StyleSheet({
              key: key,
              container: container,
              nonce: options.nonce,
              speedy: options.speedy,
              prepend: options.prepend,
              insertionPoint: options.insertionPoint
            }),
            nonce: options.nonce,
            inserted: inserted,
            registered: {},
            insert: _insert
          };
          cache.sheet.hydrate(nodesToHydrate);
          return cache;
        };
        function _extends() {
          return _extends = Object.assign ? Object.assign.bind() : function (n) {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
            }
            return n;
          }, _extends.apply(null, arguments);
        }
        var reactIs$1 = {
          exports: {}
        };
        var reactIs_production_min = {};

        /** @license React v16.13.1
         * react-is.production.min.js
         *
         * Copyright (c) Facebook, Inc. and its affiliates.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */
        var b$2 = "function" === typeof Symbol && Symbol.for,
          c$2 = b$2 ? Symbol.for("react.element") : 60103,
          d$2 = b$2 ? Symbol.for("react.portal") : 60106,
          e$1 = b$2 ? Symbol.for("react.fragment") : 60107,
          f$3 = b$2 ? Symbol.for("react.strict_mode") : 60108,
          g$3 = b$2 ? Symbol.for("react.profiler") : 60114,
          h$2 = b$2 ? Symbol.for("react.provider") : 60109,
          k$3 = b$2 ? Symbol.for("react.context") : 60110,
          l$1 = b$2 ? Symbol.for("react.async_mode") : 60111,
          m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111,
          n$1 = b$2 ? Symbol.for("react.forward_ref") : 60112,
          p$2 = b$2 ? Symbol.for("react.suspense") : 60113,
          q$2 = b$2 ? Symbol.for("react.suspense_list") : 60120,
          r$1 = b$2 ? Symbol.for("react.memo") : 60115,
          t$1 = b$2 ? Symbol.for("react.lazy") : 60116,
          v$3 = b$2 ? Symbol.for("react.block") : 60121,
          w$2 = b$2 ? Symbol.for("react.fundamental") : 60117,
          x$2 = b$2 ? Symbol.for("react.responder") : 60118,
          y$3 = b$2 ? Symbol.for("react.scope") : 60119;
        function z$2(a) {
          if ("object" === typeof a && null !== a) {
            var u = a.$$typeof;
            switch (u) {
              case c$2:
                switch (a = a.type, a) {
                  case l$1:
                  case m$3:
                  case e$1:
                  case g$3:
                  case f$3:
                  case p$2:
                    return a;
                  default:
                    switch (a = a && a.$$typeof, a) {
                      case k$3:
                      case n$1:
                      case t$1:
                      case r$1:
                      case h$2:
                        return a;
                      default:
                        return u;
                    }
                }
              case d$2:
                return u;
            }
          }
        }
        function A$1(a) {
          return z$2(a) === m$3;
        }
        reactIs_production_min.AsyncMode = l$1;
        reactIs_production_min.ConcurrentMode = m$3;
        reactIs_production_min.ContextConsumer = k$3;
        reactIs_production_min.ContextProvider = h$2;
        reactIs_production_min.Element = c$2;
        reactIs_production_min.ForwardRef = n$1;
        reactIs_production_min.Fragment = e$1;
        reactIs_production_min.Lazy = t$1;
        reactIs_production_min.Memo = r$1;
        reactIs_production_min.Portal = d$2;
        reactIs_production_min.Profiler = g$3;
        reactIs_production_min.StrictMode = f$3;
        reactIs_production_min.Suspense = p$2;
        reactIs_production_min.isAsyncMode = function (a) {
          return A$1(a) || z$2(a) === l$1;
        };
        reactIs_production_min.isConcurrentMode = A$1;
        reactIs_production_min.isContextConsumer = function (a) {
          return z$2(a) === k$3;
        };
        reactIs_production_min.isContextProvider = function (a) {
          return z$2(a) === h$2;
        };
        reactIs_production_min.isElement = function (a) {
          return "object" === typeof a && null !== a && a.$$typeof === c$2;
        };
        reactIs_production_min.isForwardRef = function (a) {
          return z$2(a) === n$1;
        };
        reactIs_production_min.isFragment = function (a) {
          return z$2(a) === e$1;
        };
        reactIs_production_min.isLazy = function (a) {
          return z$2(a) === t$1;
        };
        reactIs_production_min.isMemo = function (a) {
          return z$2(a) === r$1;
        };
        reactIs_production_min.isPortal = function (a) {
          return z$2(a) === d$2;
        };
        reactIs_production_min.isProfiler = function (a) {
          return z$2(a) === g$3;
        };
        reactIs_production_min.isStrictMode = function (a) {
          return z$2(a) === f$3;
        };
        reactIs_production_min.isSuspense = function (a) {
          return z$2(a) === p$2;
        };
        reactIs_production_min.isValidElementType = function (a) {
          return "string" === typeof a || "function" === typeof a || a === e$1 || a === m$3 || a === g$3 || a === f$3 || a === p$2 || a === q$2 || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r$1 || a.$$typeof === h$2 || a.$$typeof === k$3 || a.$$typeof === n$1 || a.$$typeof === w$2 || a.$$typeof === x$2 || a.$$typeof === y$3 || a.$$typeof === v$3);
        };
        reactIs_production_min.typeOf = z$2;
        {
          reactIs$1.exports = reactIs_production_min;
        }
        var reactIsExports = reactIs$1.exports;
        var reactIs = reactIsExports;
        var FORWARD_REF_STATICS = {
          '$$typeof': true,
          render: true,
          defaultProps: true,
          displayName: true,
          propTypes: true
        };
        var MEMO_STATICS = {
          '$$typeof': true,
          compare: true,
          defaultProps: true,
          displayName: true,
          propTypes: true,
          type: true
        };
        var TYPE_STATICS = {};
        TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
        TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
        var isBrowser$1 = true;
        function getRegisteredStyles(registered, registeredStyles, classNames) {
          var rawClassName = '';
          classNames.split(' ').forEach(function (className) {
            if (registered[className] !== undefined) {
              registeredStyles.push(registered[className] + ";");
            } else if (className) {
              rawClassName += className + " ";
            }
          });
          return rawClassName;
        }
        var registerStyles = function registerStyles(cache, serialized, isStringTag) {
          var className = cache.key + "-" + serialized.name;
          if (
          // we only need to add the styles to the registered cache if the
          // class name could be used further down
          // the tree but if it's a string tag, we know it won't
          // so we don't have to add it to registered cache.
          // this improves memory usage since we can avoid storing the whole style string
          (isStringTag === false ||
          // we need to always store it if we're in compat mode and
          // in node since emotion-server relies on whether a style is in
          // the registered cache to know whether a style is global or not
          // also, note that this check will be dead code eliminated in the browser
          isBrowser$1 === false) && cache.registered[className] === undefined) {
            cache.registered[className] = serialized.styles;
          }
        };
        var insertStyles = function insertStyles(cache, serialized, isStringTag) {
          registerStyles(cache, serialized, isStringTag);
          var className = cache.key + "-" + serialized.name;
          if (cache.inserted[serialized.name] === undefined) {
            var current = serialized;
            do {
              cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
              current = current.next;
            } while (current !== undefined);
          }
        };

        /* eslint-disable */
        // Inspired by https://github.com/garycourt/murmurhash-js
        // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
        function murmur2(str) {
          // 'm' and 'r' are mixing constants generated offline.
          // They're not really 'magic', they just happen to work well.
          // const m = 0x5bd1e995;
          // const r = 24;
          // Initialize the hash
          var h = 0; // Mix 4 bytes at a time into the hash

          var k,
            i = 0,
            len = str.length;
          for (; len >= 4; ++i, len -= 4) {
            k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
            k = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
            k ^= /* k >>> r: */
            k >>> 24;
            h = /* Math.imul(k, m): */
            (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */
            (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Handle the last few bytes of the input array

          switch (len) {
            case 3:
              h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
            case 2:
              h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
            case 1:
              h ^= str.charCodeAt(i) & 0xff;
              h = /* Math.imul(h, m): */
              (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          } // Do a few final mixes of the hash to ensure the last few
          // bytes are well-incorporated.

          h ^= h >>> 13;
          h = /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
          return ((h ^ h >>> 15) >>> 0).toString(36);
        }
        var unitlessKeys$1 = {
          animationIterationCount: 1,
          aspectRatio: 1,
          borderImageOutset: 1,
          borderImageSlice: 1,
          borderImageWidth: 1,
          boxFlex: 1,
          boxFlexGroup: 1,
          boxOrdinalGroup: 1,
          columnCount: 1,
          columns: 1,
          flex: 1,
          flexGrow: 1,
          flexPositive: 1,
          flexShrink: 1,
          flexNegative: 1,
          flexOrder: 1,
          gridRow: 1,
          gridRowEnd: 1,
          gridRowSpan: 1,
          gridRowStart: 1,
          gridColumn: 1,
          gridColumnEnd: 1,
          gridColumnSpan: 1,
          gridColumnStart: 1,
          msGridRow: 1,
          msGridRowSpan: 1,
          msGridColumn: 1,
          msGridColumnSpan: 1,
          fontWeight: 1,
          lineHeight: 1,
          opacity: 1,
          order: 1,
          orphans: 1,
          scale: 1,
          tabSize: 1,
          widows: 1,
          zIndex: 1,
          zoom: 1,
          WebkitLineClamp: 1,
          // SVG-related properties
          fillOpacity: 1,
          floodOpacity: 1,
          stopOpacity: 1,
          strokeDasharray: 1,
          strokeDashoffset: 1,
          strokeMiterlimit: 1,
          strokeOpacity: 1,
          strokeWidth: 1
        };
        var hyphenateRegex = /[A-Z]|^ms/g;
        var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
        var isCustomProperty = function isCustomProperty(property) {
          return property.charCodeAt(1) === 45;
        };
        var isProcessableValue = function isProcessableValue(value) {
          return value != null && typeof value !== 'boolean';
        };
        var processStyleName = /* #__PURE__ */memoize(function (styleName) {
          return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
        });
        var processStyleValue = function processStyleValue(key, value) {
          switch (key) {
            case 'animation':
            case 'animationName':
              {
                if (typeof value === 'string') {
                  return value.replace(animationRegex, function (match, p1, p2) {
                    cursor = {
                      name: p1,
                      styles: p2,
                      next: cursor
                    };
                    return p1;
                  });
                }
              }
          }
          if (unitlessKeys$1[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
            return value + 'px';
          }
          return value;
        };
        function handleInterpolation(mergedProps, registered, interpolation) {
          if (interpolation == null) {
            return '';
          }
          var componentSelector = interpolation;
          if (componentSelector.__emotion_styles !== undefined) {
            return componentSelector;
          }
          switch (typeof interpolation) {
            case 'boolean':
              {
                return '';
              }
            case 'object':
              {
                var keyframes = interpolation;
                if (keyframes.anim === 1) {
                  cursor = {
                    name: keyframes.name,
                    styles: keyframes.styles,
                    next: cursor
                  };
                  return keyframes.name;
                }
                var serializedStyles = interpolation;
                if (serializedStyles.styles !== undefined) {
                  var next = serializedStyles.next;
                  if (next !== undefined) {
                    // not the most efficient thing ever but this is a pretty rare case
                    // and there will be very few iterations of this generally
                    while (next !== undefined) {
                      cursor = {
                        name: next.name,
                        styles: next.styles,
                        next: cursor
                      };
                      next = next.next;
                    }
                  }
                  var styles = serializedStyles.styles + ";";
                  return styles;
                }
                return createStringFromObject(mergedProps, registered, interpolation);
              }
            case 'function':
              {
                if (mergedProps !== undefined) {
                  var previousCursor = cursor;
                  var result = interpolation(mergedProps);
                  cursor = previousCursor;
                  return handleInterpolation(mergedProps, registered, result);
                }
                break;
              }
          } // finalize string values (regular strings and functions interpolated into css calls)

          var asString = interpolation;
          if (registered == null) {
            return asString;
          }
          var cached = registered[asString];
          return cached !== undefined ? cached : asString;
        }
        function createStringFromObject(mergedProps, registered, obj) {
          var string = '';
          if (Array.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
            }
          } else {
            for (var key in obj) {
              var value = obj[key];
              if (typeof value !== 'object') {
                var asString = value;
                if (registered != null && registered[asString] !== undefined) {
                  string += key + "{" + registered[asString] + "}";
                } else if (isProcessableValue(asString)) {
                  string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
                }
              } else {
                if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
                  for (var _i = 0; _i < value.length; _i++) {
                    if (isProcessableValue(value[_i])) {
                      string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
                    }
                  }
                } else {
                  var interpolated = handleInterpolation(mergedProps, registered, value);
                  switch (key) {
                    case 'animation':
                    case 'animationName':
                      {
                        string += processStyleName(key) + ":" + interpolated + ";";
                        break;
                      }
                    default:
                      {
                        string += key + "{" + interpolated + "}";
                      }
                  }
                }
              }
            }
          }
          return string;
        }
        var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
        // keyframes are stored on the SerializedStyles object as a linked list

        var cursor;
        function serializeStyles(args, registered, mergedProps) {
          if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
            return args[0];
          }
          var stringMode = true;
          var styles = '';
          cursor = undefined;
          var strings = args[0];
          if (strings == null || strings.raw === undefined) {
            stringMode = false;
            styles += handleInterpolation(mergedProps, registered, strings);
          } else {
            var asTemplateStringsArr = strings;
            styles += asTemplateStringsArr[0];
          } // we start at 1 since we've already handled the first arg

          for (var i = 1; i < args.length; i++) {
            styles += handleInterpolation(mergedProps, registered, args[i]);
            if (stringMode) {
              var templateStringsArr = strings;
              styles += templateStringsArr[i];
            }
          } // using a global regex with .exec is stateful so lastIndex has to be reset each time

          labelPattern.lastIndex = 0;
          var identifierName = '';
          var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

          while ((match = labelPattern.exec(styles)) !== null) {
            identifierName += '-' + match[1];
          }
          var name = murmur2(styles) + identifierName;
          return {
            name: name,
            styles: styles,
            next: cursor
          };
        }
        var syncFallback = function syncFallback(create) {
          return create();
        };
        var useInsertionEffect = React$2['useInsertion' + 'Effect'] ? React$2['useInsertion' + 'Effect'] : false;
        var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
        var EmotionCacheContext = /* #__PURE__ */reactExports.createContext(
        // we're doing this to avoid preconstruct's dead code elimination in this one case
        // because this module is primarily intended for the browser and node
        // but it's also required in react native and similar environments sometimes
        // and we could have a special build just for that
        // but this is much easier and the native packages
        // might use a different theme context in the future anyway
        typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
          key: 'css'
        }) : null);
        var CacheProvider = EmotionCacheContext.Provider;
        var __unsafe_useEmotionCache = function useEmotionCache() {
          return reactExports.useContext(EmotionCacheContext);
        };
        var withEmotionCache = function withEmotionCache(func) {
          return /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
            // the cache will never be null in the browser
            var cache = reactExports.useContext(EmotionCacheContext);
            return func(props, cache, ref);
          });
        };
        var ThemeContext = /* #__PURE__ */reactExports.createContext({});
        var hasOwn = {}.hasOwnProperty;
        var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
        var createEmotionProps = function createEmotionProps(type, props) {
          var newProps = {};
          for (var _key in props) {
            if (hasOwn.call(props, _key)) {
              newProps[_key] = props[_key];
            }
          }
          newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:

          return newProps;
        };
        var Insertion$1 = function Insertion(_ref) {
          var cache = _ref.cache,
            serialized = _ref.serialized,
            isStringTag = _ref.isStringTag;
          registerStyles(cache, serialized, isStringTag);
          useInsertionEffectAlwaysWithSyncFallback(function () {
            return insertStyles(cache, serialized, isStringTag);
          });
          return null;
        };
        var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
          var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
          // not passing the registered cache to serializeStyles because it would
          // make certain babel optimisations not possible

          if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
            cssProp = cache.registered[cssProp];
          }
          var WrappedComponent = props[typePropName];
          var registeredStyles = [cssProp];
          var className = '';
          if (typeof props.className === 'string') {
            className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serializeStyles(registeredStyles, undefined, reactExports.useContext(ThemeContext));
          className += cache.key + "-" + serialized.name;
          var newProps = {};
          for (var _key2 in props) {
            if (hasOwn.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && true) {
              newProps[_key2] = props[_key2];
            }
          }
          newProps.className = className;
          if (ref) {
            newProps.ref = ref;
          }
          return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion$1, {
            cache: cache,
            serialized: serialized,
            isStringTag: typeof WrappedComponent === 'string'
          }), /*#__PURE__*/reactExports.createElement(WrappedComponent, newProps));
        });
        var Emotion$1 = Emotion;
        var jsx = function jsx(type, props) {
          // eslint-disable-next-line prefer-rest-params
          var args = arguments;
          if (props == null || !hasOwn.call(props, 'css')) {
            return reactExports.createElement.apply(undefined, args);
          }
          var argsLength = args.length;
          var createElementArgArray = new Array(argsLength);
          createElementArgArray[0] = Emotion$1;
          createElementArgArray[1] = createEmotionProps(type, props);
          for (var i = 2; i < argsLength; i++) {
            createElementArgArray[i] = args[i];
          }
          return reactExports.createElement.apply(null, createElementArgArray);
        };
        (function (_jsx) {
          var JSX;
          (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
        })(jsx || (jsx = {}));
        function css() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return serializeStyles(args);
        }
        function insertWithoutScoping(cache, serialized) {
          if (cache.inserted[serialized.name] === undefined) {
            return cache.insert('', serialized, cache.sheet, true);
          }
        }
        function merge(registered, css, className) {
          var registeredStyles = [];
          var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
          if (registeredStyles.length < 2) {
            return className;
          }
          return rawClassName + css(registeredStyles);
        }
        var createEmotion = function createEmotion(options) {
          var cache = createCache(options);
          cache.sheet.speedy = function (value) {
            this.isSpeedy = value;
          };
          cache.compat = true;
          var css = function css() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var serialized = serializeStyles(args, cache.registered, undefined);
            insertStyles(cache, serialized, false);
            return cache.key + "-" + serialized.name;
          };
          var keyframes = function keyframes() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            var serialized = serializeStyles(args, cache.registered);
            var animation = "animation-" + serialized.name;
            insertWithoutScoping(cache, {
              name: serialized.name,
              styles: "@keyframes " + animation + "{" + serialized.styles + "}"
            });
            return animation;
          };
          var injectGlobal = function injectGlobal() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            var serialized = serializeStyles(args, cache.registered);
            insertWithoutScoping(cache, serialized);
          };
          var cx = function cx() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            return merge(cache.registered, css, classnames(args));
          };
          return {
            css: css,
            cx: cx,
            injectGlobal: injectGlobal,
            keyframes: keyframes,
            hydrate: function hydrate(ids) {
              ids.forEach(function (key) {
                cache.inserted[key] = true;
              });
            },
            flush: function flush() {
              cache.registered = {};
              cache.inserted = {};
              cache.sheet.flush();
            },
            sheet: cache.sheet,
            cache: cache,
            getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),
            merge: merge.bind(null, cache.registered, css)
          };
        };
        var classnames = function classnames(args) {
          var cls = '';
          for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            if (arg == null) continue;
            var toAdd = void 0;
            switch (typeof arg) {
              case 'boolean':
                break;
              case 'object':
                {
                  if (Array.isArray(arg)) {
                    toAdd = classnames(arg);
                  } else {
                    toAdd = '';
                    for (var k in arg) {
                      if (arg[k] && k) {
                        toAdd && (toAdd += ' ');
                        toAdd += k;
                      }
                    }
                  }
                  break;
                }
              default:
                {
                  toAdd = arg;
                }
            }
            if (toAdd) {
              cls && (cls += ' ');
              cls += toAdd;
            }
          }
          return cls;
        };
        var _createEmotion = createEmotion({
            key: 'css'
          }),
          cx = _createEmotion.cx;

        /**
         * External dependencies
         */
        const isSerializedStyles = o => typeof o !== 'undefined' && o !== null && ['name', 'styles'].every(p => typeof o[p] !== 'undefined');

        /**
         * Retrieve a `cx` function that knows how to handle `SerializedStyles`
         * returned by the `@emotion/react` `css` function in addition to what
         * `cx` normally knows how to handle. It also hooks into the Emotion
         * Cache, allowing `css` calls to work inside iframes.
         *
         * ```jsx
         * import { css } from '@emotion/react';
         *
         * const styles = css`
         * 	color: red
         * `;
         *
         * function RedText( { className, ...props } ) {
         * 	const cx = useCx();
         *
         * 	const classes = cx(styles, className);
         *
         * 	return <span className={classes} {...props} />;
         * }
         * ```
         */
        const useCx = () => {
          const cache = __unsafe_useEmotionCache();
          const cx$1 = reactExports.useCallback((...classNames) => {
            if (cache === null) {
              throw new Error('The `useCx` hook should be only used within a valid Emotion Cache Context');
            }
            return cx(...classNames.map(arg => {
              if (isSerializedStyles(arg)) {
                insertStyles(cache, arg, false);
                return `${cache.key}-${arg.name}`;
              }
              return arg;
            }));
          }, [cache]);
          return cx$1;
        };
        const boxSizingReset = {
          name: "kv6lnz",
          styles: "box-sizing:border-box;*,*::before,*::after{box-sizing:inherit;}"
        };
        var r = {
            grad: .9,
            turn: 360,
            rad: 360 / (2 * Math.PI)
          },
          t = function (r) {
            return "string" == typeof r ? r.length > 0 : "number" == typeof r;
          },
          n = function (r, t, n) {
            return void 0 === t && (t = 0), void 0 === n && (n = Math.pow(10, t)), Math.round(n * r) / n + 0;
          },
          e = function (r, t, n) {
            return void 0 === t && (t = 0), void 0 === n && (n = 1), r > n ? n : r > t ? r : t;
          },
          u$1 = function (r) {
            return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;
          },
          a = function (r) {
            return {
              r: e(r.r, 0, 255),
              g: e(r.g, 0, 255),
              b: e(r.b, 0, 255),
              a: e(r.a)
            };
          },
          o = function (r) {
            return {
              r: n(r.r),
              g: n(r.g),
              b: n(r.b),
              a: n(r.a, 3)
            };
          },
          i$1 = /^#([0-9a-f]{3,8})$/i,
          s$1 = function (r) {
            var t = r.toString(16);
            return t.length < 2 ? "0" + t : t;
          },
          h$1 = function (r) {
            var t = r.r,
              n = r.g,
              e = r.b,
              u = r.a,
              a = Math.max(t, n, e),
              o = a - Math.min(t, n, e),
              i = o ? a === t ? (n - e) / o : a === n ? 2 + (e - t) / o : 4 + (t - n) / o : 0;
            return {
              h: 60 * (i < 0 ? i + 6 : i),
              s: a ? o / a * 100 : 0,
              v: a / 255 * 100,
              a: u
            };
          },
          b$1 = function (r) {
            var t = r.h,
              n = r.s,
              e = r.v,
              u = r.a;
            t = t / 360 * 6, n /= 100, e /= 100;
            var a = Math.floor(t),
              o = e * (1 - n),
              i = e * (1 - (t - a) * n),
              s = e * (1 - (1 - t + a) * n),
              h = a % 6;
            return {
              r: 255 * [e, i, o, o, s, e][h],
              g: 255 * [s, e, e, i, o, o][h],
              b: 255 * [o, o, s, e, e, i][h],
              a: u
            };
          },
          g$2 = function (r) {
            return {
              h: u$1(r.h),
              s: e(r.s, 0, 100),
              l: e(r.l, 0, 100),
              a: e(r.a)
            };
          },
          d$1 = function (r) {
            return {
              h: n(r.h),
              s: n(r.s),
              l: n(r.l),
              a: n(r.a, 3)
            };
          },
          f$2 = function (r) {
            return b$1((n = (t = r).s, {
              h: t.h,
              s: (n *= ((e = t.l) < 50 ? e : 100 - e) / 100) > 0 ? 2 * n / (e + n) * 100 : 0,
              v: e + n,
              a: t.a
            }));
            var t, n, e;
          },
          c$1 = function (r) {
            return {
              h: (t = h$1(r)).h,
              s: (u = (200 - (n = t.s)) * (e = t.v) / 100) > 0 && u < 200 ? n * e / 100 / (u <= 100 ? u : 200 - u) * 100 : 0,
              l: u / 2,
              a: t.a
            };
            var t, n, e, u;
          },
          l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          p$1 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          v$2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          m$2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          y$2 = {
            string: [[function (r) {
              var t = i$1.exec(r);
              return t ? (r = t[1]).length <= 4 ? {
                r: parseInt(r[0] + r[0], 16),
                g: parseInt(r[1] + r[1], 16),
                b: parseInt(r[2] + r[2], 16),
                a: 4 === r.length ? n(parseInt(r[3] + r[3], 16) / 255, 2) : 1
              } : 6 === r.length || 8 === r.length ? {
                r: parseInt(r.substr(0, 2), 16),
                g: parseInt(r.substr(2, 2), 16),
                b: parseInt(r.substr(4, 2), 16),
                a: 8 === r.length ? n(parseInt(r.substr(6, 2), 16) / 255, 2) : 1
              } : null : null;
            }, "hex"], [function (r) {
              var t = v$2.exec(r) || m$2.exec(r);
              return t ? t[2] !== t[4] || t[4] !== t[6] ? null : a({
                r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
              }) : null;
            }, "rgb"], [function (t) {
              var n = l.exec(t) || p$1.exec(t);
              if (!n) return null;
              var e,
                u,
                a = g$2({
                  h: (e = n[1], u = n[2], void 0 === u && (u = "deg"), Number(e) * (r[u] || 1)),
                  s: Number(n[3]),
                  l: Number(n[4]),
                  a: void 0 === n[5] ? 1 : Number(n[5]) / (n[6] ? 100 : 1)
                });
              return f$2(a);
            }, "hsl"]],
            object: [[function (r) {
              var n = r.r,
                e = r.g,
                u = r.b,
                o = r.a,
                i = void 0 === o ? 1 : o;
              return t(n) && t(e) && t(u) ? a({
                r: Number(n),
                g: Number(e),
                b: Number(u),
                a: Number(i)
              }) : null;
            }, "rgb"], [function (r) {
              var n = r.h,
                e = r.s,
                u = r.l,
                a = r.a,
                o = void 0 === a ? 1 : a;
              if (!t(n) || !t(e) || !t(u)) return null;
              var i = g$2({
                h: Number(n),
                s: Number(e),
                l: Number(u),
                a: Number(o)
              });
              return f$2(i);
            }, "hsl"], [function (r) {
              var n = r.h,
                a = r.s,
                o = r.v,
                i = r.a,
                s = void 0 === i ? 1 : i;
              if (!t(n) || !t(a) || !t(o)) return null;
              var h = function (r) {
                return {
                  h: u$1(r.h),
                  s: e(r.s, 0, 100),
                  v: e(r.v, 0, 100),
                  a: e(r.a)
                };
              }({
                h: Number(n),
                s: Number(a),
                v: Number(o),
                a: Number(s)
              });
              return b$1(h);
            }, "hsv"]]
          },
          N = function (r, t) {
            for (var n = 0; n < t.length; n++) {
              var e = t[n][0](r);
              if (e) return [e, t[n][1]];
            }
            return [null, void 0];
          },
          x$1 = function (r) {
            return "string" == typeof r ? N(r.trim(), y$2.string) : "object" == typeof r && null !== r ? N(r, y$2.object) : [null, void 0];
          },
          M$1 = function (r, t) {
            var n = c$1(r);
            return {
              h: n.h,
              s: e(n.s + 100 * t, 0, 100),
              l: n.l,
              a: n.a
            };
          },
          H$1 = function (r) {
            return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;
          },
          $$2 = function (r, t) {
            var n = c$1(r);
            return {
              h: n.h,
              s: n.s,
              l: e(n.l + 100 * t, 0, 100),
              a: n.a
            };
          },
          j$1 = function () {
            function r(r) {
              this.parsed = x$1(r)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
              };
            }
            return r.prototype.isValid = function () {
              return null !== this.parsed;
            }, r.prototype.brightness = function () {
              return n(H$1(this.rgba), 2);
            }, r.prototype.isDark = function () {
              return H$1(this.rgba) < .5;
            }, r.prototype.isLight = function () {
              return H$1(this.rgba) >= .5;
            }, r.prototype.toHex = function () {
              return r = o(this.rgba), t = r.r, e = r.g, u = r.b, i = (a = r.a) < 1 ? s$1(n(255 * a)) : "", "#" + s$1(t) + s$1(e) + s$1(u) + i;
              var r, t, e, u, a, i;
            }, r.prototype.toRgb = function () {
              return o(this.rgba);
            }, r.prototype.toRgbString = function () {
              return r = o(this.rgba), t = r.r, n = r.g, e = r.b, (u = r.a) < 1 ? "rgba(" + t + ", " + n + ", " + e + ", " + u + ")" : "rgb(" + t + ", " + n + ", " + e + ")";
              var r, t, n, e, u;
            }, r.prototype.toHsl = function () {
              return d$1(c$1(this.rgba));
            }, r.prototype.toHslString = function () {
              return r = d$1(c$1(this.rgba)), t = r.h, n = r.s, e = r.l, (u = r.a) < 1 ? "hsla(" + t + ", " + n + "%, " + e + "%, " + u + ")" : "hsl(" + t + ", " + n + "%, " + e + "%)";
              var r, t, n, e, u;
            }, r.prototype.toHsv = function () {
              return r = h$1(this.rgba), {
                h: n(r.h),
                s: n(r.s),
                v: n(r.v),
                a: n(r.a, 3)
              };
              var r;
            }, r.prototype.invert = function () {
              return w$1({
                r: 255 - (r = this.rgba).r,
                g: 255 - r.g,
                b: 255 - r.b,
                a: r.a
              });
              var r;
            }, r.prototype.saturate = function (r) {
              return void 0 === r && (r = .1), w$1(M$1(this.rgba, r));
            }, r.prototype.desaturate = function (r) {
              return void 0 === r && (r = .1), w$1(M$1(this.rgba, -r));
            }, r.prototype.grayscale = function () {
              return w$1(M$1(this.rgba, -1));
            }, r.prototype.lighten = function (r) {
              return void 0 === r && (r = .1), w$1($$2(this.rgba, r));
            }, r.prototype.darken = function (r) {
              return void 0 === r && (r = .1), w$1($$2(this.rgba, -r));
            }, r.prototype.rotate = function (r) {
              return void 0 === r && (r = 15), this.hue(this.hue() + r);
            }, r.prototype.alpha = function (r) {
              return "number" == typeof r ? w$1({
                r: (t = this.rgba).r,
                g: t.g,
                b: t.b,
                a: r
              }) : n(this.rgba.a, 3);
              var t;
            }, r.prototype.hue = function (r) {
              var t = c$1(this.rgba);
              return "number" == typeof r ? w$1({
                h: r,
                s: t.s,
                l: t.l,
                a: t.a
              }) : n(t.h);
            }, r.prototype.isEqual = function (r) {
              return this.toHex() === w$1(r).toHex();
            }, r;
          }(),
          w$1 = function (r) {
            return r instanceof j$1 ? r : new j$1(r);
          },
          S$2 = [],
          k$2 = function (r) {
            r.forEach(function (r) {
              S$2.indexOf(r) < 0 && (r(j$1, y$2), S$2.push(r));
            });
          };
        function namesPlugin(e, f) {
          var a = {
              white: "#ffffff",
              bisque: "#ffe4c4",
              blue: "#0000ff",
              cadetblue: "#5f9ea0",
              chartreuse: "#7fff00",
              chocolate: "#d2691e",
              coral: "#ff7f50",
              antiquewhite: "#faebd7",
              aqua: "#00ffff",
              azure: "#f0ffff",
              whitesmoke: "#f5f5f5",
              papayawhip: "#ffefd5",
              plum: "#dda0dd",
              blanchedalmond: "#ffebcd",
              black: "#000000",
              gold: "#ffd700",
              goldenrod: "#daa520",
              gainsboro: "#dcdcdc",
              cornsilk: "#fff8dc",
              cornflowerblue: "#6495ed",
              burlywood: "#deb887",
              aquamarine: "#7fffd4",
              beige: "#f5f5dc",
              crimson: "#dc143c",
              cyan: "#00ffff",
              darkblue: "#00008b",
              darkcyan: "#008b8b",
              darkgoldenrod: "#b8860b",
              darkkhaki: "#bdb76b",
              darkgray: "#a9a9a9",
              darkgreen: "#006400",
              darkgrey: "#a9a9a9",
              peachpuff: "#ffdab9",
              darkmagenta: "#8b008b",
              darkred: "#8b0000",
              darkorchid: "#9932cc",
              darkorange: "#ff8c00",
              darkslateblue: "#483d8b",
              gray: "#808080",
              darkslategray: "#2f4f4f",
              darkslategrey: "#2f4f4f",
              deeppink: "#ff1493",
              deepskyblue: "#00bfff",
              wheat: "#f5deb3",
              firebrick: "#b22222",
              floralwhite: "#fffaf0",
              ghostwhite: "#f8f8ff",
              darkviolet: "#9400d3",
              magenta: "#ff00ff",
              green: "#008000",
              dodgerblue: "#1e90ff",
              grey: "#808080",
              honeydew: "#f0fff0",
              hotpink: "#ff69b4",
              blueviolet: "#8a2be2",
              forestgreen: "#228b22",
              lawngreen: "#7cfc00",
              indianred: "#cd5c5c",
              indigo: "#4b0082",
              fuchsia: "#ff00ff",
              brown: "#a52a2a",
              maroon: "#800000",
              mediumblue: "#0000cd",
              lightcoral: "#f08080",
              darkturquoise: "#00ced1",
              lightcyan: "#e0ffff",
              ivory: "#fffff0",
              lightyellow: "#ffffe0",
              lightsalmon: "#ffa07a",
              lightseagreen: "#20b2aa",
              linen: "#faf0e6",
              mediumaquamarine: "#66cdaa",
              lemonchiffon: "#fffacd",
              lime: "#00ff00",
              khaki: "#f0e68c",
              mediumseagreen: "#3cb371",
              limegreen: "#32cd32",
              mediumspringgreen: "#00fa9a",
              lightskyblue: "#87cefa",
              lightblue: "#add8e6",
              midnightblue: "#191970",
              lightpink: "#ffb6c1",
              mistyrose: "#ffe4e1",
              moccasin: "#ffe4b5",
              mintcream: "#f5fffa",
              lightslategray: "#778899",
              lightslategrey: "#778899",
              navajowhite: "#ffdead",
              navy: "#000080",
              mediumvioletred: "#c71585",
              powderblue: "#b0e0e6",
              palegoldenrod: "#eee8aa",
              oldlace: "#fdf5e6",
              paleturquoise: "#afeeee",
              mediumturquoise: "#48d1cc",
              mediumorchid: "#ba55d3",
              rebeccapurple: "#663399",
              lightsteelblue: "#b0c4de",
              mediumslateblue: "#7b68ee",
              thistle: "#d8bfd8",
              tan: "#d2b48c",
              orchid: "#da70d6",
              mediumpurple: "#9370db",
              purple: "#800080",
              pink: "#ffc0cb",
              skyblue: "#87ceeb",
              springgreen: "#00ff7f",
              palegreen: "#98fb98",
              red: "#ff0000",
              yellow: "#ffff00",
              slateblue: "#6a5acd",
              lavenderblush: "#fff0f5",
              peru: "#cd853f",
              palevioletred: "#db7093",
              violet: "#ee82ee",
              teal: "#008080",
              slategray: "#708090",
              slategrey: "#708090",
              aliceblue: "#f0f8ff",
              darkseagreen: "#8fbc8f",
              darkolivegreen: "#556b2f",
              greenyellow: "#adff2f",
              seagreen: "#2e8b57",
              seashell: "#fff5ee",
              tomato: "#ff6347",
              silver: "#c0c0c0",
              sienna: "#a0522d",
              lavender: "#e6e6fa",
              lightgreen: "#90ee90",
              orange: "#ffa500",
              orangered: "#ff4500",
              steelblue: "#4682b4",
              royalblue: "#4169e1",
              turquoise: "#40e0d0",
              yellowgreen: "#9acd32",
              salmon: "#fa8072",
              saddlebrown: "#8b4513",
              sandybrown: "#f4a460",
              rosybrown: "#bc8f8f",
              darksalmon: "#e9967a",
              lightgoldenrodyellow: "#fafad2",
              snow: "#fffafa",
              lightgrey: "#d3d3d3",
              lightgray: "#d3d3d3",
              dimgray: "#696969",
              dimgrey: "#696969",
              olivedrab: "#6b8e23",
              olive: "#808000"
            },
            r = {};
          for (var d in a) r[a[d]] = d;
          var l = {};
          e.prototype.toName = function (f) {
            if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
            var d,
              i,
              n = r[this.toHex()];
            if (n) return n;
            if (null == f ? void 0 : f.closest) {
              var o = this.toRgb(),
                t = 1 / 0,
                b = "black";
              if (!l.length) for (var c in a) l[c] = new e(a[c]).toRgb();
              for (var g in a) {
                var u = (d = o, i = l[g], Math.pow(d.r - i.r, 2) + Math.pow(d.g - i.g, 2) + Math.pow(d.b - i.b, 2));
                u < t && (t = u, b = g);
              }
              return b;
            }
          };
          f.string.push([function (f) {
            var r = f.toLowerCase(),
              d = "transparent" === r ? "#0000" : a[r];
            return d ? new e(d).toRgb() : null;
          }, "name"]);
        }

        /**
         * External dependencies
         */

        /** @type {HTMLDivElement} */
        let colorComputationNode;
        k$2([namesPlugin]);

        /**
         * @return {HTMLDivElement | undefined} The HTML element for color computation.
         */
        function getColorComputationNode() {
          if (typeof document === 'undefined') {
            return;
          }
          if (!colorComputationNode) {
            // Create a temporary element for style computation.
            const el = document.createElement('div');
            el.setAttribute('data-g2-color-computation-node', '');
            // Inject for window computed style.
            document.body.appendChild(el);
            colorComputationNode = el;
          }
          return colorComputationNode;
        }

        /**
         * @param {string | unknown} value
         *
         * @return {boolean} Whether the value is a valid color.
         */
        function isColor(value) {
          if (typeof value !== 'string') {
            return false;
          }
          const test = w$1(value);
          return test.isValid();
        }

        /**
         * Retrieves the computed background color. This is useful for getting the
         * value of a CSS variable color.
         *
         * @param {string | unknown} backgroundColor The background color to compute.
         *
         * @return {string} The computed background color.
         */
        function _getComputedBackgroundColor(backgroundColor) {
          if (typeof backgroundColor !== 'string') {
            return '';
          }
          if (isColor(backgroundColor)) {
            return backgroundColor;
          }
          if (!backgroundColor.includes('var(')) {
            return '';
          }
          if (typeof document === 'undefined') {
            return '';
          }

          // Attempts to gracefully handle CSS variables color values.
          const el = getColorComputationNode();
          if (!el) {
            return '';
          }
          el.style.background = backgroundColor;
          // Grab the style.
          const computedColor = window?.getComputedStyle(el).background;
          // Reset.
          el.style.background = '';
          return computedColor || '';
        }
        const getComputedBackgroundColor = memize(_getComputedBackgroundColor);

        /**
         * Get the text shade optimized for readability, based on a background color.
         *
         * @param {string | unknown} backgroundColor The background color.
         *
         * @return {string} The optimized text color (black or white).
         */
        function getOptimalTextColor(backgroundColor) {
          const background = getComputedBackgroundColor(backgroundColor);
          return w$1(background).isLight() ? '#000000' : '#ffffff';
        }

        /**
         * Get the text shade optimized for readability, based on a background color.
         *
         * @param {string | unknown} backgroundColor The background color.
         *
         * @return {string} The optimized text shade (dark or light).
         */
        function getOptimalTextShade(backgroundColor) {
          const result = getOptimalTextColor(backgroundColor);
          return result === '#000000' ? 'dark' : 'light';
        }
        const LOWER_LEFT_REGEXP = new RegExp(/-left/g);
        const LOWER_RIGHT_REGEXP = new RegExp(/-right/g);
        const UPPER_LEFT_REGEXP = new RegExp(/Left/g);
        const UPPER_RIGHT_REGEXP = new RegExp(/Right/g);
        function getConvertedKey(key) {
          if (key === "left") {
            return "right";
          }
          if (key === "right") {
            return "left";
          }
          if (LOWER_LEFT_REGEXP.test(key)) {
            return key.replace(LOWER_LEFT_REGEXP, "-right");
          }
          if (LOWER_RIGHT_REGEXP.test(key)) {
            return key.replace(LOWER_RIGHT_REGEXP, "-left");
          }
          if (UPPER_LEFT_REGEXP.test(key)) {
            return key.replace(UPPER_LEFT_REGEXP, "Right");
          }
          if (UPPER_RIGHT_REGEXP.test(key)) {
            return key.replace(UPPER_RIGHT_REGEXP, "Left");
          }
          return key;
        }
        const convertLTRToRTL = (ltrStyles = {}) => {
          return Object.fromEntries(Object.entries(ltrStyles).map(([key, value]) => [getConvertedKey(key), value]));
        };
        function rtl(ltrStyles = {}, rtlStyles) {
          return () => {
            if (rtlStyles) {
              return isRTL$1() ? /* @__PURE__ */css(rtlStyles, "", "") : /* @__PURE__ */css(ltrStyles, "", "");
            }
            return isRTL$1() ? /* @__PURE__ */css(convertLTRToRTL(ltrStyles), "", "") : /* @__PURE__ */css(ltrStyles, "", "");
          };
        }
        rtl.watch = () => isRTL$1();
        const FONT = {
          'default.fontFamily': "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif",
          'default.fontSize': '13px',
          'helpText.fontSize': '12px',
          mobileTextMinFontSize: '16px'
        };

        /**
         * Internal dependencies
         */

        /**
         *
         * @param {keyof FONT} value Path of value from `FONT`
         * @return {string} Font rule value
         */
        function font(value) {
          var _FONT$value;
          return (_FONT$value = FONT[value]) !== null && _FONT$value !== void 0 ? _FONT$value : '';
        }
        const breakpoints$1 = {
          huge: '1440px',
          wide: '1280px',
          'x-large': '1080px',
          large: '960px',
          // admin sidebar auto folds
          medium: '782px',
          // Adminbar goes big.
          small: '600px',
          mobile: '480px',
          'zoomed-in': '280px'
        };

        /**
         * Internal dependencies
         */

        /**
         * @param {keyof breakpoints} point
         * @return {string} Media query declaration.
         */
        const breakpoint = point => `@media (min-width: ${breakpoints$1[point]})`;

        /**
         * The argument value for the `space()` utility function.
         *
         * When this is a number or a numeric string, it will be interpreted as a
         * multiplier for the grid base value (4px). For example, `space( 2 )` will be 8px.
         *
         * Otherwise, it will be interpreted as a literal CSS length value. For example,
         * `space( 'auto' )` will be 'auto', and `space( '2px' )` will be 2px.
         */

        const GRID_BASE = '4px';

        /**
         * A function that handles numbers, numeric strings, and unit values.
         *
         * When given a number or a numeric string, it will return the grid-based
         * value as a factor of GRID_BASE, defined above.
         *
         * When given a unit value or one of the named CSS values like `auto`,
         * it will simply return the value back.
         *
         * @param value A number, numeric string, or a unit value.
         */
        function space(value) {
          if (typeof value === 'undefined') {
            return undefined;
          }

          // Handle empty strings, if it's the number 0 this still works.
          if (!value) {
            return '0';
          }
          const asInt = typeof value === 'number' ? value : Number(value);

          // Test if the input has a unit, was NaN, or was one of the named CSS values (like `auto`), in which case just use that value.
          if (typeof window !== 'undefined' && window.CSS?.supports?.('margin', value.toString()) || Number.isNaN(asInt)) {
            return value.toString();
          }
          return `calc(${GRID_BASE} * ${value})`;
        }

        /**
         * Internal dependencies
         */
        const white = '#fff';

        // Matches the grays in @wordpress/base-styles
        const GRAY = {
          900: '#1e1e1e',
          800: '#2f2f2f',
          /** Meets 4.6:1 text contrast against white. */
          700: '#757575',
          /** Meets 3:1 UI or large text contrast against white. */
          600: '#949494',
          400: '#ccc',
          /** Used for most borders. */
          300: '#ddd',
          /** Used sparingly for light borders. */
          200: '#e0e0e0',
          /** Used for light gray backgrounds. */
          100: '#f0f0f0'
        };

        // Matches @wordpress/base-styles
        const ALERT = {
          yellow: '#f0b849',
          red: '#d94f4f',
          green: '#4ab866'
        };

        // Should match packages/components/src/utils/theme-variables.scss
        const THEME = {
          accent: `var(--wp-components-color-accent, var(--wp-admin-theme-color, #3858e9))`,
          accentDarker10: `var(--wp-components-color-accent-darker-10, var(--wp-admin-theme-color-darker-10, #2145e6))`,
          accentDarker20: `var(--wp-components-color-accent-darker-20, var(--wp-admin-theme-color-darker-20, #183ad6))`,
          /** Used when placing text on the accent color. */
          accentInverted: `var(--wp-components-color-accent-inverted, ${white})`,
          background: `var(--wp-components-color-background, ${white})`,
          foreground: `var(--wp-components-color-foreground, ${GRAY[900]})`,
          /** Used when placing text on the foreground color. */
          foregroundInverted: `var(--wp-components-color-foreground-inverted, ${white})`,
          gray: {
            /** @deprecated Use `COLORS.theme.foreground` instead. */
            900: `var(--wp-components-color-foreground, ${GRAY[900]})`,
            800: `var(--wp-components-color-gray-800, ${GRAY[800]})`,
            700: `var(--wp-components-color-gray-700, ${GRAY[700]})`,
            600: `var(--wp-components-color-gray-600, ${GRAY[600]})`,
            400: `var(--wp-components-color-gray-400, ${GRAY[400]})`,
            300: `var(--wp-components-color-gray-300, ${GRAY[300]})`,
            200: `var(--wp-components-color-gray-200, ${GRAY[200]})`,
            100: `var(--wp-components-color-gray-100, ${GRAY[100]})`
          }
        };
        const UI = {
          background: THEME.background,
          backgroundDisabled: THEME.gray[100],
          border: THEME.gray[600],
          borderHover: THEME.gray[700],
          borderFocus: THEME.accent,
          borderDisabled: THEME.gray[400],
          textDisabled: THEME.gray[600],
          // Matches @wordpress/base-styles
          darkGrayPlaceholder: `color-mix(in srgb, ${THEME.foreground}, transparent 38%)`,
          lightGrayPlaceholder: `color-mix(in srgb, ${THEME.background}, transparent 35%)`
        };
        const COLORS$1 = Object.freeze({
          /**
           * The main gray color object.
           *
           * @deprecated Use semantic aliases in `COLORS.ui` or theme-ready variables in `COLORS.theme.gray`.
           */
          gray: GRAY,
          // TODO: Stop exporting this when everything is migrated to `theme` or `ui`
          white,
          alert: ALERT,
          /**
           * Theme-ready variables with fallbacks.
           *
           * Prefer semantic aliases in `COLORS.ui` when applicable.
           */
          theme: THEME,
          /**
           * Semantic aliases (prefer these over raw variables when applicable).
           */
          ui: UI
        });

        /**
         * Internal dependencies
         */
        const CONTROL_HEIGHT = '36px';
        const CONTROL_PROPS = {
          // These values should be shared with TextControl.
          controlPaddingX: 12,
          controlPaddingXSmall: 8,
          controlPaddingXLarge: 12 * 1.3334,
          // TODO: Deprecate

          controlBackgroundColor: COLORS$1.white,
          controlBoxShadowFocus: `0 0 0 0.5px ${COLORS$1.theme.accent}`,
          controlHeight: CONTROL_HEIGHT,
          controlHeightXSmall: `calc( ${CONTROL_HEIGHT} * 0.6 )`,
          controlHeightSmall: `calc( ${CONTROL_HEIGHT} * 0.8 )`,
          controlHeightLarge: `calc( ${CONTROL_HEIGHT} * 1.2 )`,
          controlHeightXLarge: `calc( ${CONTROL_HEIGHT} * 1.4 )`
        };

        // Using Object.assign to avoid creating circular references when emitting
        // TypeScript type declarations.
        const CONFIG = Object.assign({}, CONTROL_PROPS, {
          colorDivider: 'rgba(0, 0, 0, 0.1)',
          colorScrollbarThumb: 'rgba(0, 0, 0, 0.2)',
          colorScrollbarThumbHover: 'rgba(0, 0, 0, 0.5)',
          colorScrollbarTrack: 'rgba(0, 0, 0, 0.04)',
          elevationIntensity: 1,
          radiusXSmall: '1px',
          radiusSmall: '2px',
          radiusMedium: '4px',
          radiusLarge: '8px',
          radiusFull: '9999px',
          radiusRound: '50%',
          borderWidth: '1px',
          borderWidthFocus: '1.5px',
          borderWidthTab: '4px',
          spinnerSize: 16,
          fontSize: '13px',
          fontSizeH1: 'calc(2.44 * 13px)',
          fontSizeH2: 'calc(1.95 * 13px)',
          fontSizeH3: 'calc(1.56 * 13px)',
          fontSizeH4: 'calc(1.25 * 13px)',
          fontSizeH5: '13px',
          fontSizeH6: 'calc(0.8 * 13px)',
          fontSizeInputMobile: '16px',
          fontSizeMobile: '15px',
          fontSizeSmall: 'calc(0.92 * 13px)',
          fontSizeXSmall: 'calc(0.75 * 13px)',
          fontLineHeightBase: '1.4',
          fontWeight: 'normal',
          fontWeightHeading: '600',
          gridBase: '4px',
          cardPaddingXSmall: `${space(2)}`,
          cardPaddingSmall: `${space(4)}`,
          cardPaddingMedium: `${space(4)} ${space(6)}`,
          cardPaddingLarge: `${space(6)} ${space(8)}`,
          elevationXSmall: `0 1px 1px rgba(0, 0, 0, 0.03), 0 1px 2px rgba(0, 0, 0, 0.02), 0 3px 3px rgba(0, 0, 0, 0.02), 0 4px 4px rgba(0, 0, 0, 0.01)`,
          elevationSmall: `0 1px 2px rgba(0, 0, 0, 0.05), 0 2px 3px rgba(0, 0, 0, 0.04), 0 6px 6px rgba(0, 0, 0, 0.03), 0 8px 8px rgba(0, 0, 0, 0.02)`,
          elevationMedium: `0 2px 3px rgba(0, 0, 0, 0.05), 0 4px 5px rgba(0, 0, 0, 0.04), 0 12px 12px rgba(0, 0, 0, 0.03), 0 16px 16px rgba(0, 0, 0, 0.02)`,
          elevationLarge: `0 5px 15px rgba(0, 0, 0, 0.08), 0 15px 27px rgba(0, 0, 0, 0.07), 0 30px 36px rgba(0, 0, 0, 0.04), 0 50px 43px rgba(0, 0, 0, 0.02)`,
          surfaceBackgroundColor: COLORS$1.white,
          surfaceBackgroundSubtleColor: '#F3F3F3',
          surfaceBackgroundTintColor: '#F5F5F5',
          surfaceBorderColor: 'rgba(0, 0, 0, 0.1)',
          surfaceBorderBoldColor: 'rgba(0, 0, 0, 0.15)',
          surfaceBorderSubtleColor: 'rgba(0, 0, 0, 0.05)',
          surfaceBackgroundTertiaryColor: COLORS$1.white,
          surfaceColor: COLORS$1.white,
          transitionDuration: '200ms',
          transitionDurationFast: '160ms',
          transitionDurationFaster: '120ms',
          transitionDurationFastest: '100ms',
          transitionTimingFunction: 'cubic-bezier(0.08, 0.52, 0.52, 1)',
          transitionTimingFunctionControl: 'cubic-bezier(0.12, 0.8, 0.32, 1)'
        });
        const baseLabelTypography = {
          name: "9amh4a",
          styles: "font-size:11px;font-weight:500;line-height:1.4;text-transform:uppercase"
        };

        /**
         * External dependencies
         */
        const ComponentsContext = reactExports.createContext(/** @type {Record<string, any>} */{});
        const useComponentsContext = () => reactExports.useContext(ComponentsContext);

        /**
         * Consolidates incoming ContextSystem values with a (potential) parent ContextSystem value.
         *
         * Note: This function will warn if it detects an un-memoized `value`
         *
         * @param {Object}              props
         * @param {Record<string, any>} props.value
         * @return {Record<string, any>} The consolidated value.
         */
        function useContextSystemBridge({
          value
        }) {
          const parentContext = useComponentsContext();
          const valueRef = reactExports.useRef(value);
          useUpdateEffect(() => {
            if (
            // Objects are equivalent.
            fastDeepEqual(valueRef.current, value) &&
            // But not the same reference.
            valueRef.current !== value) {
              globalThis.SCRIPT_DEBUG === true ? warning(`Please memoize your context: ${JSON.stringify(value)}`) : void 0;
            }
          }, [value]);

          // `parentContext` will always be memoized (i.e., the result of this hook itself)
          // or the default value from when the `ComponentsContext` was originally
          // initialized (which will never change, it's a static variable)
          // so this memoization will prevent `deepmerge()` from rerunning unless
          // the references to `value` change OR the `parentContext` has an actual material change
          // (because again, it's guaranteed to be memoized or a static reference to the empty object
          // so we know that the only changes for `parentContext` are material ones... i.e., why we
          // don't have to warn in the `useUpdateEffect` hook above for `parentContext` and we only
          // need to bother with the `value`). The `useUpdateEffect` above will ensure that we are
          // correctly warning when the `value` isn't being properly memoized. All of that to say
          // that this should be super safe to assume that `useMemo` will only run on actual
          // changes to the two dependencies, therefore saving us calls to `deepmerge()`!
          const config = reactExports.useMemo(() => {
            // Deep clone `parentContext` to avoid mutating it later.
            return deepmerge$1(parentContext !== null && parentContext !== void 0 ? parentContext : {}, value !== null && value !== void 0 ? value : {}, {
              isMergeableObject: isPlainObject
            });
          }, [parentContext, value]);
          return config;
        }

        /**
         * A Provider component that can modify props for connected components within
         * the Context system.
         *
         * @example
         * ```jsx
         * <ContextSystemProvider value={{ Button: { size: 'small' }}}>
         *   <Button>...</Button>
         * </ContextSystemProvider>
         * ```
         *
         * @template {Record<string, any>} T
         * @param {Object}                    options
         * @param {import('react').ReactNode} options.children Children to render.
         * @param {T}                         options.value    Props to render into connected components.
         * @return {JSX.Element} A Provider wrapped component.
         */
        const BaseContextSystemProvider = ({
          children,
          value
        }) => {
          const contextValue = useContextSystemBridge({
            value
          });
          return /*#__PURE__*/jsxRuntimeExports.jsx(ComponentsContext.Provider, {
            value: contextValue,
            children: children
          });
        };
        const ContextSystemProvider = reactExports.memo(BaseContextSystemProvider);
        const COMPONENT_NAMESPACE = 'data-wp-component';
        const CONNECTED_NAMESPACE = 'data-wp-c16t';

        /**
         * Special key where the connected namespaces are stored.
         * This is attached to Context connected components as a static property.
         */
        const CONNECT_STATIC_NAMESPACE = '__contextSystemKey__';

        /**
         * External dependencies
         */

        /**
         * Generates the connected component CSS className based on the namespace.
         *
         * @param namespace The name of the connected component.
         * @return The generated CSS className.
         */
        function getStyledClassName(namespace) {
          const kebab = paramCase(namespace);
          return `components-${kebab}`;
        }
        const getStyledClassNameFromKey = memize(getStyledClassName);

        /* wp:polyfill */
        /**
         * External dependencies
         */

        /**
         * Forwards ref (React.ForwardRef) and "Connects" (or registers) a component
         * within the Context system under a specified namespace.
         *
         * @param Component The component to register into the Context system.
         * @param namespace The namespace to register the component under.
         * @return The connected WordPressComponent
         */
        function contextConnect(Component, namespace) {
          return _contextConnect(Component, namespace, {
            forwardsRef: true
          });
        }

        /**
         * "Connects" (or registers) a component within the Context system under a specified namespace.
         * Does not forward a ref.
         *
         * @param Component The component to register into the Context system.
         * @param namespace The namespace to register the component under.
         * @return The connected WordPressComponent
         */
        function contextConnectWithoutRef(Component, namespace) {
          return _contextConnect(Component, namespace);
        }

        // This is an (experimental) evolution of the initial connect() HOC.
        // The hope is that we can improve render performance by removing functional
        // component wrappers.
        function _contextConnect(Component, namespace, options) {
          const WrappedComponent = options?.forwardsRef ? reactExports.forwardRef(Component) : Component;
          if (typeof namespace === 'undefined') {
            globalThis.SCRIPT_DEBUG === true ? warning('contextConnect: Please provide a namespace') : void 0;
          }

          // @ts-expect-error internal property
          let mergedNamespace = WrappedComponent[CONNECT_STATIC_NAMESPACE] || [namespace];

          /**
           * Consolidate (merge) namespaces before attaching it to the WrappedComponent.
           */
          if (Array.isArray(namespace)) {
            mergedNamespace = [...mergedNamespace, ...namespace];
          }
          if (typeof namespace === 'string') {
            mergedNamespace = [...mergedNamespace, namespace];
          }

          // @ts-expect-error We can't rely on inferred types here because of the
          // `as` prop polymorphism we're handling in https://github.com/WordPress/gutenberg/blob/4f3a11243c365f94892e479bff0b922ccc4ccda3/packages/components/src/context/wordpress-component.ts#L32-L33
          return Object.assign(WrappedComponent, {
            [CONNECT_STATIC_NAMESPACE]: [...new Set(mergedNamespace)],
            displayName: namespace,
            selector: `.${getStyledClassNameFromKey(namespace)}`
          });
        }

        /**
         * Attempts to retrieve the connected namespace from a component.
         *
         * @param Component The component to retrieve a namespace from.
         * @return The connected namespaces.
         */
        function getConnectNamespace(Component) {
          if (!Component) {
            return [];
          }
          let namespaces = [];

          // @ts-ignore internal property
          if (Component[CONNECT_STATIC_NAMESPACE]) {
            // @ts-ignore internal property
            namespaces = Component[CONNECT_STATIC_NAMESPACE];
          }

          // @ts-ignore
          if (Component.type && Component.type[CONNECT_STATIC_NAMESPACE]) {
            // @ts-ignore
            namespaces = Component.type[CONNECT_STATIC_NAMESPACE];
          }
          return namespaces;
        }

        /**
         * Checks to see if a component is connected within the Context system.
         *
         * @param Component The component to retrieve a namespace from.
         * @param match     The namespace to check.
         */
        function hasConnectNamespace(Component, match) {
          if (!Component) {
            return false;
          }
          if (typeof match === 'string') {
            return getConnectNamespace(Component).includes(match);
          }
          if (Array.isArray(match)) {
            return match.some(result => getConnectNamespace(Component).includes(result));
          }
          return false;
        }

        /**
         * Internal dependencies
         */

        /**
         * Creates a dedicated context namespace HTML attribute for components.
         * ns is short for "namespace"
         *
         * @example
         * ```jsx
         * <div {...ns('Container')} />
         * ```
         *
         * @param {string} componentName The name for the component.
         * @return {Record<string, any>} A props object with the namespaced HTML attribute.
         */
        function getNamespace(componentName) {
          return {
            [COMPONENT_NAMESPACE]: componentName
          };
        }

        /**
         * Creates a dedicated connected context namespace HTML attribute for components.
         * ns is short for "namespace"
         *
         * @example
         * ```jsx
         * <div {...cns()} />
         * ```
         *
         * @return {Record<string, any>} A props object with the namespaced HTML attribute.
         */
        function getConnectedNamespace() {
          return {
            [CONNECTED_NAMESPACE]: true
          };
        }

        /**
         * WordPress dependencies
         */

        /**
         * @template TProps
         * @typedef {TProps & { className: string }} ConnectedProps
         */

        /**
         * Custom hook that derives registered props from the Context system.
         * These derived props are then consolidated with incoming component props.
         *
         * @template {{ className?: string }} P
         * @param {P}      props     Incoming props from the component.
         * @param {string} namespace The namespace to register and to derive context props from.
         * @return {ConnectedProps<P>} The connected props.
         */
        function useContextSystem(props, namespace) {
          const contextSystemProps = useComponentsContext();
          if (typeof namespace === 'undefined') {
            globalThis.SCRIPT_DEBUG === true ? warning('useContextSystem: Please provide a namespace') : void 0;
          }
          const contextProps = contextSystemProps?.[namespace] || {};

          /* eslint-disable jsdoc/no-undefined-types */
          /** @type {ConnectedProps<P>} */
          // @ts-ignore We fill in the missing properties below
          const finalComponentProps = {
            ...getConnectedNamespace(),
            ...getNamespace(namespace)
          };
          /* eslint-enable jsdoc/no-undefined-types */

          const {
            _overrides: overrideProps,
            ...otherContextProps
          } = contextProps;
          const initialMergedProps = Object.entries(otherContextProps).length ? Object.assign({}, otherContextProps, props) : props;
          const cx = useCx();
          const classes = cx(getStyledClassNameFromKey(namespace), props.className);

          // Provides the ability to customize the render of the component.
          const rendered = typeof initialMergedProps.renderChildren === 'function' ? initialMergedProps.renderChildren(initialMergedProps) : initialMergedProps.children;
          for (const key in initialMergedProps) {
            // @ts-ignore filling in missing props
            finalComponentProps[key] = initialMergedProps[key];
          }
          for (const key in overrideProps) {
            // @ts-ignore filling in missing props
            finalComponentProps[key] = overrideProps[key];
          }

          // Setting an `undefined` explicitly can cause unintended overwrites
          // when a `cloneElement()` is involved.
          if (rendered !== undefined) {
            // @ts-ignore
            finalComponentProps.children = rendered;
          }
          finalComponentProps.className = classes;
          return finalComponentProps;
        }

        /**
         * External dependencies
         */

        const visuallyHidden = {
          border: 0,
          clip: 'rect(1px, 1px, 1px, 1px)',
          WebkitClipPath: 'inset( 50% )',
          clipPath: 'inset( 50% )',
          height: '1px',
          margin: '-1px',
          overflow: 'hidden',
          padding: 0,
          position: 'absolute',
          width: '1px',
          wordWrap: 'normal'
        };

        // eslint-disable-next-line no-undef
        var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

        var isPropValid = /* #__PURE__ */memoize(function (prop) {
          return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
          /* o */ && prop.charCodeAt(1) === 110
          /* n */ && prop.charCodeAt(2) < 91;
        }
        /* Z+1 */);
        var testOmitPropsOnStringTag = isPropValid;
        var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
          return key !== 'theme';
        };
        var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
          return typeof tag === 'string' &&
          // 96 is one less than the char code
          // for "a" so this is checking that
          // it's a lowercase character
          tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
        };
        var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
          var shouldForwardProp;
          if (options) {
            var optionsShouldForwardProp = options.shouldForwardProp;
            shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
              return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
            } : optionsShouldForwardProp;
          }
          if (typeof shouldForwardProp !== 'function' && isReal) {
            shouldForwardProp = tag.__emotion_forwardProp;
          }
          return shouldForwardProp;
        };
        var Insertion = function Insertion(_ref) {
          var cache = _ref.cache,
            serialized = _ref.serialized,
            isStringTag = _ref.isStringTag;
          registerStyles(cache, serialized, isStringTag);
          useInsertionEffectAlwaysWithSyncFallback(function () {
            return insertStyles(cache, serialized, isStringTag);
          });
          return null;
        };
        var createStyled = function createStyled(tag, options) {
          var isReal = tag.__emotion_real === tag;
          var baseTag = isReal && tag.__emotion_base || tag;
          var identifierName;
          var targetClassName;
          if (options !== undefined) {
            identifierName = options.label;
            targetClassName = options.target;
          }
          var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
          var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
          var shouldUseAs = !defaultShouldForwardProp('as');
          return function () {
            // eslint-disable-next-line prefer-rest-params
            var args = arguments;
            var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];
            if (identifierName !== undefined) {
              styles.push("label:" + identifierName + ";");
            }
            if (args[0] == null || args[0].raw === undefined) {
              // eslint-disable-next-line prefer-spread
              styles.push.apply(styles, args);
            } else {
              var templateStringsArr = args[0];
              styles.push(templateStringsArr[0]);
              var len = args.length;
              var i = 1;
              for (; i < len; i++) {
                styles.push(args[i], templateStringsArr[i]);
              }
            }
            var Styled = withEmotionCache(function (props, cache, ref) {
              var FinalTag = shouldUseAs && props.as || baseTag;
              var className = '';
              var classInterpolations = [];
              var mergedProps = props;
              if (props.theme == null) {
                mergedProps = {};
                for (var key in props) {
                  mergedProps[key] = props[key];
                }
                mergedProps.theme = reactExports.useContext(ThemeContext);
              }
              if (typeof props.className === 'string') {
                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
              } else if (props.className != null) {
                className = props.className + " ";
              }
              var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
              className += cache.key + "-" + serialized.name;
              if (targetClassName !== undefined) {
                className += " " + targetClassName;
              }
              var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
              var newProps = {};
              for (var _key in props) {
                if (shouldUseAs && _key === 'as') continue;
                if (finalShouldForwardProp(_key)) {
                  newProps[_key] = props[_key];
                }
              }
              newProps.className = className;
              if (ref) {
                newProps.ref = ref;
              }
              return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion, {
                cache: cache,
                serialized: serialized,
                isStringTag: typeof FinalTag === 'string'
              }), /*#__PURE__*/reactExports.createElement(FinalTag, newProps));
            });
            Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
            Styled.defaultProps = tag.defaultProps;
            Styled.__emotion_real = Styled;
            Styled.__emotion_base = baseTag;
            Styled.__emotion_styles = styles;
            Styled.__emotion_forwardProp = shouldForwardProp;
            Object.defineProperty(Styled, 'toString', {
              value: function value() {
                return "." + targetClassName;
              }
            });
            Styled.withComponent = function (nextTag, nextOptions) {
              var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
              }));
              return newStyled.apply(void 0, styles);
            };
            return Styled;
          };
        };
        const PolymorphicDiv = /* @__PURE__ */createStyled("div", {
          target: "e19lxcc00"
        })("");
        function UnforwardedView({
          as,
          ...restProps
        }, ref) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(PolymorphicDiv, {
            as,
            ref,
            ...restProps
          });
        }
        const View = Object.assign(reactExports.forwardRef(UnforwardedView), {
          selector: ".components-view"
        });

        /**
         * External dependencies
         */

        function UnconnectedVisuallyHidden(props, forwardedRef) {
          const {
            style: styleProp,
            ...contextProps
          } = useContextSystem(props, 'VisuallyHidden');
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ref: forwardedRef,
            ...contextProps,
            style: {
              ...visuallyHidden,
              ...(styleProp || {})
            }
          });
        }

        /**
         * `VisuallyHidden` is a component used to render text intended to be visually
         * hidden, but will show for alternate devices, for example a screen reader.
         *
         * ```jsx
         * import { VisuallyHidden } from `@wordpress/components`;
         *
         * function Example() {
         *   return (
         *     <VisuallyHidden>
         *       <label>Code is Poetry</label>
         *     </VisuallyHidden>
         *   );
         * }
         * ```
         */
        const VisuallyHidden = contextConnect(UnconnectedVisuallyHidden, 'VisuallyHidden');

        /**
         * WordPress dependencies
         */
        const breakpoints = ['40em', '52em', '64em'];
        const useBreakpointIndex = (options = {}) => {
          const {
            defaultIndex = 0
          } = options;
          if (typeof defaultIndex !== 'number') {
            throw new TypeError(`Default breakpoint index should be a number. Got: ${defaultIndex}, ${typeof defaultIndex}`);
          } else if (defaultIndex < 0 || defaultIndex > breakpoints.length - 1) {
            throw new RangeError(`Default breakpoint index out of range. Theme has ${breakpoints.length} breakpoints, got index ${defaultIndex}`);
          }
          const [value, setValue] = reactExports.useState(defaultIndex);
          reactExports.useEffect(() => {
            const getIndex = () => breakpoints.filter(bp => {
              return typeof window !== 'undefined' ? window.matchMedia(`screen and (min-width: ${bp})`).matches : false;
            }).length;
            const onResize = () => {
              const newValue = getIndex();
              if (value !== newValue) {
                setValue(newValue);
              }
            };
            onResize();
            if (typeof window !== 'undefined') {
              window.addEventListener('resize', onResize);
            }
            return () => {
              if (typeof window !== 'undefined') {
                window.removeEventListener('resize', onResize);
              }
            };
          }, [value]);
          return value;
        };
        function useResponsiveValue(values, options = {}) {
          const index = useBreakpointIndex(options);

          // Allow calling the function with a "normal" value without having to check on the outside.
          if (!Array.isArray(values) && typeof values !== 'function') {
            return values;
          }
          const array = values || [];

          /* eslint-disable jsdoc/no-undefined-types */
          return /** @type {T[]} */array[/* eslint-enable jsdoc/no-undefined-types */
          index >= array.length ? array.length - 1 : index];
        }
        const Flex$1 = {
          name: "zjik7",
          styles: "display:flex"
        };
        const Item = {
          name: "qgaee5",
          styles: "display:block;max-height:100%;max-width:100%;min-height:0;min-width:0"
        };
        const block$1 = {
          name: "82a6rk",
          styles: "flex:1"
        };
        const ItemsColumn = {
          name: "13nosa1",
          styles: ">*{min-height:0;}"
        };
        const ItemsRow = {
          name: "1pwxzk4",
          styles: ">*{min-width:0;}"
        };
        function useDeprecatedProps$3(props) {
          const {
            isReversed,
            ...otherProps
          } = props;
          if (typeof isReversed !== "undefined") {
            deprecated("Flex isReversed", {
              alternative: 'Flex direction="row-reverse" or "column-reverse"',
              since: "5.9"
            });
            return {
              ...otherProps,
              direction: isReversed ? "row-reverse" : "row"
            };
          }
          return otherProps;
        }
        function useFlex(props) {
          const {
            align,
            className,
            direction: directionProp = "row",
            expanded = true,
            gap = 2,
            justify = "space-between",
            wrap = false,
            ...otherProps
          } = useContextSystem(useDeprecatedProps$3(props), "Flex");
          const directionAsArray = Array.isArray(directionProp) ? directionProp : [directionProp];
          const direction = useResponsiveValue(directionAsArray);
          const isColumn = typeof direction === "string" && !!direction.includes("column");
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            const base = /* @__PURE__ */css({
              alignItems: align !== null && align !== void 0 ? align : isColumn ? "normal" : "center",
              flexDirection: direction,
              flexWrap: wrap ? "wrap" : void 0,
              gap: space(gap),
              justifyContent: justify,
              height: isColumn && expanded ? "100%" : void 0,
              width: !isColumn && expanded ? "100%" : void 0
            }, "", "");
            return cx(Flex$1, base, isColumn ? ItemsColumn : ItemsRow, className);
          }, [align, className, cx, direction, expanded, gap, isColumn, justify, wrap]);
          return {
            ...otherProps,
            className: classes,
            isColumn
          };
        }

        /**
         * WordPress dependencies
         */
        const FlexContext = reactExports.createContext({
          flexItemDisplay: undefined
        });
        const useFlexContext = () => reactExports.useContext(FlexContext);

        /**
         * External dependencies
         */

        function UnconnectedFlex(props, forwardedRef) {
          const {
            children,
            isColumn,
            ...otherProps
          } = useFlex(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(FlexContext.Provider, {
            value: {
              flexItemDisplay: isColumn ? 'block' : undefined
            },
            children: /*#__PURE__*/jsxRuntimeExports.jsx(View, {
              ...otherProps,
              ref: forwardedRef,
              children: children
            })
          });
        }

        /**
         * `Flex` is a primitive layout component that adaptively aligns child content
         * horizontally or vertically. `Flex` powers components like `HStack` and
         * `VStack`.
         *
         * `Flex` is used with any of its two sub-components, `FlexItem` and
         * `FlexBlock`.
         *
         * ```jsx
         * import { Flex, FlexBlock, FlexItem } from '@wordpress/components';
         *
         * function Example() {
         *   return (
         *     <Flex>
         *       <FlexItem>
         *         <p>Code</p>
         *       </FlexItem>
         *       <FlexBlock>
         *         <p>Poetry</p>
         *       </FlexBlock>
         *     </Flex>
         *   );
         * }
         * ```
         */
        const Flex = contextConnect(UnconnectedFlex, 'Flex');
        function useFlexItem(props) {
          const {
            className,
            display: displayProp,
            isBlock = false,
            ...otherProps
          } = useContextSystem(props, "FlexItem");
          const sx = {};
          const contextDisplay = useFlexContext().flexItemDisplay;
          sx.Base = /* @__PURE__ */css({
            display: displayProp || contextDisplay
          }, "", "");
          const cx = useCx();
          const classes = cx(Item, sx.Base, isBlock && block$1, className);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedFlexItem(props, forwardedRef) {
          const flexItemProps = useFlexItem(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...flexItemProps,
            ref: forwardedRef
          });
        }

        /**
         * `FlexItem` is a primitive layout component that aligns content within layout
         * containers like `Flex`.
         *
         * ```jsx
         * import { Flex, FlexItem } from '@wordpress/components';
         *
         * function Example() {
         *   return (
         *     <Flex>
         *       <FlexItem>...</FlexItem>
         *     </Flex>
         *   );
         * }
         * ```
         */
        const FlexItem = contextConnect(UnconnectedFlexItem, 'FlexItem');

        /**
         * Internal dependencies
         */

        function useFlexBlock(props) {
          const otherProps = useContextSystem(props, 'FlexBlock');
          const flexItemProps = useFlexItem({
            isBlock: true,
            ...otherProps
          });
          return flexItemProps;
        }

        /**
         * External dependencies
         */

        function UnconnectedFlexBlock(props, forwardedRef) {
          const flexBlockProps = useFlexBlock(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...flexBlockProps,
            ref: forwardedRef
          });
        }

        /**
         * `FlexBlock` is a primitive layout component that adaptively resizes content
         * within layout containers like `Flex`.
         *
         * ```jsx
         * import { Flex, FlexBlock } from '@wordpress/components';
         *
         * function Example() {
         *   return (
         *     <Flex>
         *       <FlexBlock>...</FlexBlock>
         *     </Flex>
         *   );
         * }
         * ```
         */
        const FlexBlock = contextConnect(UnconnectedFlexBlock, 'FlexBlock');
        function isDefined(o) {
          return typeof o !== "undefined" && o !== null;
        }
        function useSpacer(props) {
          const {
            className,
            margin,
            marginBottom = 2,
            marginLeft,
            marginRight,
            marginTop,
            marginX,
            marginY,
            padding,
            paddingBottom,
            paddingLeft,
            paddingRight,
            paddingTop,
            paddingX,
            paddingY,
            ...otherProps
          } = useContextSystem(props, "Spacer");
          const cx = useCx();
          const classes = cx(isDefined(margin) && /* @__PURE__ */css("margin:", space(margin), ";" + "", ""), isDefined(marginY) && /* @__PURE__ */css("margin-bottom:", space(marginY), ";margin-top:", space(marginY), ";" + "", ""), isDefined(marginX) && /* @__PURE__ */css("margin-left:", space(marginX), ";margin-right:", space(marginX), ";" + "", ""), isDefined(marginTop) && /* @__PURE__ */css("margin-top:", space(marginTop), ";" + "", ""), isDefined(marginBottom) && /* @__PURE__ */css("margin-bottom:", space(marginBottom), ";" + "", ""), isDefined(marginLeft) && rtl({
            marginLeft: space(marginLeft)
          })(), isDefined(marginRight) && rtl({
            marginRight: space(marginRight)
          })(), isDefined(padding) && /* @__PURE__ */css("padding:", space(padding), ";" + "", ""), isDefined(paddingY) && /* @__PURE__ */css("padding-bottom:", space(paddingY), ";padding-top:", space(paddingY), ";" + "", ""), isDefined(paddingX) && /* @__PURE__ */css("padding-left:", space(paddingX), ";padding-right:", space(paddingX), ";" + "", ""), isDefined(paddingTop) && /* @__PURE__ */css("padding-top:", space(paddingTop), ";" + "", ""), isDefined(paddingBottom) && /* @__PURE__ */css("padding-bottom:", space(paddingBottom), ";" + "", ""), isDefined(paddingLeft) && rtl({
            paddingLeft: space(paddingLeft)
          })(), isDefined(paddingRight) && rtl({
            paddingRight: space(paddingRight)
          })(), className);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedSpacer(props, forwardedRef) {
          const spacerProps = useSpacer(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...spacerProps,
            ref: forwardedRef
          });
        }

        /**
         * `Spacer` is a primitive layout component that providers inner (`padding`) or outer (`margin`) space in-between components. It can also be used to adaptively provide space within an `HStack` or `VStack`.
         *
         * `Spacer` comes with a bunch of shorthand props to adjust `margin` and `padding`. The values of these props
         * can either be a number (which will act as a multiplier to the library's grid system base of 4px),
         * or a literal CSS value string.
         *
         * ```jsx
         * import { Spacer } from `@wordpress/components`
         *
         * function Example() {
         *   return (
         *     <View>
         *       <Spacer>
         *         <Heading>WordPress.org</Heading>
         *       </Spacer>
         *       <Text>
         *         Code is Poetry
         *       </Text>
         *     </View>
         *   );
         * }
         * ```
         */
        const Spacer = contextConnect(UnconnectedSpacer, 'Spacer');

        /**
         * WordPress dependencies
         */

        /** @typedef {{icon: JSX.Element, size?: number} & import('@wordpress/primitives').SVGProps} IconProps */

        /**
         * Return an SVG icon.
         *
         * @param {IconProps}                                 props icon is the SVG component to render
         *                                                          size is a number specifying the icon size in pixels
         *                                                          Other props will be passed to wrapped SVG component
         * @param {import('react').ForwardedRef<HTMLElement>} ref   The forwarded ref to the SVG element.
         *
         * @return {JSX.Element}  Icon component
         */
        function Icon$1({
          icon,
          size = 24,
          ...props
        }, ref) {
          return reactExports.cloneElement(icon, {
            width: size,
            height: size,
            ...props,
            ref
          });
        }
        const Icon$2 = reactExports.forwardRef(Icon$1);

        /**
         * WordPress dependencies
         */
        const check = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "M16.7 7.1l-6.3 8.5-3.3-2.5-.9 1.2 4.5 3.4L17.9 8z"
          })
        });

        /**
         * WordPress dependencies
         */
        const chevronDown = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "M17.5 11.6L12 16l-5.5-4.4.9-1.2L12 14l4.5-3.6 1 1.2z"
          })
        });

        /**
         * WordPress dependencies
         */
        const chevronUp = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          viewBox: "0 0 24 24",
          xmlns: "http://www.w3.org/2000/svg",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "M6.5 12.4L12 8l5.5 4.4-.9 1.2L12 10l-4.5 3.6-1-1.2z"
          })
        });

        /**
         * WordPress dependencies
         */
        const close = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "m13.06 12 6.47-6.47-1.06-1.06L12 10.94 5.53 4.47 4.47 5.53 10.94 12l-6.47 6.47 1.06 1.06L12 13.06l6.47 6.47 1.06-1.06L13.06 12Z"
          })
        });

        /**
         * WordPress dependencies
         */
        const copy$1 = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M5 4.5h11a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5H5a.5.5 0 0 1-.5-.5V5a.5.5 0 0 1 .5-.5ZM3 5a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5Zm17 3v10.75c0 .69-.56 1.25-1.25 1.25H6v1.5h12.75a2.75 2.75 0 0 0 2.75-2.75V8H20Z"
          })
        });

        /**
         * WordPress dependencies
         */
        const plus = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "M11 12.5V17.5H12.5V12.5H17.5V11H12.5V6H11V11H6V12.5H11Z"
          })
        });

        /**
         * WordPress dependencies
         */
        const reset = /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          children: /*#__PURE__*/jsxRuntimeExports.jsx(Path, {
            d: "M7 11.5h10V13H7z"
          })
        });
        const Truncate = {
          name: "hdknak",
          styles: "display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        };

        /**
         * Internal dependencies
         */
        const TRUNCATE_ELLIPSIS = '…';
        const TRUNCATE_TYPE = {
          auto: 'auto',
          head: 'head',
          middle: 'middle',
          none: 'none'
        };
        const TRUNCATE_DEFAULT_PROPS = {
          ellipsis: TRUNCATE_ELLIPSIS,
          ellipsizeMode: TRUNCATE_TYPE.auto,
          limit: 0,
          numberOfLines: 0
        };

        // Source
        // https://github.com/kahwee/truncate-middle
        function truncateMiddle(word, headLength, tailLength, ellipsis) {
          if (typeof word !== 'string') {
            return '';
          }
          const wordLength = word.length;
          // Setting default values
          // eslint-disable-next-line no-bitwise
          const frontLength = ~~headLength; // Will cast to integer
          // eslint-disable-next-line no-bitwise
          const backLength = ~~tailLength;
          /* istanbul ignore next */
          const truncateStr = isValueDefined(ellipsis) ? ellipsis : TRUNCATE_ELLIPSIS;
          if (frontLength === 0 && backLength === 0 || frontLength >= wordLength || backLength >= wordLength || frontLength + backLength >= wordLength) {
            return word;
          } else if (backLength === 0) {
            return word.slice(0, frontLength) + truncateStr;
          }
          return word.slice(0, frontLength) + truncateStr + word.slice(wordLength - backLength);
        }
        function truncateContent(words = '', props) {
          const mergedProps = {
            ...TRUNCATE_DEFAULT_PROPS,
            ...props
          };
          const {
            ellipsis,
            ellipsizeMode,
            limit
          } = mergedProps;
          if (ellipsizeMode === TRUNCATE_TYPE.none) {
            return words;
          }
          let truncateHead;
          let truncateTail;
          switch (ellipsizeMode) {
            case TRUNCATE_TYPE.head:
              truncateHead = 0;
              truncateTail = limit;
              break;
            case TRUNCATE_TYPE.middle:
              truncateHead = Math.floor(limit / 2);
              truncateTail = Math.floor(limit / 2);
              break;
            default:
              truncateHead = limit;
              truncateTail = 0;
          }
          const truncatedContent = ellipsizeMode !== TRUNCATE_TYPE.auto ? truncateMiddle(words, truncateHead, truncateTail, ellipsis) : words;
          return truncatedContent;
        }
        function useTruncate(props) {
          const {
            className,
            children,
            ellipsis = TRUNCATE_ELLIPSIS,
            ellipsizeMode = TRUNCATE_TYPE.auto,
            limit = 0,
            numberOfLines = 0,
            ...otherProps
          } = useContextSystem(props, "Truncate");
          const cx = useCx();
          let childrenAsText;
          if (typeof children === "string") {
            childrenAsText = children;
          } else if (typeof children === "number") {
            childrenAsText = children.toString();
          }
          const truncatedContent = childrenAsText ? truncateContent(childrenAsText, {
            ellipsis,
            ellipsizeMode,
            limit,
            numberOfLines
          }) : children;
          const shouldTruncate = !!childrenAsText && ellipsizeMode === TRUNCATE_TYPE.auto;
          const classes = reactExports.useMemo(() => {
            const truncateLines = /* @__PURE__ */css(numberOfLines === 1 ? "word-break: break-all;" : "", " -webkit-box-orient:vertical;-webkit-line-clamp:", numberOfLines, ";display:-webkit-box;overflow:hidden;" + "", "");
            return cx(shouldTruncate && !numberOfLines && Truncate, shouldTruncate && !!numberOfLines && truncateLines, className);
          }, [className, cx, numberOfLines, shouldTruncate]);
          return {
            ...otherProps,
            className: classes,
            children: truncatedContent
          };
        }
        const Text$1 = /* @__PURE__ */css("color:", COLORS$1.gray[900], ";line-height:", CONFIG.fontLineHeightBase, ";margin:0;text-wrap:balance;text-wrap:pretty;" + "", "");
        const block = {
          name: "4zleql",
          styles: "display:block"
        };
        const positive = /* @__PURE__ */css("color:", COLORS$1.alert.green, ";" + "", "");
        const destructive = /* @__PURE__ */css("color:", COLORS$1.alert.red, ";" + "", "");
        const muted = /* @__PURE__ */css("color:", COLORS$1.gray[700], ";" + "", "");
        const highlighterText = /* @__PURE__ */css("mark{background:", COLORS$1.alert.yellow, ";border-radius:", CONFIG.radiusSmall, ";box-shadow:0 0 0 1px rgba( 0, 0, 0, 0.05 ) inset,0 -1px 0 rgba( 0, 0, 0, 0.1 ) inset;}" + "", "");
        const upperCase = {
          name: "50zrmy",
          styles: "text-transform:uppercase"
        };
        const styles$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
          __proto__: null,
          Text: Text$1,
          block,
          destructive,
          highlighterText,
          muted,
          positive,
          upperCase
        }, Symbol.toStringTag, {
          value: 'Module'
        }));
        var dist = {
          exports: {}
        };
        (function (module) {
          module.exports = /******/function (modules) {
            // webpackBootstrap
            /******/ // The module cache
            /******/
            var installedModules = {};
            /******/
            /******/ // The require function
            /******/
            function __webpack_require__(moduleId) {
              /******/
              /******/ // Check if module is in cache
              /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;
              /******/
              /******/ // Create a new module (and put it into the cache)
              /******/
              var module = installedModules[moduleId] = {
                /******/exports: {},
                /******/id: moduleId,
                /******/loaded: false
                /******/
              };
              /******/
              /******/ // Execute the module function
              /******/
              modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
              /******/
              /******/ // Flag the module as loaded
              /******/
              module.loaded = true;
              /******/
              /******/ // Return the exports of the module
              /******/
              return module.exports;
              /******/
            }
            /******/
            /******/
            /******/ // expose the modules object (__webpack_modules__)
            /******/
            __webpack_require__.m = modules;
            /******/
            /******/ // expose the module cache
            /******/
            __webpack_require__.c = installedModules;
            /******/
            /******/ // __webpack_public_path__
            /******/
            __webpack_require__.p = "";
            /******/
            /******/ // Load entry module and return exports
            /******/
            return __webpack_require__(0);
            /******/
          }
          /************************************************************************/
          /******/([(/* 0 */
          /***/function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(1);

            /***/
          }), (/* 1 */
          /***/function (module, exports, __webpack_require__) {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            var _utils = __webpack_require__(2);
            Object.defineProperty(exports, 'combineChunks', {
              enumerable: true,
              get: function get() {
                return _utils.combineChunks;
              }
            });
            Object.defineProperty(exports, 'fillInChunks', {
              enumerable: true,
              get: function get() {
                return _utils.fillInChunks;
              }
            });
            Object.defineProperty(exports, 'findAll', {
              enumerable: true,
              get: function get() {
                return _utils.findAll;
              }
            });
            Object.defineProperty(exports, 'findChunks', {
              enumerable: true,
              get: function get() {
                return _utils.findChunks;
              }
            });

            /***/
          }), (/* 2 */
          /***/function (module, exports) {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            /**
             * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.
             * @return Array of "chunks" (where a Chunk is { start:number, end:number, highlight:boolean })
             */
            exports.findAll = function findAll(_ref) {
              var autoEscape = _ref.autoEscape,
                _ref$caseSensitive = _ref.caseSensitive,
                caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,
                _ref$findChunks = _ref.findChunks,
                findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,
                sanitize = _ref.sanitize,
                searchWords = _ref.searchWords,
                textToHighlight = _ref.textToHighlight;
              return fillInChunks({
                chunksToHighlight: combineChunks({
                  chunks: findChunks({
                    autoEscape: autoEscape,
                    caseSensitive: caseSensitive,
                    sanitize: sanitize,
                    searchWords: searchWords,
                    textToHighlight: textToHighlight
                  })
                }),
                totalLength: textToHighlight ? textToHighlight.length : 0
              });
            };

            /**
             * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.
             * @return {start:number, end:number}[]
             */

            var combineChunks = exports.combineChunks = function combineChunks(_ref2) {
              var chunks = _ref2.chunks;
              chunks = chunks.sort(function (first, second) {
                return first.start - second.start;
              }).reduce(function (processedChunks, nextChunk) {
                // First chunk just goes straight in the array...
                if (processedChunks.length === 0) {
                  return [nextChunk];
                } else {
                  // ... subsequent chunks get checked to see if they overlap...
                  var prevChunk = processedChunks.pop();
                  if (nextChunk.start < prevChunk.end) {
                    // It may be the case that prevChunk completely surrounds nextChunk, so take the
                    // largest of the end indexes.
                    var endIndex = Math.max(prevChunk.end, nextChunk.end);
                    processedChunks.push({
                      highlight: false,
                      start: prevChunk.start,
                      end: endIndex
                    });
                  } else {
                    processedChunks.push(prevChunk, nextChunk);
                  }
                  return processedChunks;
                }
              }, []);
              return chunks;
            };

            /**
             * Examine text for any matches.
             * If we find matches, add them to the returned array as a "chunk" object ({start:number, end:number}).
             * @return {start:number, end:number}[]
             */
            var defaultFindChunks = function defaultFindChunks(_ref3) {
              var autoEscape = _ref3.autoEscape,
                caseSensitive = _ref3.caseSensitive,
                _ref3$sanitize = _ref3.sanitize,
                sanitize = _ref3$sanitize === undefined ? defaultSanitize : _ref3$sanitize,
                searchWords = _ref3.searchWords,
                textToHighlight = _ref3.textToHighlight;
              textToHighlight = sanitize(textToHighlight);
              return searchWords.filter(function (searchWord) {
                return searchWord;
              }) // Remove empty words
              .reduce(function (chunks, searchWord) {
                searchWord = sanitize(searchWord);
                if (autoEscape) {
                  searchWord = escapeRegExpFn(searchWord);
                }
                var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');
                var match = void 0;
                while (match = regex.exec(textToHighlight)) {
                  var _start = match.index;
                  var _end = regex.lastIndex;
                  // We do not return zero-length matches
                  if (_end > _start) {
                    chunks.push({
                      highlight: false,
                      start: _start,
                      end: _end
                    });
                  }

                  // Prevent browsers like Firefox from getting stuck in an infinite loop
                  // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/
                  if (match.index === regex.lastIndex) {
                    regex.lastIndex++;
                  }
                }
                return chunks;
              }, []);
            };
            // Allow the findChunks to be overridden in findAll,
            // but for backwards compatibility we export as the old name
            exports.findChunks = defaultFindChunks;

            /**
             * Given a set of chunks to highlight, create an additional set of chunks
             * to represent the bits of text between the highlighted text.
             * @param chunksToHighlight {start:number, end:number}[]
             * @param totalLength number
             * @return {start:number, end:number, highlight:boolean}[]
             */

            var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {
              var chunksToHighlight = _ref4.chunksToHighlight,
                totalLength = _ref4.totalLength;
              var allChunks = [];
              var append = function append(start, end, highlight) {
                if (end - start > 0) {
                  allChunks.push({
                    start: start,
                    end: end,
                    highlight: highlight
                  });
                }
              };
              if (chunksToHighlight.length === 0) {
                append(0, totalLength, false);
              } else {
                var lastIndex = 0;
                chunksToHighlight.forEach(function (chunk) {
                  append(lastIndex, chunk.start, false);
                  append(chunk.start, chunk.end, true);
                  lastIndex = chunk.end;
                });
                append(lastIndex, totalLength, false);
              }
              return allChunks;
            };
            function defaultSanitize(string) {
              return string;
            }
            function escapeRegExpFn(string) {
              return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            }

            /***/
          }
          /******/)]);
        })(dist);
        var distExports = dist.exports;

        /**
         * External dependencies
         */

        /**
         * Source:
         * https://github.com/bvaughn/react-highlight-words/blob/HEAD/src/Highlighter.js
         */

        /**
         * @typedef Options
         * @property {string}                                                     [activeClassName='']      Classname for active highlighted areas.
         * @property {number}                                                     [activeIndex=-1]          The index of the active highlighted area.
         * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [activeStyle]             Styles to apply to the active highlighted area.
         * @property {boolean}                                                    [autoEscape]              Whether to automatically escape text.
         * @property {boolean}                                                    [caseSensitive=false]     Whether to highlight in a case-sensitive manner.
         * @property {string}                                                     children                  Children to highlight.
         * @property {import('highlight-words-core').FindAllArgs['findChunks']}   [findChunks]              Custom `findChunks` function to pass to `highlight-words-core`.
         * @property {string | Record<string, unknown>}                           [highlightClassName='']   Classname to apply to highlighted text or a Record of classnames to apply to given text (which should be the key).
         * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [highlightStyle={}]       Styles to apply to highlighted text.
         * @property {keyof JSX.IntrinsicElements}                                [highlightTag='mark']     Tag to use for the highlighted text.
         * @property {import('highlight-words-core').FindAllArgs['sanitize']}     [sanitize]                Custom `santize` function to pass to `highlight-words-core`.
         * @property {string[]}                                                   [searchWords=[]]          Words to search for and highlight.
         * @property {string}                                                     [unhighlightClassName=''] Classname to apply to unhighlighted text.
         * @property {import('react').AllHTMLAttributes<HTMLDivElement>['style']} [unhighlightStyle]        Style to apply to unhighlighted text.
         */

        /**
         * Maps props to lowercase names.
         *
         * @param object Props to map.
         * @return The mapped props.
         */
        const lowercaseProps = object => {
          const mapped = {};
          for (const key in object) {
            mapped[key.toLowerCase()] = object[key];
          }
          return mapped;
        };
        const memoizedLowercaseProps = memize(lowercaseProps);

        /**
         * @param options
         * @param options.activeClassName
         * @param options.activeIndex
         * @param options.activeStyle
         * @param options.autoEscape
         * @param options.caseSensitive
         * @param options.children
         * @param options.findChunks
         * @param options.highlightClassName
         * @param options.highlightStyle
         * @param options.highlightTag
         * @param options.sanitize
         * @param options.searchWords
         * @param options.unhighlightClassName
         * @param options.unhighlightStyle
         */
        function createHighlighterText({
          activeClassName = '',
          activeIndex = -1,
          activeStyle,
          autoEscape,
          caseSensitive = false,
          children,
          findChunks,
          highlightClassName = '',
          highlightStyle = {},
          highlightTag = 'mark',
          sanitize,
          searchWords = [],
          unhighlightClassName = '',
          unhighlightStyle
        }) {
          if (!children) {
            return null;
          }
          if (typeof children !== 'string') {
            return children;
          }
          const textToHighlight = children;
          const chunks = distExports.findAll({
            autoEscape,
            caseSensitive,
            findChunks,
            sanitize,
            searchWords,
            textToHighlight
          });
          const HighlightTag = highlightTag;
          let highlightIndex = -1;
          let highlightClassNames = '';
          let highlightStyles;
          const textContent = chunks.map((chunk, index) => {
            const text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);
            if (chunk.highlight) {
              highlightIndex++;
              let highlightClass;
              if (typeof highlightClassName === 'object') {
                if (!caseSensitive) {
                  highlightClassName = memoizedLowercaseProps(highlightClassName);
                  highlightClass = highlightClassName[text.toLowerCase()];
                } else {
                  highlightClass = highlightClassName[text];
                }
              } else {
                highlightClass = highlightClassName;
              }
              const isActive = highlightIndex === +activeIndex;
              highlightClassNames = `${highlightClass} ${isActive ? activeClassName : ''}`;
              highlightStyles = isActive === true && activeStyle !== null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
              const props = {
                children: text,
                className: highlightClassNames,
                key: index,
                style: highlightStyles
              };

              // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)
              // Only pass through the highlightIndex attribute for custom components.
              if (typeof HighlightTag !== 'string') {
                props.highlightIndex = highlightIndex;
              }
              return reactExports.createElement(HighlightTag, props);
            }
            return reactExports.createElement('span', {
              children: text,
              className: unhighlightClassName,
              key: index,
              style: unhighlightStyle
            });
          });
          return textContent;
        }

        /**
         * External dependencies
         */

        const BASE_FONT_SIZE = 13;
        const PRESET_FONT_SIZES = {
          body: BASE_FONT_SIZE,
          caption: 10,
          footnote: 11,
          largeTitle: 28,
          subheadline: 12,
          title: 20
        };
        const HEADING_FONT_SIZES = [1, 2, 3, 4, 5, 6].flatMap(n => [n, n.toString()]);
        function getFontSize(size = BASE_FONT_SIZE) {
          if (size in PRESET_FONT_SIZES) {
            return getFontSize(PRESET_FONT_SIZES[size]);
          }
          if (typeof size !== 'number') {
            const parsed = parseFloat(size);
            if (Number.isNaN(parsed)) {
              return size;
            }
            size = parsed;
          }
          const ratio = `(${size} / ${BASE_FONT_SIZE})`;
          return `calc(${ratio} * ${CONFIG.fontSize})`;
        }
        function getHeadingFontSize(size = 3) {
          if (!HEADING_FONT_SIZES.includes(size)) {
            return getFontSize(size);
          }
          const headingSize = `fontSizeH${size}`;
          return CONFIG[headingSize];
        }

        /**
         * External dependencies
         */

        function getLineHeight(adjustLineHeightForInnerControls, lineHeight) {
          if (lineHeight) {
            return lineHeight;
          }
          if (!adjustLineHeightForInnerControls) {
            return;
          }
          let value = `calc(${CONFIG.controlHeight} + ${space(2)})`;
          switch (adjustLineHeightForInnerControls) {
            case 'large':
              value = `calc(${CONFIG.controlHeightLarge} + ${space(2)})`;
              break;
            case 'small':
              value = `calc(${CONFIG.controlHeightSmall} + ${space(2)})`;
              break;
            case 'xSmall':
              value = `calc(${CONFIG.controlHeightXSmall} + ${space(2)})`;
              break;
          }
          return value;
        }
        var _ref$6 = {
          name: "50zrmy",
          styles: "text-transform:uppercase"
        };
        function useText(props) {
          const {
            adjustLineHeightForInnerControls,
            align,
            children,
            className,
            color,
            ellipsizeMode,
            isDestructive = false,
            display,
            highlightEscape = false,
            highlightCaseSensitive = false,
            highlightWords,
            highlightSanitize,
            isBlock = false,
            letterSpacing,
            lineHeight: lineHeightProp,
            optimizeReadabilityFor,
            size,
            truncate = false,
            upperCase = false,
            variant,
            weight = CONFIG.fontWeight,
            ...otherProps
          } = useContextSystem(props, "Text");
          let content = children;
          const isHighlighter = Array.isArray(highlightWords);
          const isCaption = size === "caption";
          if (isHighlighter) {
            if (typeof children !== "string") {
              throw new TypeError("`children` of `Text` must only be `string` types when `highlightWords` is defined");
            }
            content = createHighlighterText({
              autoEscape: highlightEscape,
              children,
              caseSensitive: highlightCaseSensitive,
              searchWords: highlightWords,
              sanitize: highlightSanitize
            });
          }
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            const sx = {};
            const lineHeight = getLineHeight(adjustLineHeightForInnerControls, lineHeightProp);
            sx.Base = /* @__PURE__ */css({
              color,
              display,
              fontSize: getFontSize(size),
              fontWeight: weight,
              lineHeight,
              letterSpacing,
              textAlign: align
            }, "", "");
            sx.upperCase = _ref$6;
            sx.optimalTextColor = null;
            if (optimizeReadabilityFor) {
              const isOptimalTextColorDark = getOptimalTextShade(optimizeReadabilityFor) === "dark";
              sx.optimalTextColor = isOptimalTextColorDark ? /* @__PURE__ */css({
                color: COLORS$1.gray[900]
              }, "", "") : /* @__PURE__ */css({
                color: COLORS$1.white
              }, "", "");
            }
            return cx(Text$1, sx.Base, sx.optimalTextColor, isDestructive && destructive, !!isHighlighter && highlighterText, isBlock && block, isCaption && muted, variant && styles$1[variant], upperCase && sx.upperCase, className);
          }, [adjustLineHeightForInnerControls, align, className, color, cx, display, isBlock, isCaption, isDestructive, isHighlighter, letterSpacing, lineHeightProp, optimizeReadabilityFor, size, upperCase, variant, weight]);
          let finalEllipsizeMode;
          if (truncate === true) {
            finalEllipsizeMode = "auto";
          }
          if (truncate === false) {
            finalEllipsizeMode = "none";
          }
          const finalComponentProps = {
            ...otherProps,
            className: classes,
            children,
            ellipsizeMode: ellipsizeMode || finalEllipsizeMode
          };
          const truncateProps = useTruncate(finalComponentProps);
          if (!truncate && Array.isArray(children)) {
            content = reactExports.Children.map(children, child => {
              if (typeof child !== "object" || child === null || !("props" in child)) {
                return child;
              }
              const isLink = hasConnectNamespace(child, ["Link"]);
              if (isLink) {
                return reactExports.cloneElement(child, {
                  size: child.props.size || "inherit"
                });
              }
              return child;
            });
          }
          return {
            ...truncateProps,
            children: truncate ? truncateProps.children : content
          };
        }

        /**
         * Internal dependencies
         */

        /**
         * @param props
         * @param forwardedRef
         */
        function UnconnectedText(props, forwardedRef) {
          const textProps = useText(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            as: "span",
            ...textProps,
            ref: forwardedRef
          });
        }

        /**
         * `Text` is a core component that renders text in the library, using the
         * library's typography system.
         *
         * `Text` can be used to render any text-content, like an HTML `p` or `span`.
         *
         * @example
         *
         * ```jsx
         * import { __experimentalText as Text } from `@wordpress/components`;
         *
         * function Example() {
         * 	return <Text>Code is Poetry</Text>;
         * }
         * ```
         */
        const Text = contextConnect(UnconnectedText, 'Text');
        const Prefix = /* @__PURE__ */createStyled("span", {
          target: "em5sgkm8"
        })({
          name: "pvvbxf",
          styles: "box-sizing:border-box;display:block"
        });
        const Suffix = /* @__PURE__ */createStyled("span", {
          target: "em5sgkm7"
        })({
          name: "jgf79h",
          styles: "align-items:center;align-self:stretch;box-sizing:border-box;display:flex"
        });
        const backdropBorderColor = ({
          disabled,
          isBorderless
        }) => {
          if (isBorderless) {
            return "transparent";
          }
          if (disabled) {
            return COLORS$1.ui.borderDisabled;
          }
          return COLORS$1.ui.border;
        };
        const BackdropUI = /* @__PURE__ */createStyled("div", {
          target: "em5sgkm6"
        })("&&&{box-sizing:border-box;border-color:", backdropBorderColor, ";border-radius:inherit;border-style:solid;border-width:1px;bottom:0;left:0;margin:0;padding:0;pointer-events:none;position:absolute;right:0;top:0;", rtl({
          paddingLeft: 2
        }), ";}" + "");
        const Root$1 = /* @__PURE__ */createStyled(Flex, {
          target: "em5sgkm5"
        })("box-sizing:border-box;position:relative;border-radius:", CONFIG.radiusSmall, ";padding-top:0;&:focus-within:not( :has( :is( ", Prefix, ", ", Suffix, " ):focus-within ) ){", BackdropUI, "{border-color:", COLORS$1.ui.borderFocus, ";box-shadow:", CONFIG.controlBoxShadowFocus, ";outline:2px solid transparent;outline-offset:-2px;}}" + "");
        const containerDisabledStyles = ({
          disabled
        }) => {
          const backgroundColor = disabled ? COLORS$1.ui.backgroundDisabled : COLORS$1.ui.background;
          return /* @__PURE__ */css({
            backgroundColor
          }, "", "");
        };
        var _ref$5 = {
          name: "1d3w5wq",
          styles: "width:100%"
        };
        const containerWidthStyles = ({
          __unstableInputWidth,
          labelPosition
        }) => {
          if (!__unstableInputWidth) {
            return _ref$5;
          }
          if (labelPosition === "side") {
            return "";
          }
          if (labelPosition === "edge") {
            return /* @__PURE__ */css({
              flex: `0 0 ${__unstableInputWidth}`
            }, "", "");
          }
          return /* @__PURE__ */css({
            width: __unstableInputWidth
          }, "", "");
        };
        const Container = /* @__PURE__ */createStyled("div", {
          target: "em5sgkm4"
        })("align-items:center;box-sizing:border-box;border-radius:inherit;display:flex;flex:1;position:relative;", containerDisabledStyles, " ", containerWidthStyles, ";" + "");
        const disabledStyles$1 = ({
          disabled
        }) => {
          if (!disabled) {
            return "";
          }
          return /* @__PURE__ */css({
            color: COLORS$1.ui.textDisabled
          }, "", "");
        };
        const fontSizeStyles = ({
          inputSize: size
        }) => {
          const sizes = {
            default: "13px",
            small: "11px",
            compact: "13px",
            "__unstable-large": "13px"
          };
          const fontSize = sizes[size] || sizes.default;
          const fontSizeMobile = "16px";
          return /* @__PURE__ */css("font-size:", fontSizeMobile, ";@media ( min-width: 600px ){font-size:", fontSize, ";}" + "", "");
        };
        const getSizeConfig = ({
          inputSize: size,
          __next40pxDefaultSize
        }) => {
          const sizes = {
            default: {
              height: 40,
              lineHeight: 1,
              minHeight: 40,
              paddingLeft: CONFIG.controlPaddingX,
              paddingRight: CONFIG.controlPaddingX
            },
            small: {
              height: 24,
              lineHeight: 1,
              minHeight: 24,
              paddingLeft: CONFIG.controlPaddingXSmall,
              paddingRight: CONFIG.controlPaddingXSmall
            },
            compact: {
              height: 32,
              lineHeight: 1,
              minHeight: 32,
              paddingLeft: CONFIG.controlPaddingXSmall,
              paddingRight: CONFIG.controlPaddingXSmall
            },
            "__unstable-large": {
              height: 40,
              lineHeight: 1,
              minHeight: 40,
              paddingLeft: CONFIG.controlPaddingX,
              paddingRight: CONFIG.controlPaddingX
            }
          };
          if (!__next40pxDefaultSize) {
            sizes.default = sizes.compact;
          }
          return sizes[size] || sizes.default;
        };
        const sizeStyles$1 = props => {
          return /* @__PURE__ */css(getSizeConfig(props), "", "");
        };
        const customPaddings = ({
          paddingInlineStart,
          paddingInlineEnd
        }) => {
          return /* @__PURE__ */css({
            paddingInlineStart,
            paddingInlineEnd
          }, "", "");
        };
        const dragStyles = ({
          isDragging,
          dragCursor
        }) => {
          let defaultArrowStyles;
          let activeDragCursorStyles;
          if (isDragging) {
            defaultArrowStyles = /* @__PURE__ */css("cursor:", dragCursor, ";user-select:none;&::-webkit-outer-spin-button,&::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}" + "", "");
          }
          if (isDragging && dragCursor) {
            activeDragCursorStyles = /* @__PURE__ */css("&:active{cursor:", dragCursor, ";}" + "", "");
          }
          return /* @__PURE__ */css(defaultArrowStyles, " ", activeDragCursorStyles, ";" + "", "");
        };
        const Input$1 = /* @__PURE__ */createStyled("input", {
          target: "em5sgkm3"
        })("&&&{background-color:transparent;box-sizing:border-box;border:none;box-shadow:none!important;color:", COLORS$1.theme.foreground, ";display:block;font-family:inherit;margin:0;outline:none;width:100%;", dragStyles, " ", disabledStyles$1, " ", fontSizeStyles, " ", sizeStyles$1, " ", customPaddings, " &::-webkit-input-placeholder{line-height:normal;}}" + "");
        const BaseLabel = /* @__PURE__ */createStyled(Text, {
          target: "em5sgkm2"
        })("&&&{", baseLabelTypography, ";box-sizing:border-box;display:block;padding-top:0;padding-bottom:0;max-width:100%;z-index:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}" + "");
        const Label$1 = props => /* @__PURE__ */jsxRuntimeExports.jsx(BaseLabel, {
          ...props,
          as: "label"
        });
        const LabelWrapper = /* @__PURE__ */createStyled(FlexItem, {
          target: "em5sgkm1"
        })({
          name: "1b6uupn",
          styles: "max-width:calc( 100% - 10px )"
        });
        const prefixSuffixWrapperStyles = ({
          variant = "default",
          size,
          __next40pxDefaultSize,
          isPrefix
        }) => {
          const {
            paddingLeft: padding
          } = getSizeConfig({
            inputSize: size,
            __next40pxDefaultSize
          });
          const paddingProperty = isPrefix ? "paddingInlineStart" : "paddingInlineEnd";
          if (variant === "default") {
            return /* @__PURE__ */css({
              [paddingProperty]: padding
            }, "", "");
          }
          return /* @__PURE__ */css({
            display: "flex",
            [paddingProperty]: padding - 4
          }, "", "");
        };
        const PrefixSuffixWrapper = /* @__PURE__ */createStyled("div", {
          target: "em5sgkm0"
        })(prefixSuffixWrapperStyles, ";" + "");

        /**
         * WordPress dependencies
         */
        function Backdrop({
          disabled = false,
          isBorderless = false
        }) {
          return /*#__PURE__*/jsxRuntimeExports.jsx(BackdropUI, {
            "aria-hidden": "true",
            className: "components-input-control__backdrop",
            disabled: disabled,
            isBorderless: isBorderless
          });
        }
        const MemoizedBackdrop = reactExports.memo(Backdrop);

        /**
         * Internal dependencies
         */
        function Label({
          children,
          hideLabelFromVision,
          htmlFor,
          ...props
        }) {
          if (!children) {
            return null;
          }
          if (hideLabelFromVision) {
            return /*#__PURE__*/jsxRuntimeExports.jsx(VisuallyHidden, {
              as: "label",
              htmlFor: htmlFor,
              children: children
            });
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx(LabelWrapper, {
            children: /*#__PURE__*/jsxRuntimeExports.jsx(Label$1, {
              htmlFor: htmlFor,
              ...props,
              children: children
            })
          });
        }
        function useDeprecated36pxDefaultSizeProp(props) {
          const {
            __next36pxDefaultSize,
            __next40pxDefaultSize,
            ...otherProps
          } = props;
          return {
            ...otherProps,
            __next40pxDefaultSize: __next40pxDefaultSize !== null && __next40pxDefaultSize !== void 0 ? __next40pxDefaultSize : __next36pxDefaultSize
          };
        }

        /**
         * External dependencies
         */

        function useUniqueId$3(idProp) {
          const instanceId = useInstanceId(InputBase);
          const id = `input-base-control-${instanceId}`;
          return idProp || id;
        }

        // Adapter to map props for the new ui/flex component.
        function getUIFlexProps(labelPosition) {
          const props = {};
          switch (labelPosition) {
            case 'top':
              props.direction = 'column';
              props.expanded = false;
              props.gap = 0;
              break;
            case 'bottom':
              props.direction = 'column-reverse';
              props.expanded = false;
              props.gap = 0;
              break;
            case 'edge':
              props.justify = 'space-between';
              break;
          }
          return props;
        }
        function InputBase(props, ref) {
          const {
            __next40pxDefaultSize,
            __unstableInputWidth,
            children,
            className,
            disabled = false,
            hideLabelFromVision = false,
            labelPosition,
            id: idProp,
            isBorderless = false,
            label,
            prefix,
            size = 'default',
            suffix,
            ...restProps
          } = useDeprecated36pxDefaultSizeProp(useContextSystem(props, 'InputBase'));
          const id = useUniqueId$3(idProp);
          const hideLabel = hideLabelFromVision || !label;
          const prefixSuffixContextValue = reactExports.useMemo(() => {
            return {
              InputControlPrefixWrapper: {
                __next40pxDefaultSize,
                size
              },
              InputControlSuffixWrapper: {
                __next40pxDefaultSize,
                size
              }
            };
          }, [__next40pxDefaultSize, size]);
          return (/*#__PURE__*/
            // @ts-expect-error The `direction` prop from Flex (FlexDirection) conflicts with legacy SVGAttributes `direction` (string) that come from React intrinsic prop definitions.
            jsxRuntimeExports.jsxs(Root$1, {
              ...restProps,
              ...getUIFlexProps(labelPosition),
              className: className,
              gap: 2,
              ref: ref,
              children: [/*#__PURE__*/jsxRuntimeExports.jsx(Label, {
                className: "components-input-control__label",
                hideLabelFromVision: hideLabelFromVision,
                labelPosition: labelPosition,
                htmlFor: id,
                children: label
              }), /*#__PURE__*/jsxRuntimeExports.jsxs(Container, {
                __unstableInputWidth: __unstableInputWidth,
                className: "components-input-control__container",
                disabled: disabled,
                hideLabel: hideLabel,
                labelPosition: labelPosition,
                children: [/*#__PURE__*/jsxRuntimeExports.jsxs(ContextSystemProvider, {
                  value: prefixSuffixContextValue,
                  children: [prefix && /*#__PURE__*/jsxRuntimeExports.jsx(Prefix, {
                    className: "components-input-control__prefix",
                    children: prefix
                  }), children, suffix && /*#__PURE__*/jsxRuntimeExports.jsx(Suffix, {
                    className: "components-input-control__suffix",
                    children: suffix
                  })]
                }), /*#__PURE__*/jsxRuntimeExports.jsx(MemoizedBackdrop, {
                  disabled: disabled,
                  isBorderless: isBorderless
                })]
              })]
            })
          );
        }

        /**
         * `InputBase` is an internal component used to style the standard borders for an input,
         * as well as handle the layout for prefix/suffix elements.
         */
        const InputBase$1 = contextConnect(InputBase, 'InputBase');
        function clamp$1(v, min, max) {
          return Math.max(min, Math.min(v, max));
        }
        const V$2 = {
          toVector(v, fallback) {
            if (v === undefined) v = fallback;
            return Array.isArray(v) ? v : [v, v];
          },
          add(v1, v2) {
            return [v1[0] + v2[0], v1[1] + v2[1]];
          },
          sub(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1]];
          },
          addTo(v1, v2) {
            v1[0] += v2[0];
            v1[1] += v2[1];
          },
          subTo(v1, v2) {
            v1[0] -= v2[0];
            v1[1] -= v2[1];
          }
        };
        function rubberband(distance, dimension, constant) {
          if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
          return distance * dimension * constant / (dimension + constant * distance);
        }
        function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
          if (constant === 0) return clamp$1(position, min, max);
          if (position < min) return -rubberband(min - position, max - min, constant) + min;
          if (position > max) return +rubberband(position - max, max - min, constant) + max;
          return position;
        }
        function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
          const [[X0, X1], [Y0, Y1]] = bounds;
          return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
        }
        function _toPrimitive(input, hint) {
          if (typeof input !== "object" || input === null) return input;
          var prim = input[Symbol.toPrimitive];
          if (prim !== void 0) {
            var res = prim.call(input, hint);
            if (typeof res !== "object") return res;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return (hint === "string" ? String : Number)(input);
        }
        function _toPropertyKey(arg) {
          var key = _toPrimitive(arg, "string");
          return typeof key === "symbol" ? key : String(key);
        }
        function _defineProperty(obj, key, value) {
          key = _toPropertyKey(key);
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function (r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread2(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), true).forEach(function (r2) {
              _defineProperty(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        const EVENT_TYPE_MAP = {
          pointer: {
            start: "down",
            change: "move",
            end: "up"
          },
          mouse: {
            start: "down",
            change: "move",
            end: "up"
          },
          touch: {
            start: "start",
            change: "move",
            end: "end"
          },
          gesture: {
            start: "start",
            change: "change",
            end: "end"
          }
        };
        function capitalize(string) {
          if (!string) return "";
          return string[0].toUpperCase() + string.slice(1);
        }
        const actionsWithoutCaptureSupported = ["enter", "leave"];
        function hasCapture(capture = false, actionKey) {
          return capture && !actionsWithoutCaptureSupported.includes(actionKey);
        }
        function toHandlerProp(device, action = "", capture = false) {
          const deviceProps = EVENT_TYPE_MAP[device];
          const actionKey = deviceProps ? deviceProps[action] || action : action;
          return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
        }
        const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
        function parseProp(prop) {
          let eventKey = prop.substring(2).toLowerCase();
          const passive = !!~eventKey.indexOf("passive");
          if (passive) eventKey = eventKey.replace("passive", "");
          const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
          const capture = !!~eventKey.indexOf(captureKey);
          if (capture) eventKey = eventKey.replace("capture", "");
          return {
            device: eventKey,
            capture,
            passive
          };
        }
        function toDomEventType(device, action = "") {
          const deviceProps = EVENT_TYPE_MAP[device];
          const actionKey = deviceProps ? deviceProps[action] || action : action;
          return device + actionKey;
        }
        function isTouch(event) {
          return "touches" in event;
        }
        function getPointerType(event) {
          if (isTouch(event)) return "touch";
          if ("pointerType" in event) return event.pointerType;
          return "mouse";
        }
        function getCurrentTargetTouchList(event) {
          return Array.from(event.touches).filter(e => {
            var _event$currentTarget, _event$currentTarget$;
            return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
          });
        }
        function getTouchList(event) {
          return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
        }
        function getValueEvent(event) {
          return isTouch(event) ? getTouchList(event)[0] : event;
        }
        function touchIds(event) {
          return getCurrentTargetTouchList(event).map(touch => touch.identifier);
        }
        function pointerId(event) {
          const valueEvent = getValueEvent(event);
          return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
        }
        function pointerValues(event) {
          const valueEvent = getValueEvent(event);
          return [valueEvent.clientX, valueEvent.clientY];
        }
        function getEventDetails(event) {
          const payload = {};
          if ("buttons" in event) payload.buttons = event.buttons;
          if ("shiftKey" in event) {
            const {
              shiftKey,
              altKey,
              metaKey,
              ctrlKey
            } = event;
            Object.assign(payload, {
              shiftKey,
              altKey,
              metaKey,
              ctrlKey
            });
          }
          return payload;
        }
        function call(v, ...args) {
          if (typeof v === "function") {
            return v(...args);
          } else {
            return v;
          }
        }
        function noop$7() {}
        function chain(...fns) {
          if (fns.length === 0) return noop$7;
          if (fns.length === 1) return fns[0];
          return function () {
            let result;
            for (const fn of fns) {
              result = fn.apply(this, arguments) || result;
            }
            return result;
          };
        }
        function assignDefault(value, fallback) {
          return Object.assign({}, fallback, value || {});
        }
        const BEFORE_LAST_KINEMATICS_DELAY = 32;
        class Engine {
          constructor(ctrl, args, key) {
            this.ctrl = ctrl;
            this.args = args;
            this.key = key;
            if (!this.state) {
              this.state = {};
              this.computeValues([0, 0]);
              this.computeInitial();
              if (this.init) this.init();
              this.reset();
            }
          }
          get state() {
            return this.ctrl.state[this.key];
          }
          set state(state) {
            this.ctrl.state[this.key] = state;
          }
          get shared() {
            return this.ctrl.state.shared;
          }
          get eventStore() {
            return this.ctrl.gestureEventStores[this.key];
          }
          get timeoutStore() {
            return this.ctrl.gestureTimeoutStores[this.key];
          }
          get config() {
            return this.ctrl.config[this.key];
          }
          get sharedConfig() {
            return this.ctrl.config.shared;
          }
          get handler() {
            return this.ctrl.handlers[this.key];
          }
          reset() {
            const {
              state,
              shared,
              ingKey,
              args
            } = this;
            shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
            state._step = [false, false];
            state.intentional = false;
            state._movement = [0, 0];
            state._distance = [0, 0];
            state._direction = [0, 0];
            state._delta = [0, 0];
            state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
            state.args = args;
            state.axis = void 0;
            state.memo = void 0;
            state.elapsedTime = state.timeDelta = 0;
            state.direction = [0, 0];
            state.distance = [0, 0];
            state.overflow = [0, 0];
            state._movementBound = [false, false];
            state.velocity = [0, 0];
            state.movement = [0, 0];
            state.delta = [0, 0];
            state.timeStamp = 0;
          }
          start(event) {
            const state = this.state;
            const config = this.config;
            if (!state._active) {
              this.reset();
              this.computeInitial();
              state._active = true;
              state.target = event.target;
              state.currentTarget = event.currentTarget;
              state.lastOffset = config.from ? call(config.from, state) : state.offset;
              state.offset = state.lastOffset;
              state.startTime = state.timeStamp = event.timeStamp;
            }
          }
          computeValues(values) {
            const state = this.state;
            state._values = values;
            state.values = this.config.transform(values);
          }
          computeInitial() {
            const state = this.state;
            state._initial = state._values;
            state.initial = state.values;
          }
          compute(event) {
            const {
              state,
              config,
              shared
            } = this;
            state.args = this.args;
            let dt = 0;
            if (event) {
              state.event = event;
              if (config.preventDefault && event.cancelable) state.event.preventDefault();
              state.type = event.type;
              shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
              shared.locked = !!document.pointerLockElement;
              Object.assign(shared, getEventDetails(event));
              shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
              dt = event.timeStamp - state.timeStamp;
              state.timeStamp = event.timeStamp;
              state.elapsedTime = state.timeStamp - state.startTime;
            }
            if (state._active) {
              const _absoluteDelta = state._delta.map(Math.abs);
              V$2.addTo(state._distance, _absoluteDelta);
            }
            if (this.axisIntent) this.axisIntent(event);
            const [_m0, _m1] = state._movement;
            const [t0, t1] = config.threshold;
            const {
              _step,
              values
            } = state;
            if (config.hasCustomTransform) {
              if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
              if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
            } else {
              if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
              if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
            }
            state.intentional = _step[0] !== false || _step[1] !== false;
            if (!state.intentional) return;
            const movement = [0, 0];
            if (config.hasCustomTransform) {
              const [v0, v1] = values;
              movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
              movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
            } else {
              movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
              movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
            }
            if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
            const previousOffset = state.offset;
            const gestureIsActive = state._active && !state._blocked || state.active;
            if (gestureIsActive) {
              state.first = state._active && !state.active;
              state.last = !state._active && state.active;
              state.active = shared[this.ingKey] = state._active;
              if (event) {
                if (state.first) {
                  if ("bounds" in config) state._bounds = call(config.bounds, state);
                  if (this.setup) this.setup();
                }
                state.movement = movement;
                this.computeOffset();
              }
            }
            const [ox, oy] = state.offset;
            const [[x0, x1], [y0, y1]] = state._bounds;
            state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
            state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
            state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
            const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];
            state.offset = computeRubberband(state._bounds, state.offset, rubberband);
            state.delta = V$2.sub(state.offset, previousOffset);
            this.computeMovement();
            if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
              state.delta = V$2.sub(state.offset, previousOffset);
              const absoluteDelta = state.delta.map(Math.abs);
              V$2.addTo(state.distance, absoluteDelta);
              state.direction = state.delta.map(Math.sign);
              state._direction = state._delta.map(Math.sign);
              if (!state.first && dt > 0) {
                state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
                state.timeDelta = dt;
              }
            }
          }
          emit() {
            const state = this.state;
            const shared = this.shared;
            const config = this.config;
            if (!state._active) this.clean();
            if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
            const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
              [this.aliasKey]: state.values
            }));
            if (memo !== void 0) state.memo = memo;
          }
          clean() {
            this.eventStore.clean();
            this.timeoutStore.clean();
          }
        }
        function selectAxis([dx, dy], threshold) {
          const absDx = Math.abs(dx);
          const absDy = Math.abs(dy);
          if (absDx > absDy && absDx > threshold) {
            return "x";
          }
          if (absDy > absDx && absDy > threshold) {
            return "y";
          }
          return void 0;
        }
        class CoordinatesEngine extends Engine {
          constructor(...args) {
            super(...args);
            _defineProperty(this, "aliasKey", "xy");
          }
          reset() {
            super.reset();
            this.state.axis = void 0;
          }
          init() {
            this.state.offset = [0, 0];
            this.state.lastOffset = [0, 0];
          }
          computeOffset() {
            this.state.offset = V$2.add(this.state.lastOffset, this.state.movement);
          }
          computeMovement() {
            this.state.movement = V$2.sub(this.state.offset, this.state.lastOffset);
          }
          axisIntent(event) {
            const state = this.state;
            const config = this.config;
            if (!state.axis && event) {
              const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
              state.axis = selectAxis(state._movement, threshold);
            }
            state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
          }
          restrictToAxis(v) {
            if (this.config.axis || this.config.lockDirection) {
              switch (this.state.axis) {
                case "x":
                  v[1] = 0;
                  break;
                case "y":
                  v[0] = 0;
                  break;
              }
            }
          }
        }
        const identity = v => v;
        const DEFAULT_RUBBERBAND = 0.15;
        const commonConfigResolver = {
          enabled(value = true) {
            return value;
          },
          eventOptions(value, _k, config) {
            return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
          },
          preventDefault(value = false) {
            return value;
          },
          triggerAllEvents(value = false) {
            return value;
          },
          rubberband(value = 0) {
            switch (value) {
              case true:
                return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
              case false:
                return [0, 0];
              default:
                return V$2.toVector(value);
            }
          },
          from(value) {
            if (typeof value === "function") return value;
            if (value != null) return V$2.toVector(value);
          },
          transform(value, _k, config) {
            const transform = value || config.shared.transform;
            this.hasCustomTransform = !!transform;
            return transform || identity;
          },
          threshold(value) {
            return V$2.toVector(value, 0);
          }
        };
        const DEFAULT_AXIS_THRESHOLD = 0;
        const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
          axis(_v, _k, {
            axis
          }) {
            this.lockDirection = axis === "lock";
            if (!this.lockDirection) return axis;
          },
          axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
            return value;
          },
          bounds(value = {}) {
            if (typeof value === "function") {
              return state => coordinatesConfigResolver.bounds(value(state));
            }
            if ("current" in value) {
              return () => value.current;
            }
            if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
              return value;
            }
            const {
              left = -Infinity,
              right = Infinity,
              top = -Infinity,
              bottom = Infinity
            } = value;
            return [[left, right], [top, bottom]];
          }
        });
        const KEYS_DELTA_MAP = {
          ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
          ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
          ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
          ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
        };
        class DragEngine extends CoordinatesEngine {
          constructor(...args) {
            super(...args);
            _defineProperty(this, "ingKey", "dragging");
          }
          reset() {
            super.reset();
            const state = this.state;
            state._pointerId = void 0;
            state._pointerActive = false;
            state._keyboardActive = false;
            state._preventScroll = false;
            state._delayed = false;
            state.swipe = [0, 0];
            state.tap = false;
            state.canceled = false;
            state.cancel = this.cancel.bind(this);
          }
          setup() {
            const state = this.state;
            if (state._bounds instanceof HTMLElement) {
              const boundRect = state._bounds.getBoundingClientRect();
              const targetRect = state.currentTarget.getBoundingClientRect();
              const _bounds = {
                left: boundRect.left - targetRect.left + state.offset[0],
                right: boundRect.right - targetRect.right + state.offset[0],
                top: boundRect.top - targetRect.top + state.offset[1],
                bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
              };
              state._bounds = coordinatesConfigResolver.bounds(_bounds);
            }
          }
          cancel() {
            const state = this.state;
            if (state.canceled) return;
            state.canceled = true;
            state._active = false;
            setTimeout(() => {
              this.compute();
              this.emit();
            }, 0);
          }
          setActive() {
            this.state._active = this.state._pointerActive || this.state._keyboardActive;
          }
          clean() {
            this.pointerClean();
            this.state._pointerActive = false;
            this.state._keyboardActive = false;
            super.clean();
          }
          pointerDown(event) {
            const config = this.config;
            const state = this.state;
            if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
            const ctrlIds = this.ctrl.setEventIds(event);
            if (config.pointerCapture) {
              event.target.setPointerCapture(event.pointerId);
            }
            if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
            this.start(event);
            this.setupPointer(event);
            state._pointerId = pointerId(event);
            state._pointerActive = true;
            this.computeValues(pointerValues(event));
            this.computeInitial();
            if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
              state._active = false;
              this.setupScrollPrevention(event);
            } else if (config.delay > 0) {
              this.setupDelayTrigger(event);
              if (config.triggerAllEvents) {
                this.compute(event);
                this.emit();
              }
            } else {
              this.startPointerDrag(event);
            }
          }
          startPointerDrag(event) {
            const state = this.state;
            state._active = true;
            state._preventScroll = true;
            state._delayed = false;
            this.compute(event);
            this.emit();
          }
          pointerMove(event) {
            const state = this.state;
            const config = this.config;
            if (!state._pointerActive) return;
            const id = pointerId(event);
            if (state._pointerId !== void 0 && id !== state._pointerId) return;
            const _values = pointerValues(event);
            if (document.pointerLockElement === event.target) {
              state._delta = [event.movementX, event.movementY];
            } else {
              state._delta = V$2.sub(_values, state._values);
              this.computeValues(_values);
            }
            V$2.addTo(state._movement, state._delta);
            this.compute(event);
            if (state._delayed && state.intentional) {
              this.timeoutStore.remove("dragDelay");
              state.active = false;
              this.startPointerDrag(event);
              return;
            }
            if (config.preventScrollAxis && !state._preventScroll) {
              if (state.axis) {
                if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
                  state._active = false;
                  this.clean();
                  return;
                } else {
                  this.timeoutStore.remove("startPointerDrag");
                  this.startPointerDrag(event);
                  return;
                }
              } else {
                return;
              }
            }
            this.emit();
          }
          pointerUp(event) {
            this.ctrl.setEventIds(event);
            try {
              if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
                ;
                event.target.releasePointerCapture(event.pointerId);
              }
            } catch (_unused) {}
            const state = this.state;
            const config = this.config;
            if (!state._active || !state._pointerActive) return;
            const id = pointerId(event);
            if (state._pointerId !== void 0 && id !== state._pointerId) return;
            this.state._pointerActive = false;
            this.setActive();
            this.compute(event);
            const [dx, dy] = state._distance;
            state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
            if (state.tap && config.filterTaps) {
              state._force = true;
            } else {
              const [_dx, _dy] = state._delta;
              const [_mx, _my] = state._movement;
              const [svx, svy] = config.swipe.velocity;
              const [sx, sy] = config.swipe.distance;
              const sdt = config.swipe.duration;
              if (state.elapsedTime < sdt) {
                const _vx = Math.abs(_dx / state.timeDelta);
                const _vy = Math.abs(_dy / state.timeDelta);
                if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
                if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
              }
            }
            this.emit();
          }
          pointerClick(event) {
            if (!this.state.tap && event.detail > 0) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
          setupPointer(event) {
            const config = this.config;
            const device = config.device;
            if (config.pointerLock) {
              event.currentTarget.requestPointerLock();
            }
            if (!config.pointerCapture) {
              this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
              this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
              this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
            }
          }
          pointerClean() {
            if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
              document.exitPointerLock();
            }
          }
          preventScroll(event) {
            if (this.state._preventScroll && event.cancelable) {
              event.preventDefault();
            }
          }
          setupScrollPrevention(event) {
            this.state._preventScroll = false;
            persistEvent(event);
            const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
              passive: false
            });
            this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
            this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
            this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
          }
          setupDelayTrigger(event) {
            this.state._delayed = true;
            this.timeoutStore.add("dragDelay", () => {
              this.state._step = [0, 0];
              this.startPointerDrag(event);
            }, this.config.delay);
          }
          keyDown(event) {
            const deltaFn = KEYS_DELTA_MAP[event.key];
            if (deltaFn) {
              const state = this.state;
              const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
              this.start(event);
              state._delta = deltaFn(this.config.keyboardDisplacement, factor);
              state._keyboardActive = true;
              V$2.addTo(state._movement, state._delta);
              this.compute(event);
              this.emit();
            }
          }
          keyUp(event) {
            if (!(event.key in KEYS_DELTA_MAP)) return;
            this.state._keyboardActive = false;
            this.setActive();
            this.compute(event);
            this.emit();
          }
          bind(bindFunction) {
            const device = this.config.device;
            bindFunction(device, "start", this.pointerDown.bind(this));
            if (this.config.pointerCapture) {
              bindFunction(device, "change", this.pointerMove.bind(this));
              bindFunction(device, "end", this.pointerUp.bind(this));
              bindFunction(device, "cancel", this.pointerUp.bind(this));
              bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
            }
            if (this.config.keys) {
              bindFunction("key", "down", this.keyDown.bind(this));
              bindFunction("key", "up", this.keyUp.bind(this));
            }
            if (this.config.filterTaps) {
              bindFunction("click", "", this.pointerClick.bind(this), {
                capture: true,
                passive: false
              });
            }
          }
        }
        function persistEvent(event) {
          "persist" in event && typeof event.persist === "function" && event.persist();
        }
        const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
        function supportsTouchEvents() {
          return isBrowser && "ontouchstart" in window;
        }
        function isTouchScreen() {
          return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
        }
        function supportsPointerEvents() {
          return isBrowser && "onpointerdown" in window;
        }
        function supportsPointerLock() {
          return isBrowser && "exitPointerLock" in window.document;
        }
        function supportsGestureEvents() {
          try {
            return "constructor" in GestureEvent;
          } catch (e) {
            return false;
          }
        }
        const SUPPORT = {
          isBrowser,
          gesture: supportsGestureEvents(),
          touch: supportsTouchEvents(),
          touchscreen: isTouchScreen(),
          pointer: supportsPointerEvents(),
          pointerLock: supportsPointerLock()
        };
        const DEFAULT_PREVENT_SCROLL_DELAY = 250;
        const DEFAULT_DRAG_DELAY = 180;
        const DEFAULT_SWIPE_VELOCITY = 0.5;
        const DEFAULT_SWIPE_DISTANCE = 50;
        const DEFAULT_SWIPE_DURATION = 250;
        const DEFAULT_KEYBOARD_DISPLACEMENT = 10;
        const DEFAULT_DRAG_AXIS_THRESHOLD = {
          mouse: 0,
          touch: 0,
          pen: 8
        };
        const dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
          device(_v, _k, {
            pointer: {
              touch = false,
              lock = false,
              mouse = false
            } = {}
          }) {
            this.pointerLock = lock && SUPPORT.pointerLock;
            if (SUPPORT.touch && touch) return "touch";
            if (this.pointerLock) return "mouse";
            if (SUPPORT.pointer && !mouse) return "pointer";
            if (SUPPORT.touch) return "touch";
            return "mouse";
          },
          preventScrollAxis(value, _k, {
            preventScroll
          }) {
            this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
            if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
            return value ? value : preventScroll !== void 0 ? "y" : void 0;
          },
          pointerCapture(_v, _k, {
            pointer: {
              capture = true,
              buttons = 1,
              keys = true
            } = {}
          }) {
            this.pointerButtons = buttons;
            this.keys = keys;
            return !this.pointerLock && this.device === "pointer" && capture;
          },
          threshold(value, _k, {
            filterTaps = false,
            tapsThreshold = 3,
            axis = void 0
          }) {
            const threshold = V$2.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
            this.filterTaps = filterTaps;
            this.tapsThreshold = tapsThreshold;
            return threshold;
          },
          swipe({
            velocity = DEFAULT_SWIPE_VELOCITY,
            distance = DEFAULT_SWIPE_DISTANCE,
            duration = DEFAULT_SWIPE_DURATION
          } = {}) {
            return {
              velocity: this.transform(V$2.toVector(velocity)),
              distance: this.transform(V$2.toVector(distance)),
              duration
            };
          },
          delay(value = 0) {
            switch (value) {
              case true:
                return DEFAULT_DRAG_DELAY;
              case false:
                return 0;
              default:
                return value;
            }
          },
          axisThreshold(value) {
            if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
            return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
          },
          keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
            return value;
          }
        });
        _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
          device(_v, _k, {
            shared,
            pointer: {
              touch = false
            } = {}
          }) {
            const sharedConfig = shared;
            if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
            if (SUPPORT.touch && touch) return "touch";
            if (SUPPORT.touchscreen) {
              if (SUPPORT.pointer) return "pointer";
              if (SUPPORT.touch) return "touch";
            }
          },
          bounds(_v, _k, {
            scaleBounds = {},
            angleBounds = {}
          }) {
            const _scaleBounds = state => {
              const D = assignDefault(call(scaleBounds, state), {
                min: -Infinity,
                max: Infinity
              });
              return [D.min, D.max];
            };
            const _angleBounds = state => {
              const A = assignDefault(call(angleBounds, state), {
                min: -Infinity,
                max: Infinity
              });
              return [A.min, A.max];
            };
            if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
            return state => [_scaleBounds(state), _angleBounds(state)];
          },
          threshold(value, _k, config) {
            this.lockDirection = config.axis === "lock";
            const threshold = V$2.toVector(value, this.lockDirection ? [0.1, 3] : 0);
            return threshold;
          },
          modifierKey(value) {
            if (value === void 0) return "ctrlKey";
            return value;
          },
          pinchOnWheel(value = true) {
            return value;
          }
        });
        _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
          mouseOnly: (value = true) => value
        });
        _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
          mouseOnly: (value = true) => value
        });
        const EngineMap = /* @__PURE__ */new Map();
        const ConfigResolverMap = /* @__PURE__ */new Map();
        function registerAction(action) {
          EngineMap.set(action.key, action.engine);
          ConfigResolverMap.set(action.key, action.resolver);
        }
        const dragAction = {
          key: "drag",
          engine: DragEngine,
          resolver: dragConfigResolver
        };
        function _objectWithoutPropertiesLoose(source, excluded) {
          if (source == null) return {};
          var target = {};
          var sourceKeys = Object.keys(source);
          var key, i;
          for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
          }
          return target;
        }
        function _objectWithoutProperties(source, excluded) {
          if (source == null) return {};
          var target = _objectWithoutPropertiesLoose(source, excluded);
          var key, i;
          if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for (i = 0; i < sourceSymbolKeys.length; i++) {
              key = sourceSymbolKeys[i];
              if (excluded.indexOf(key) >= 0) continue;
              if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
              target[key] = source[key];
            }
          }
          return target;
        }
        const sharedConfigResolver = {
          target(value) {
            if (value) {
              return () => "current" in value ? value.current : value;
            }
            return void 0;
          },
          enabled(value = true) {
            return value;
          },
          window(value = SUPPORT.isBrowser ? window : void 0) {
            return value;
          },
          eventOptions({
            passive = true,
            capture = false
          } = {}) {
            return {
              passive,
              capture
            };
          },
          transform(value) {
            return value;
          }
        };
        const _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
        function resolveWith(config = {}, resolvers) {
          const result = {};
          for (const [key, resolver] of Object.entries(resolvers)) {
            switch (typeof resolver) {
              case "function":
                {
                  result[key] = resolver.call(result, config[key], key, config);
                }
                break;
              case "object":
                result[key] = resolveWith(config[key], resolver);
                break;
              case "boolean":
                if (resolver) result[key] = config[key];
                break;
            }
          }
          return result;
        }
        function parse$1(newConfig, gestureKey, _config = {}) {
          const _ref = newConfig,
            {
              target,
              eventOptions,
              window: window2,
              enabled,
              transform
            } = _ref,
            rest = _objectWithoutProperties(_ref, _excluded);
          _config.shared = resolveWith({
            target,
            eventOptions,
            window: window2,
            enabled,
            transform
          }, sharedConfigResolver);
          if (gestureKey) {
            const resolver = ConfigResolverMap.get(gestureKey);
            _config[gestureKey] = resolveWith(_objectSpread2({
              shared: _config.shared
            }, rest), resolver);
          } else {
            for (const key in rest) {
              const resolver = ConfigResolverMap.get(key);
              if (resolver) {
                _config[key] = resolveWith(_objectSpread2({
                  shared: _config.shared
                }, rest[key]), resolver);
              }
            }
          }
          return _config;
        }
        class EventStore {
          constructor(ctrl, gestureKey) {
            _defineProperty(this, "_listeners", /* @__PURE__ */new Set());
            this._ctrl = ctrl;
            this._gestureKey = gestureKey;
          }
          add(element, device, action, handler, options) {
            const listeners = this._listeners;
            const type = toDomEventType(device, action);
            const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
            const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
            element.addEventListener(type, handler, eventOptions);
            const remove = () => {
              element.removeEventListener(type, handler, eventOptions);
              listeners.delete(remove);
            };
            listeners.add(remove);
            return remove;
          }
          clean() {
            this._listeners.forEach(remove => remove());
            this._listeners.clear();
          }
        }
        class TimeoutStore {
          constructor() {
            _defineProperty(this, "_timeouts", /* @__PURE__ */new Map());
          }
          add(key, callback, ms = 140, ...args) {
            this.remove(key);
            this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
          }
          remove(key) {
            const timeout = this._timeouts.get(key);
            if (timeout) window.clearTimeout(timeout);
          }
          clean() {
            this._timeouts.forEach(timeout => void window.clearTimeout(timeout));
            this._timeouts.clear();
          }
        }
        class Controller {
          constructor(handlers) {
            _defineProperty(this, "gestures", /* @__PURE__ */new Set());
            _defineProperty(this, "_targetEventStore", new EventStore(this));
            _defineProperty(this, "gestureEventStores", {});
            _defineProperty(this, "gestureTimeoutStores", {});
            _defineProperty(this, "handlers", {});
            _defineProperty(this, "config", {});
            _defineProperty(this, "pointerIds", /* @__PURE__ */new Set());
            _defineProperty(this, "touchIds", /* @__PURE__ */new Set());
            _defineProperty(this, "state", {
              shared: {
                shiftKey: false,
                metaKey: false,
                ctrlKey: false,
                altKey: false
              }
            });
            resolveGestures(this, handlers);
          }
          setEventIds(event) {
            if (isTouch(event)) {
              this.touchIds = new Set(touchIds(event));
              return this.touchIds;
            } else if ("pointerId" in event) {
              if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
              return this.pointerIds;
            }
          }
          applyHandlers(handlers, nativeHandlers) {
            this.handlers = handlers;
            this.nativeHandlers = nativeHandlers;
          }
          applyConfig(config, gestureKey) {
            this.config = parse$1(config, gestureKey, this.config);
          }
          clean() {
            this._targetEventStore.clean();
            for (const key of this.gestures) {
              this.gestureEventStores[key].clean();
              this.gestureTimeoutStores[key].clean();
            }
          }
          effect() {
            if (this.config.shared.target) this.bind();
            return () => this._targetEventStore.clean();
          }
          bind(...args) {
            const sharedConfig = this.config.shared;
            const props = {};
            let target;
            if (sharedConfig.target) {
              target = sharedConfig.target();
              if (!target) return;
            }
            if (sharedConfig.enabled) {
              for (const gestureKey of this.gestures) {
                const gestureConfig = this.config[gestureKey];
                const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
                if (gestureConfig.enabled) {
                  const Engine = EngineMap.get(gestureKey);
                  new Engine(this, args, gestureKey).bind(bindFunction);
                }
              }
              const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
              for (const eventKey in this.nativeHandlers) {
                nativeBindFunction(eventKey, "", event => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
                  event,
                  args
                })), void 0, true);
              }
            }
            for (const handlerProp in props) {
              props[handlerProp] = chain(...props[handlerProp]);
            }
            if (!target) return props;
            for (const handlerProp in props) {
              const {
                device,
                capture,
                passive
              } = parseProp(handlerProp);
              this._targetEventStore.add(target, device, "", props[handlerProp], {
                capture,
                passive
              });
            }
          }
        }
        function setupGesture(ctrl, gestureKey) {
          ctrl.gestures.add(gestureKey);
          ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
          ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
        }
        function resolveGestures(ctrl, internalHandlers) {
          if (internalHandlers.drag) setupGesture(ctrl, "drag");
          if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
          if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
          if (internalHandlers.move) setupGesture(ctrl, "move");
          if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
          if (internalHandlers.hover) setupGesture(ctrl, "hover");
        }
        const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
          var _options$capture, _options$passive;
          const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
          const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
          let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
          if (withPassiveOption && passive) handlerProp += "Passive";
          props[handlerProp] = props[handlerProp] || [];
          props[handlerProp].push(handler);
        };
        function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
          const ctrl = React$1.useMemo(() => new Controller(handlers), []);
          ctrl.applyHandlers(handlers, nativeHandlers);
          ctrl.applyConfig(config, gestureKey);
          React$1.useEffect(ctrl.effect.bind(ctrl));
          React$1.useEffect(() => {
            return ctrl.clean.bind(ctrl);
          }, []);
          if (config.target === undefined) {
            return ctrl.bind.bind(ctrl);
          }
          return undefined;
        }
        function useDrag(handler, config) {
          registerAction(dragAction);
          return useRecognizers({
            drag: handler
          }, config || {}, 'drag');
        }

        /**
         * External dependencies
         */

        /**
         * Internal dependencies
         */

        /**
         * Gets a CSS cursor value based on a drag direction.
         *
         * @param dragDirection The drag direction.
         * @return  The CSS cursor value.
         */
        function getDragCursor(dragDirection) {
          let dragCursor = 'ns-resize';
          switch (dragDirection) {
            case 'n':
            case 's':
              dragCursor = 'ns-resize';
              break;
            case 'e':
            case 'w':
              dragCursor = 'ew-resize';
              break;
          }
          return dragCursor;
        }

        /**
         * Custom hook that renders a drag cursor when dragging.
         *
         * @param {boolean} isDragging    The dragging state.
         * @param {string}  dragDirection The drag direction.
         *
         * @return {string} The CSS cursor value.
         */
        function useDragCursor(isDragging, dragDirection) {
          const dragCursor = getDragCursor(dragDirection);
          reactExports.useEffect(() => {
            if (isDragging) {
              document.documentElement.style.cursor = dragCursor;
            } else {
              // @ts-expect-error
              document.documentElement.style.cursor = null;
            }
          }, [isDragging, dragCursor]);
          return dragCursor;
        }
        function useDraft(props) {
          const previousValueRef = reactExports.useRef(props.value);
          const [draft, setDraft] = reactExports.useState({});
          const value = draft.value !== undefined ? draft.value : props.value;

          // Determines when to discard the draft value to restore controlled status.
          // To do so, it tracks the previous value and marks the draft value as stale
          // after each render.
          reactExports.useLayoutEffect(() => {
            const {
              current: previousValue
            } = previousValueRef;
            previousValueRef.current = props.value;
            if (draft.value !== undefined && !draft.isStale) {
              setDraft({
                ...draft,
                isStale: true
              });
            } else if (draft.isStale && props.value !== previousValue) {
              setDraft({});
            }
          }, [props.value, draft]);
          const onChange = (nextValue, extra) => {
            // Mutates the draft value to avoid an extra effect run.
            setDraft(current => Object.assign(current, {
              value: nextValue,
              isStale: false
            }));
            props.onChange(nextValue, extra);
          };
          const onBlur = event => {
            setDraft({});
            props.onBlur?.(event);
          };
          return {
            value,
            onBlur,
            onChange
          };
        }

        /**
         * External dependencies
         */

        /**
         * Internal dependencies
         */

        const initialStateReducer = state => state;
        const initialInputControlState = {
          error: null,
          initialValue: '',
          isDirty: false,
          isDragEnabled: false,
          isDragging: false,
          isPressEnterToChange: false,
          value: ''
        };

        /**
         * External dependencies
         */

        /**
         * Internal dependencies
         */

        const CHANGE = 'CHANGE';
        const COMMIT = 'COMMIT';
        const CONTROL = 'CONTROL';
        const DRAG_END = 'DRAG_END';
        const DRAG_START = 'DRAG_START';
        const DRAG = 'DRAG';
        const INVALIDATE = 'INVALIDATE';
        const PRESS_DOWN = 'PRESS_DOWN';
        const PRESS_ENTER = 'PRESS_ENTER';
        const PRESS_UP = 'PRESS_UP';
        const RESET = 'RESET';

        /**
         * External dependencies
         */

        /**
         * Prepares initialState for the reducer.
         *
         * @param initialState The initial state.
         * @return Prepared initialState for the reducer
         */
        function mergeInitialState(initialState = initialInputControlState) {
          const {
            value
          } = initialState;
          return {
            ...initialInputControlState,
            ...initialState,
            initialValue: value
          };
        }

        /**
         * Creates the base reducer which may be coupled to a specializing reducer.
         * As its final step, for all actions other than CONTROL, the base reducer
         * passes the state and action on through the specializing reducer. The
         * exception for CONTROL actions is because they represent controlled updates
         * from props and no case has yet presented for their specialization.
         *
         * @param composedStateReducers A reducer to specialize state changes.
         * @return The reducer.
         */
        function inputControlStateReducer(composedStateReducers) {
          return (state, action) => {
            const nextState = {
              ...state
            };
            switch (action.type) {
              /*
               * Controlled updates
               */
              case CONTROL:
                nextState.value = action.payload.value;
                nextState.isDirty = false;
                nextState._event = undefined;
                // Returns immediately to avoid invoking additional reducers.
                return nextState;

              /**
               * Keyboard events
               */
              case PRESS_UP:
                nextState.isDirty = false;
                break;
              case PRESS_DOWN:
                nextState.isDirty = false;
                break;

              /**
               * Drag events
               */
              case DRAG_START:
                nextState.isDragging = true;
                break;
              case DRAG_END:
                nextState.isDragging = false;
                break;

              /**
               * Input events
               */
              case CHANGE:
                nextState.error = null;
                nextState.value = action.payload.value;
                if (state.isPressEnterToChange) {
                  nextState.isDirty = true;
                }
                break;
              case COMMIT:
                nextState.value = action.payload.value;
                nextState.isDirty = false;
                break;
              case RESET:
                nextState.error = null;
                nextState.isDirty = false;
                nextState.value = action.payload.value || state.initialValue;
                break;

              /**
               * Validation
               */
              case INVALIDATE:
                nextState.error = action.payload.error;
                break;
            }
            nextState._event = action.payload.event;

            /**
             * Send the nextState + action to the composedReducers via
             * this "bridge" mechanism. This allows external stateReducers
             * to hook into actions, and modify state if needed.
             */
            return composedStateReducers(nextState, action);
          };
        }

        /**
         * A custom hook that connects and external stateReducer with an internal
         * reducer. This hook manages the internal state of InputControl.
         * However, by connecting an external stateReducer function, other
         * components can react to actions as well as modify state before it is
         * applied.
         *
         * This technique uses the "stateReducer" design pattern:
         * https://kentcdodds.com/blog/the-state-reducer-pattern/
         *
         * @param stateReducer    An external state reducer.
         * @param initialState    The initial state for the reducer.
         * @param onChangeHandler A handler for the onChange event.
         * @return State, dispatch, and a collection of actions.
         */
        function useInputControlStateReducer(stateReducer = initialStateReducer, initialState = initialInputControlState, onChangeHandler) {
          const [state, dispatch] = reactExports.useReducer(inputControlStateReducer(stateReducer), mergeInitialState(initialState));
          const createChangeEvent = type => (nextValue, event) => {
            dispatch({
              type,
              payload: {
                value: nextValue,
                event
              }
            });
          };
          const createKeyEvent = type => event => {
            dispatch({
              type,
              payload: {
                event
              }
            });
          };
          const createDragEvent = type => payload => {
            dispatch({
              type,
              payload
            });
          };

          /**
           * Actions for the reducer
           */
          const change = createChangeEvent(CHANGE);
          const invalidate = (error, event) => dispatch({
            type: INVALIDATE,
            payload: {
              error,
              event
            }
          });
          const reset = createChangeEvent(RESET);
          const commit = createChangeEvent(COMMIT);
          const dragStart = createDragEvent(DRAG_START);
          const drag = createDragEvent(DRAG);
          const dragEnd = createDragEvent(DRAG_END);
          const pressUp = createKeyEvent(PRESS_UP);
          const pressDown = createKeyEvent(PRESS_DOWN);
          const pressEnter = createKeyEvent(PRESS_ENTER);
          const currentStateRef = reactExports.useRef(state);
          const refPropsRef = reactExports.useRef({
            value: initialState.value,
            onChangeHandler
          });

          // Freshens refs to props and state so that subsequent effects have access
          // to their latest values without their changes causing effect runs.
          reactExports.useLayoutEffect(() => {
            currentStateRef.current = state;
            refPropsRef.current = {
              value: initialState.value,
              onChangeHandler
            };
          });

          // Propagates the latest state through onChange.
          reactExports.useLayoutEffect(() => {
            if (currentStateRef.current._event !== undefined && state.value !== refPropsRef.current.value && !state.isDirty) {
              var _state$value;
              refPropsRef.current.onChangeHandler((_state$value = state.value) !== null && _state$value !== void 0 ? _state$value : '', {
                event: currentStateRef.current._event
              });
            }
          }, [state.value, state.isDirty]);

          // Updates the state from props.
          reactExports.useLayoutEffect(() => {
            if (initialState.value !== currentStateRef.current.value && !currentStateRef.current.isDirty) {
              var _initialState$value;
              dispatch({
                type: CONTROL,
                payload: {
                  value: (_initialState$value = initialState.value) !== null && _initialState$value !== void 0 ? _initialState$value : ''
                }
              });
            }
          }, [initialState.value]);
          return {
            change,
            commit,
            dispatch,
            drag,
            dragEnd,
            dragStart,
            invalidate,
            pressDown,
            pressEnter,
            pressUp,
            reset,
            state
          };
        }

        /**
         * A higher-order function that wraps a keydown event handler to ensure it is not an IME event.
         *
         * In CJK languages, an IME (Input Method Editor) is used to input complex characters.
         * During an IME composition, keydown events (e.g. Enter or Escape) can be fired
         * which are intended to control the IME and not the application.
         * These events should be ignored by any application logic.
         *
         * @param keydownHandler The keydown event handler to execute after ensuring it was not an IME event.
         *
         * @return A wrapped version of the given event handler that ignores IME events.
         */
        function withIgnoreIMEEvents(keydownHandler) {
          return event => {
            const {
              isComposing
            } = 'nativeEvent' in event ? event.nativeEvent : event;
            if (isComposing ||
            // Workaround for Mac Safari where the final Enter/Backspace of an IME composition
            // is `isComposing=false`, even though it's technically still part of the composition.
            // These can only be detected by keyCode.
            event.keyCode === 229) {
              return;
            }
            keydownHandler(event);
          };
        }

        /**
         * External dependencies
         */
        const noop$6 = () => {};
        function InputField({
          disabled = false,
          dragDirection = 'n',
          dragThreshold = 10,
          id,
          isDragEnabled = false,
          isPressEnterToChange = false,
          onBlur = noop$6,
          onChange = noop$6,
          onDrag = noop$6,
          onDragEnd = noop$6,
          onDragStart = noop$6,
          onKeyDown = noop$6,
          onValidate = noop$6,
          size = 'default',
          stateReducer = state => state,
          value: valueProp,
          type,
          ...props
        }, ref) {
          const {
            // State.
            state,
            // Actions.
            change,
            commit,
            drag,
            dragEnd,
            dragStart,
            invalidate,
            pressDown,
            pressEnter,
            pressUp,
            reset
          } = useInputControlStateReducer(stateReducer, {
            isDragEnabled,
            value: valueProp,
            isPressEnterToChange
          }, onChange);
          const {
            value,
            isDragging,
            isDirty
          } = state;
          const wasDirtyOnBlur = reactExports.useRef(false);
          const dragCursor = useDragCursor(isDragging, dragDirection);
          const handleOnBlur = event => {
            onBlur(event);

            /**
             * If isPressEnterToChange is set, this commits the value to
             * the onChange callback.
             */
            if (isDirty || !event.target.validity.valid) {
              wasDirtyOnBlur.current = true;
              handleOnCommit(event);
            }
          };
          const handleOnChange = event => {
            const nextValue = event.target.value;
            change(nextValue, event);
          };
          const handleOnCommit = event => {
            const nextValue = event.currentTarget.value;
            try {
              onValidate(nextValue);
              commit(nextValue, event);
            } catch (err) {
              invalidate(err, event);
            }
          };
          const handleOnKeyDown = event => {
            const {
              key
            } = event;
            onKeyDown(event);
            switch (key) {
              case 'ArrowUp':
                pressUp(event);
                break;
              case 'ArrowDown':
                pressDown(event);
                break;
              case 'Enter':
                pressEnter(event);
                if (isPressEnterToChange) {
                  event.preventDefault();
                  handleOnCommit(event);
                }
                break;
              case 'Escape':
                if (isPressEnterToChange && isDirty) {
                  event.preventDefault();
                  reset(valueProp, event);
                }
                break;
            }
          };
          const dragGestureProps = useDrag(dragProps => {
            const {
              distance,
              dragging,
              event,
              target
            } = dragProps;

            // The `target` prop always references the `input` element while, by
            // default, the `dragProps.event.target` property would reference the real
            // event target (i.e. any DOM element that the pointer is hovering while
            // dragging). Ensuring that the `target` is always the `input` element
            // allows consumers of `InputControl` (or any higher-level control) to
            // check the input's validity by accessing `event.target.validity.valid`.
            dragProps.event = {
              ...dragProps.event,
              target
            };
            if (!distance) {
              return;
            }
            event.stopPropagation();

            /**
             * Quick return if no longer dragging.
             * This prevents unnecessary value calculations.
             */
            if (!dragging) {
              onDragEnd(dragProps);
              dragEnd(dragProps);
              return;
            }
            onDrag(dragProps);
            drag(dragProps);
            if (!isDragging) {
              onDragStart(dragProps);
              dragStart(dragProps);
            }
          }, {
            axis: dragDirection === 'e' || dragDirection === 'w' ? 'x' : 'y',
            threshold: dragThreshold,
            enabled: isDragEnabled,
            pointer: {
              capture: false
            }
          });
          const dragProps = isDragEnabled ? dragGestureProps() : {};
          /*
           * Works around the odd UA (e.g. Firefox) that does not focus inputs of
           * type=number when their spinner arrows are pressed.
           */
          let handleOnMouseDown;
          if (type === 'number') {
            handleOnMouseDown = event => {
              props.onMouseDown?.(event);
              if (event.currentTarget !== event.currentTarget.ownerDocument.activeElement) {
                event.currentTarget.focus();
              }
            };
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx(Input$1, {
            ...props,
            ...dragProps,
            className: "components-input-control__input",
            disabled: disabled,
            dragCursor: dragCursor,
            isDragging: isDragging,
            id: id,
            onBlur: handleOnBlur,
            onChange: handleOnChange,
            onKeyDown: withIgnoreIMEEvents(handleOnKeyDown),
            onMouseDown: handleOnMouseDown,
            ref: ref,
            inputSize: size
            // Fallback to `''` to avoid "uncontrolled to controlled" warning.
            // See https://github.com/WordPress/gutenberg/pull/47250 for details.
            ,

            value: value !== null && value !== void 0 ? value : '',
            type: type
          });
        }
        const ForwardedComponent$1 = reactExports.forwardRef(InputField);
        const Wrapper$2 = /* @__PURE__ */createStyled("div", {
          target: "ej5x27r4"
        })("font-family:", font("default.fontFamily"), ";font-size:", font("default.fontSize"), ";", boxSizingReset, ";" + "");
        const deprecatedMarginField = ({
          __nextHasNoMarginBottom = false
        }) => {
          return !__nextHasNoMarginBottom && /* @__PURE__ */css("margin-bottom:", space(2), ";" + "", "");
        };
        const StyledField = /* @__PURE__ */createStyled("div", {
          target: "ej5x27r3"
        })(deprecatedMarginField, " .components-panel__row &{margin-bottom:inherit;}" + "");
        const labelStyles = /* @__PURE__ */css(baseLabelTypography, ";display:block;margin-bottom:", space(2), ";padding:0;" + "", "");
        const StyledLabel = /* @__PURE__ */createStyled("label", {
          target: "ej5x27r2"
        })(labelStyles, ";" + "");
        var _ref$4 = {
          name: "11yad0w",
          styles: "margin-bottom:revert"
        };
        const deprecatedMarginHelp = ({
          __nextHasNoMarginBottom = false
        }) => {
          return !__nextHasNoMarginBottom && _ref$4;
        };
        const StyledHelp = /* @__PURE__ */createStyled("p", {
          target: "ej5x27r1"
        })("margin-top:", space(2), ";margin-bottom:0;font-size:", font("helpText.fontSize"), ";font-style:normal;color:", COLORS$1.gray[700], ";", deprecatedMarginHelp, ";" + "");
        const StyledVisualLabel = /* @__PURE__ */createStyled("span", {
          target: "ej5x27r0"
        })(labelStyles, ";" + "");

        /**
         * External dependencies
         */
        const UnconnectedBaseControl = props => {
          const {
            __nextHasNoMarginBottom = false,
            __associatedWPComponentName = 'BaseControl',
            id,
            label,
            hideLabelFromVision = false,
            help,
            className,
            children
          } = useContextSystem(props, 'BaseControl');
          if (!__nextHasNoMarginBottom) {
            deprecated(`Bottom margin styles for wp.components.${__associatedWPComponentName}`, {
              since: '6.7',
              version: '7.0',
              hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version.'
            });
          }
          return /*#__PURE__*/jsxRuntimeExports.jsxs(Wrapper$2, {
            className: className,
            children: [/*#__PURE__*/jsxRuntimeExports.jsxs(StyledField, {
              className: "components-base-control__field"
              // TODO: Official deprecation for this should start after all internal usages have been migrated
              ,

              __nextHasNoMarginBottom: __nextHasNoMarginBottom,
              children: [label && id && (hideLabelFromVision ? /*#__PURE__*/jsxRuntimeExports.jsx(VisuallyHidden, {
                as: "label",
                htmlFor: id,
                children: label
              }) : /*#__PURE__*/jsxRuntimeExports.jsx(StyledLabel, {
                className: "components-base-control__label",
                htmlFor: id,
                children: label
              })), label && !id && (hideLabelFromVision ? /*#__PURE__*/jsxRuntimeExports.jsx(VisuallyHidden, {
                as: "label",
                children: label
              }) : /*#__PURE__*/jsxRuntimeExports.jsx(VisualLabel, {
                children: label
              })), children]
            }), !!help && /*#__PURE__*/jsxRuntimeExports.jsx(StyledHelp, {
              id: id ? id + '__help' : undefined,
              className: "components-base-control__help",
              __nextHasNoMarginBottom: __nextHasNoMarginBottom,
              children: help
            })]
          });
        };
        const UnforwardedVisualLabel = (props, ref) => {
          const {
            className,
            children,
            ...restProps
          } = props;
          return /*#__PURE__*/jsxRuntimeExports.jsx(StyledVisualLabel, {
            ref: ref,
            ...restProps,
            className: clsx('components-base-control__label', className),
            children: children
          });
        };
        const VisualLabel = reactExports.forwardRef(UnforwardedVisualLabel);

        /**
         * `BaseControl` is a component used to generate labels and help text for components handling user inputs.
         *
         * ```jsx
         * import { BaseControl, useBaseControlProps } from '@wordpress/components';
         *
         * // Render a `BaseControl` for a textarea input
         * const MyCustomTextareaControl = ({ children, ...baseProps }) => (
         * 	// `useBaseControlProps` is a convenience hook to get the props for the `BaseControl`
         * 	// and the inner control itself. Namely, it takes care of generating a unique `id`,
         * 	// properly associating it with the `label` and `help` elements.
         * 	const { baseControlProps, controlProps } = useBaseControlProps( baseProps );
         *
         * 	return (
         * 		<BaseControl { ...baseControlProps } __nextHasNoMarginBottom>
         * 			<textarea { ...controlProps }>
         * 			  { children }
         * 			</textarea>
         * 		</BaseControl>
         * 	);
         * );
         * ```
         */
        const BaseControl = Object.assign(contextConnectWithoutRef(UnconnectedBaseControl, 'BaseControl'), {
          /**
           * `BaseControl.VisualLabel` is used to render a purely visual label inside a `BaseControl` component.
           *
           * It should only be used in cases where the children being rendered inside `BaseControl` are already accessibly labeled,
           * e.g., a button, but we want an additional visual label for that section equivalent to the labels `BaseControl` would
           * otherwise use if the `label` prop was passed.
           *
           * ```jsx
           * import { BaseControl } from '@wordpress/components';
           *
           * const MyBaseControl = () => (
           * 	<BaseControl
           * 		__nextHasNoMarginBottom
           * 		help="This button is already accessibly labeled."
           * 	>
           * 		<BaseControl.VisualLabel>Author</BaseControl.VisualLabel>
           * 		<Button>Select an author</Button>
           * 	</BaseControl>
           * );
           * ```
           */
          VisualLabel
        });

        /**
         * External dependencies
         */
        const noop$5 = () => {};
        function useUniqueId$2(idProp) {
          const instanceId = useInstanceId(InputControl);
          const id = `inspector-input-control-${instanceId}`;
          return idProp || id;
        }
        function UnforwardedInputControl(props, ref) {
          const {
            __next40pxDefaultSize,
            __unstableStateReducer: stateReducer = state => state,
            __unstableInputWidth,
            className,
            disabled = false,
            help,
            hideLabelFromVision = false,
            id: idProp,
            isPressEnterToChange = false,
            label,
            labelPosition = 'top',
            onChange = noop$5,
            onValidate = noop$5,
            onKeyDown = noop$5,
            prefix,
            size = 'default',
            style,
            suffix,
            value,
            ...restProps
          } = useDeprecated36pxDefaultSizeProp(props);
          const id = useUniqueId$2(idProp);
          const classes = clsx('components-input-control', className);
          const draftHookProps = useDraft({
            value,
            onBlur: restProps.onBlur,
            onChange
          });
          const helpProp = !!help ? {
            'aria-describedby': `${id}__help`
          } : {};
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            className: classes,
            help: help,
            id: id,
            __nextHasNoMarginBottom: true,
            children: /*#__PURE__*/jsxRuntimeExports.jsx(InputBase$1, {
              __next40pxDefaultSize: __next40pxDefaultSize,
              __unstableInputWidth: __unstableInputWidth,
              disabled: disabled,
              gap: 3,
              hideLabelFromVision: hideLabelFromVision,
              id: id,
              justify: "left",
              label: label,
              labelPosition: labelPosition,
              prefix: prefix,
              size: size,
              style: style,
              suffix: suffix,
              children: /*#__PURE__*/jsxRuntimeExports.jsx(ForwardedComponent$1, {
                ...restProps,
                ...helpProp,
                __next40pxDefaultSize: __next40pxDefaultSize,
                className: "components-input-control__input",
                disabled: disabled,
                id: id,
                isPressEnterToChange: isPressEnterToChange,
                onKeyDown: onKeyDown,
                onValidate: onValidate,
                paddingInlineStart: prefix ? space(1) : undefined,
                paddingInlineEnd: suffix ? space(1) : undefined,
                ref: ref,
                size: size,
                stateReducer: stateReducer,
                ...draftHookProps
              })
            })
          });
        }

        /**
         * InputControl components let users enter and edit text. This is an experimental component
         * intended to (in time) merge with or replace `TextControl`.
         *
         * ```jsx
         * import { __experimentalInputControl as InputControl } from '@wordpress/components';
         * import { useState } from 'react';
         *
         * const Example = () => {
         *   const [ value, setValue ] = useState( '' );
         *
         *   return (
         *  	<InputControl
         *  		value={ value }
         *  		onChange={ ( nextValue ) => setValue( nextValue ?? '' ) }
         *  	/>
         *   );
         * };
         * ```
         */
        const InputControl = reactExports.forwardRef(UnforwardedInputControl);

        /**
         * @typedef OwnProps
         *
         * @property {import('./types').IconKey} icon        Icon name
         * @property {string}                    [className] Class name
         * @property {number}                    [size]      Size of the icon
         */

        /**
         * Internal dependencies
         */

        function Dashicon({
          icon,
          className,
          size = 20,
          style = {},
          ...extraProps
        }) {
          const iconClass = ['dashicon', 'dashicons', 'dashicons-' + icon, className].filter(Boolean).join(' ');

          // For retro-compatibility reasons (for example if people are overriding icon size with CSS), we add inline styles just if the size is different to the default
          const sizeStyles =
          // using `!=` to catch both 20 and "20"
          // eslint-disable-next-line eqeqeq
          20 != size ? {
            fontSize: `${size}px`,
            width: `${size}px`,
            height: `${size}px`
          } : {};
          const styles = {
            ...sizeStyles,
            ...style
          };
          return /*#__PURE__*/jsxRuntimeExports.jsx("span", {
            className: iconClass,
            style: styles,
            ...extraProps
          });
        }

        /**
         * External dependencies
         */

        /**
         * Renders a raw icon without any initial styling or wrappers.
         *
         * ```jsx
         * import { wordpress } from '@wordpress/icons';
         *
         * <Icon icon={ wordpress } />
         * ```
         */
        function Icon({
          icon = null,
          size = 'string' === typeof icon ? 20 : 24,
          ...additionalProps
        }) {
          if ('string' === typeof icon) {
            return /*#__PURE__*/jsxRuntimeExports.jsx(Dashicon, {
              icon: icon,
              size: size,
              ...additionalProps
            });
          }
          if (reactExports.isValidElement(icon) && Dashicon === icon.type) {
            return reactExports.cloneElement(icon, {
              ...additionalProps
            });
          }
          if ('function' === typeof icon) {
            return reactExports.createElement(icon, {
              size,
              ...additionalProps
            });
          }
          if (icon && (icon.type === 'svg' || icon.type === SVG)) {
            const appliedProps = {
              ...icon.props,
              width: size,
              height: size,
              ...additionalProps
            };
            return /*#__PURE__*/jsxRuntimeExports.jsx(SVG, {
              ...appliedProps
            });
          }
          if (reactExports.isValidElement(icon)) {
            return reactExports.cloneElement(icon, {
              // @ts-ignore Just forwarding the size prop along
              size,
              ...additionalProps
            });
          }
          return icon;
        }

        /**
         * External dependencies
         */
        const disabledEventsOnDisabledButton = ['onMouseDown', 'onClick'];
        function useDeprecatedProps$2({
          __experimentalIsFocusable,
          isDefault,
          isPrimary,
          isSecondary,
          isTertiary,
          isLink,
          isPressed,
          isSmall,
          size,
          variant,
          describedBy,
          ...otherProps
        }) {
          let computedSize = size;
          let computedVariant = variant;
          const newProps = {
            accessibleWhenDisabled: __experimentalIsFocusable,
            // @todo Mark `isPressed` as deprecated
            'aria-pressed': isPressed,
            description: describedBy
          };
          if (isSmall) {
            var _computedSize;
            (_computedSize = computedSize) !== null && _computedSize !== void 0 ? _computedSize : computedSize = 'small';
          }
          if (isPrimary) {
            var _computedVariant;
            (_computedVariant = computedVariant) !== null && _computedVariant !== void 0 ? _computedVariant : computedVariant = 'primary';
          }
          if (isTertiary) {
            var _computedVariant2;
            (_computedVariant2 = computedVariant) !== null && _computedVariant2 !== void 0 ? _computedVariant2 : computedVariant = 'tertiary';
          }
          if (isSecondary) {
            var _computedVariant3;
            (_computedVariant3 = computedVariant) !== null && _computedVariant3 !== void 0 ? _computedVariant3 : computedVariant = 'secondary';
          }
          if (isDefault) {
            var _computedVariant4;
            deprecated('wp.components.Button `isDefault` prop', {
              since: '5.4',
              alternative: 'variant="secondary"'
            });
            (_computedVariant4 = computedVariant) !== null && _computedVariant4 !== void 0 ? _computedVariant4 : computedVariant = 'secondary';
          }
          if (isLink) {
            var _computedVariant5;
            (_computedVariant5 = computedVariant) !== null && _computedVariant5 !== void 0 ? _computedVariant5 : computedVariant = 'link';
          }
          return {
            ...newProps,
            ...otherProps,
            size: computedSize,
            variant: computedVariant
          };
        }
        function UnforwardedButton(props, ref) {
          const {
            __next40pxDefaultSize,
            accessibleWhenDisabled,
            isBusy,
            isDestructive,
            className,
            disabled,
            icon,
            iconPosition = 'left',
            iconSize,
            showTooltip,
            tooltipPosition,
            shortcut,
            label,
            children,
            size = 'default',
            text,
            variant,
            description,
            ...buttonOrAnchorProps
          } = useDeprecatedProps$2(props);
          const {
            href,
            target,
            'aria-checked': ariaChecked,
            'aria-pressed': ariaPressed,
            'aria-selected': ariaSelected,
            ...additionalProps
          } = 'href' in buttonOrAnchorProps ? buttonOrAnchorProps : {
            href: undefined,
            target: undefined,
            ...buttonOrAnchorProps
          };
          const instanceId = useInstanceId(Button, 'components-button__description');
          const hasChildren = 'string' === typeof children && !!children || Array.isArray(children) && children?.[0] && children[0] !== null &&
          // Tooltip should not considered as a child
          children?.[0]?.props?.className !== 'components-tooltip';
          const truthyAriaPressedValues = [true, 'true', 'mixed'];
          const classes = clsx('components-button', className, {
            'is-next-40px-default-size': __next40pxDefaultSize,
            'is-secondary': variant === 'secondary',
            'is-primary': variant === 'primary',
            'is-small': size === 'small',
            'is-compact': size === 'compact',
            'is-tertiary': variant === 'tertiary',
            'is-pressed': truthyAriaPressedValues.includes(ariaPressed),
            'is-pressed-mixed': ariaPressed === 'mixed',
            'is-busy': isBusy,
            'is-link': variant === 'link',
            'is-destructive': isDestructive,
            'has-text': !!icon && (hasChildren || text),
            'has-icon': !!icon
          });
          const trulyDisabled = disabled && !accessibleWhenDisabled;
          const Tag = href !== undefined && !disabled ? 'a' : 'button';
          const buttonProps = Tag === 'button' ? {
            type: 'button',
            disabled: trulyDisabled,
            'aria-checked': ariaChecked,
            'aria-pressed': ariaPressed,
            'aria-selected': ariaSelected
          } : {};
          const anchorProps = Tag === 'a' ? {
            href,
            target
          } : {};
          const disableEventProps = {};
          if (disabled && accessibleWhenDisabled) {
            // In this case, the button will be disabled, but still focusable and
            // perceivable by screen reader users.
            buttonProps['aria-disabled'] = true;
            anchorProps['aria-disabled'] = true;
            for (const disabledEvent of disabledEventsOnDisabledButton) {
              disableEventProps[disabledEvent] = event => {
                if (event) {
                  event.stopPropagation();
                  event.preventDefault();
                }
              };
            }
          }

          // Should show the tooltip if...
          const shouldShowTooltip = !trulyDisabled && (
          // An explicit tooltip is passed or...
          showTooltip && !!label ||
          // There's a shortcut or...
          !!shortcut ||
          // There's a label and...
          !!label &&
          // The children are empty and...
          !children?.length &&
          // The tooltip is not explicitly disabled.
          false !== showTooltip);
          const descriptionId = description ? instanceId : undefined;
          const describedById = additionalProps['aria-describedby'] || descriptionId;
          const commonProps = {
            className: classes,
            'aria-label': additionalProps['aria-label'] || label,
            'aria-describedby': describedById,
            ref
          };
          const elementChildren = /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [icon && iconPosition === 'left' && /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
              icon: icon,
              size: iconSize
            }), text && /*#__PURE__*/jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: text
            }), children, icon && iconPosition === 'right' && /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
              icon: icon,
              size: iconSize
            })]
          });
          const element = Tag === 'a' ? /*#__PURE__*/jsxRuntimeExports.jsx("a", {
            ...anchorProps,
            ...additionalProps,
            ...disableEventProps,
            ...commonProps,
            children: elementChildren
          }) : /*#__PURE__*/jsxRuntimeExports.jsx("button", {
            ...buttonProps,
            ...additionalProps,
            ...disableEventProps,
            ...commonProps,
            children: elementChildren
          });

          // In order to avoid some React reconciliation issues, we are always rendering
          // the `Tooltip` component even when `shouldShowTooltip` is `false`.
          // In order to make sure that the tooltip doesn't show when it shouldn't,
          // we don't pass the props to the `Tooltip` component.
          const tooltipProps = shouldShowTooltip ? {
            text: children?.length && description ? description : label,
            shortcut,
            placement: tooltipPosition &&
            // Convert legacy `position` values to be used with the new `placement` prop
            positionToPlacement(tooltipPosition)
          } : {};
          return /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(Tooltip$1, {
              ...tooltipProps,
              children: element
            }), description && /*#__PURE__*/jsxRuntimeExports.jsx(VisuallyHidden, {
              children: /*#__PURE__*/jsxRuntimeExports.jsx("span", {
                id: descriptionId,
                children: description
              })
            })]
          });
        }

        /**
         * Lets users take actions and make choices with a single click or tap.
         *
         * ```jsx
         * import { Button } from '@wordpress/components';
         * const Mybutton = () => (
         *   <Button
         *     variant="primary"
         *     onClick={ handleClick }
         *   >
         *     Click here
         *   </Button>
         * );
         * ```
         */
        const Button = reactExports.forwardRef(UnforwardedButton);
        var _ref$3 = {
          name: "euqsgg",
          styles: "input[type='number']::-webkit-outer-spin-button,input[type='number']::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0!important;}input[type='number']{-moz-appearance:textfield;}"
        };
        const htmlArrowStyles = ({
          hideHTMLArrows
        }) => {
          if (!hideHTMLArrows) {
            return ``;
          }
          return _ref$3;
        };
        const Input = /* @__PURE__ */createStyled(InputControl, {
          target: "ep09it41"
        })(htmlArrowStyles, ";" + "");
        const SpinButton = /* @__PURE__ */createStyled(Button, {
          target: "ep09it40"
        })("&&&&&{color:", COLORS$1.theme.accent, ";}" + "");
        const smallSpinButtons = /* @__PURE__ */css("width:", space(5), ";min-width:", space(5), ";height:", space(5), ";" + "", "");
        const styles = {
          smallSpinButtons
        };

        /**
         * Parses and retrieves a number value.
         *
         * @param {unknown} value The incoming value.
         *
         * @return {number} The parsed number value.
         */
        function getNumber(value) {
          const number = Number(value);
          return isNaN(number) ? 0 : number;
        }

        /**
         * Safely adds 2 values.
         *
         * @param {Array<number|string>} args Values to add together.
         *
         * @return {number} The sum of values.
         */
        function add$1(...args) {
          return args.reduce(/** @type {(sum:number, arg: number|string) => number} */
          (sum, arg) => sum + getNumber(arg), 0);
        }

        /**
         * Safely subtracts 2 values.
         *
         * @param {Array<number|string>} args Values to subtract together.
         *
         * @return {number} The difference of the values.
         */
        function subtract$1(...args) {
          return args.reduce(/** @type {(diff:number, arg: number|string, index:number) => number} */
          (diff, arg, index) => {
            const value = getNumber(arg);
            return index === 0 ? value : diff - value;
          }, 0);
        }

        /**
         * Determines the decimal position of a number value.
         *
         * @param {number} value The number to evaluate.
         *
         * @return {number} The number of decimal places.
         */
        function getPrecision(value) {
          const split = (value + '').split('.');
          return split[1] !== undefined ? split[1].length : 0;
        }

        /**
         * Clamps a value based on a min/max range.
         *
         * @param {number} value The value.
         * @param {number} min   The minimum range.
         * @param {number} max   The maximum range.
         *
         * @return {number} The clamped value.
         */
        function clamp(value, min, max) {
          const baseValue = getNumber(value);
          return Math.max(min, Math.min(baseValue, max));
        }

        /**
         * Clamps a value based on a min/max range with rounding
         *
         * @param {number | string} value The value.
         * @param {number}          min   The minimum range.
         * @param {number}          max   The maximum range.
         * @param {number}          step  A multiplier for the value.
         *
         * @return {number} The rounded and clamped value.
         */
        function roundClamp(value = 0, min = Infinity, max = Infinity, step = 1) {
          const baseValue = getNumber(value);
          const stepValue = getNumber(step);
          const precision = getPrecision(step);
          const rounded = Math.round(baseValue / stepValue) * stepValue;
          const clampedValue = clamp(rounded, min, max);
          return precision ? getNumber(clampedValue.toFixed(precision)) : clampedValue;
        }

        /**
         * External dependencies
         */

        const H_ALIGNMENTS = {
          bottom: {
            align: 'flex-end',
            justify: 'center'
          },
          bottomLeft: {
            align: 'flex-end',
            justify: 'flex-start'
          },
          bottomRight: {
            align: 'flex-end',
            justify: 'flex-end'
          },
          center: {
            align: 'center',
            justify: 'center'
          },
          edge: {
            align: 'center',
            justify: 'space-between'
          },
          left: {
            align: 'center',
            justify: 'flex-start'
          },
          right: {
            align: 'center',
            justify: 'flex-end'
          },
          stretch: {
            align: 'stretch'
          },
          top: {
            align: 'flex-start',
            justify: 'center'
          },
          topLeft: {
            align: 'flex-start',
            justify: 'flex-start'
          },
          topRight: {
            align: 'flex-start',
            justify: 'flex-end'
          }
        };
        const V_ALIGNMENTS = {
          bottom: {
            justify: 'flex-end',
            align: 'center'
          },
          bottomLeft: {
            justify: 'flex-end',
            align: 'flex-start'
          },
          bottomRight: {
            justify: 'flex-end',
            align: 'flex-end'
          },
          center: {
            justify: 'center',
            align: 'center'
          },
          edge: {
            justify: 'space-between',
            align: 'center'
          },
          left: {
            justify: 'center',
            align: 'flex-start'
          },
          right: {
            justify: 'center',
            align: 'flex-end'
          },
          stretch: {
            align: 'stretch'
          },
          top: {
            justify: 'flex-start',
            align: 'center'
          },
          topLeft: {
            justify: 'flex-start',
            align: 'flex-start'
          },
          topRight: {
            justify: 'flex-start',
            align: 'flex-end'
          }
        };
        function getAlignmentProps$1(alignment, direction = 'row') {
          if (!isValueDefined(alignment)) {
            return {};
          }
          const isVertical = direction === 'column';
          const props = isVertical ? V_ALIGNMENTS : H_ALIGNMENTS;
          const alignmentProps = alignment in props ? props[alignment] : {
            align: alignment
          };
          return alignmentProps;
        }

        /**
         * External dependencies
         */

        /**
         * Gets a collection of available children elements from a React component's children prop.
         *
         * @param children
         *
         * @return An array of available children.
         */
        function getValidChildren(children) {
          if (typeof children === 'string') {
            return [children];
          }
          return reactExports.Children.toArray(children).filter(child => reactExports.isValidElement(child));
        }

        /**
         * External dependencies
         */

        function useHStack(props) {
          const {
            alignment = 'edge',
            children,
            direction,
            spacing = 2,
            ...otherProps
          } = useContextSystem(props, 'HStack');
          const align = getAlignmentProps$1(alignment, direction);
          const validChildren = getValidChildren(children);
          const clonedChildren = validChildren.map((child, index) => {
            const _isSpacer = hasConnectNamespace(child, ['Spacer']);
            if (_isSpacer) {
              const childElement = child;
              const _key = childElement.key || `hstack-${index}`;
              return /*#__PURE__*/jsxRuntimeExports.jsx(FlexItem, {
                isBlock: true,
                ...childElement.props
              }, _key);
            }
            return child;
          });
          const propsForFlex = {
            children: clonedChildren,
            direction,
            justify: 'center',
            ...align,
            ...otherProps,
            gap: spacing
          };

          // Omit `isColumn` because it's not used in HStack.
          const {
            isColumn,
            ...flexProps
          } = useFlex(propsForFlex);
          return flexProps;
        }

        /**
         * Internal dependencies
         */

        function UnconnectedHStack(props, forwardedRef) {
          const hStackProps = useHStack(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...hStackProps,
            ref: forwardedRef
          });
        }

        /**
         * `HStack` (Horizontal Stack) arranges child elements in a horizontal line.
         *
         * `HStack` can render anything inside.
         *
         * ```jsx
         * import {
         * 	__experimentalHStack as HStack,
         * 	__experimentalText as Text,
         * } from `@wordpress/components`;
         *
         * function Example() {
         * 	return (
         * 		<HStack>
         * 			<Text>Code</Text>
         * 			<Text>is</Text>
         * 			<Text>Poetry</Text>
         * 		</HStack>
         * 	);
         * }
         * ```
         */
        const HStack = contextConnect(UnconnectedHStack, 'HStack');

        /**
         * External dependencies
         */
        const noop$4 = () => {};
        function UnforwardedNumberControl(props, forwardedRef) {
          const {
            __unstableStateReducer: stateReducerProp,
            className,
            dragDirection = 'n',
            hideHTMLArrows = false,
            spinControls = hideHTMLArrows ? 'none' : 'native',
            isDragEnabled = true,
            isShiftStepEnabled = true,
            label,
            max = Infinity,
            min = -Infinity,
            required = false,
            shiftStep = 10,
            step = 1,
            spinFactor = 1,
            type: typeProp = 'number',
            value: valueProp,
            size = 'default',
            suffix,
            onChange = noop$4,
            ...restProps
          } = useDeprecated36pxDefaultSizeProp(props);
          if (hideHTMLArrows) {
            deprecated('wp.components.NumberControl hideHTMLArrows prop ', {
              alternative: 'spinControls="none"',
              since: '6.2',
              version: '6.3'
            });
          }
          const inputRef = reactExports.useRef();
          const mergedRef = useMergeRefs$1([inputRef, forwardedRef]);
          const isStepAny = step === 'any';
          const baseStep = isStepAny ? 1 : ensureNumber(step);
          const baseSpin = ensureNumber(spinFactor) * baseStep;
          const baseValue = roundClamp(0, min, max, baseStep);
          const constrainValue = (value, stepOverride) => {
            // When step is "any" clamp the value, otherwise round and clamp it.
            // Use '' + to convert to string for use in input value attribute.
            return isStepAny ? '' + Math.min(max, Math.max(min, ensureNumber(value))) : '' + roundClamp(value, min, max, stepOverride !== null && stepOverride !== void 0 ? stepOverride : baseStep);
          };
          const autoComplete = typeProp === 'number' ? 'off' : undefined;
          const classes = clsx('components-number-control', className);
          const cx = useCx();
          const spinButtonClasses = cx(size === 'small' && styles.smallSpinButtons);
          const spinValue = (value, direction, event) => {
            event?.preventDefault();
            const shift = event?.shiftKey && isShiftStepEnabled;
            const delta = shift ? ensureNumber(shiftStep) * baseSpin : baseSpin;
            let nextValue = isValueEmpty(value) ? baseValue : value;
            if (direction === 'up') {
              nextValue = add$1(nextValue, delta);
            } else if (direction === 'down') {
              nextValue = subtract$1(nextValue, delta);
            }
            return constrainValue(nextValue, shift ? delta : undefined);
          };

          /**
           * "Middleware" function that intercepts updates from InputControl.
           * This allows us to tap into actions to transform the (next) state for
           * InputControl.
           *
           * @return The updated state to apply to InputControl
           */
          const numberControlStateReducer = (state, action) => {
            const nextState = {
              ...state
            };
            const {
              type,
              payload
            } = action;
            const event = payload.event;
            const currentValue = nextState.value;

            /**
             * Handles custom UP and DOWN Keyboard events
             */
            if (type === PRESS_UP || type === PRESS_DOWN) {
              nextState.value = spinValue(currentValue, type === PRESS_UP ? 'up' : 'down', event);
            }

            /**
             * Handles drag to update events
             */
            if (type === DRAG && isDragEnabled) {
              const [x, y] = payload.delta;
              const enableShift = payload.shiftKey && isShiftStepEnabled;
              const modifier = enableShift ? ensureNumber(shiftStep) * baseSpin : baseSpin;
              let directionModifier;
              let delta;
              switch (dragDirection) {
                case 'n':
                  delta = y;
                  directionModifier = -1;
                  break;
                case 'e':
                  delta = x;
                  directionModifier = isRTL$1() ? -1 : 1;
                  break;
                case 's':
                  delta = y;
                  directionModifier = 1;
                  break;
                case 'w':
                  delta = x;
                  directionModifier = isRTL$1() ? 1 : -1;
                  break;
              }
              if (delta !== 0) {
                delta = Math.ceil(Math.abs(delta)) * Math.sign(delta);
                const distance = delta * modifier * directionModifier;
                nextState.value = constrainValue(
                // @ts-expect-error TODO: Investigate if it's ok for currentValue to be undefined
                add$1(currentValue, distance), enableShift ? modifier : undefined);
              }
            }

            /**
             * Handles commit (ENTER key press or blur)
             */
            if (type === PRESS_ENTER || type === COMMIT) {
              const applyEmptyValue = required === false && currentValue === '';
              nextState.value = applyEmptyValue ? currentValue :
              // @ts-expect-error TODO: Investigate if it's ok for currentValue to be undefined
              constrainValue(currentValue);
            }
            return nextState;
          };
          const buildSpinButtonClickHandler = direction => event => onChange(String(spinValue(valueProp, direction, event)), {
            // Set event.target to the <input> so that consumers can use
            // e.g. event.target.validity.
            event: {
              ...event,
              target: inputRef.current
            }
          });
          return /*#__PURE__*/jsxRuntimeExports.jsx(Input, {
            autoComplete: autoComplete,
            inputMode: "numeric",
            ...restProps,
            className: classes,
            dragDirection: dragDirection,
            hideHTMLArrows: spinControls !== 'native',
            isDragEnabled: isDragEnabled,
            label: label,
            max: max,
            min: min,
            ref: mergedRef,
            required: required,
            step: step,
            type: typeProp
            // @ts-expect-error TODO: Resolve discrepancy between `value` types in InputControl based components
            ,

            value: valueProp,
            __unstableStateReducer: (state, action) => {
              var _stateReducerProp;
              const baseState = numberControlStateReducer(state, action);
              return (_stateReducerProp = stateReducerProp?.(baseState, action)) !== null && _stateReducerProp !== void 0 ? _stateReducerProp : baseState;
            },
            size: size,
            suffix: spinControls === 'custom' ? /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [suffix, /*#__PURE__*/jsxRuntimeExports.jsx(Spacer, {
                marginBottom: 0,
                marginRight: 2,
                children: /*#__PURE__*/jsxRuntimeExports.jsxs(HStack, {
                  spacing: 1,
                  children: [/*#__PURE__*/jsxRuntimeExports.jsx(SpinButton, {
                    className: spinButtonClasses,
                    icon: plus,
                    size: "small",
                    label: __('Increment'),
                    onClick: buildSpinButtonClickHandler('up')
                  }), /*#__PURE__*/jsxRuntimeExports.jsx(SpinButton, {
                    className: spinButtonClasses,
                    icon: reset,
                    size: "small",
                    label: __('Decrement'),
                    onClick: buildSpinButtonClickHandler('down')
                  })]
                })
              })]
            }) : suffix,
            onChange: onChange
          });
        }
        const NumberControl = reactExports.forwardRef(UnforwardedNumberControl);

        // Unique ID creation requires a high quality random # generator. In the browser we therefore
        // require the crypto API and do not support built-in fallback to lower quality random number
        // generators (like Math.random()).
        let getRandomValues;
        const rnds8 = new Uint8Array(16);
        function rng() {
          // lazy load so that environments that need to polyfill have a chance to do so
          if (!getRandomValues) {
            // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
            getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
            if (!getRandomValues) {
              throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
            }
          }
          return getRandomValues(rnds8);
        }

        /**
         * Convert array of 16 byte values to UUID string format of the form:
         * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
         */

        const byteToHex = [];
        for (let i = 0; i < 256; ++i) {
          byteToHex.push((i + 0x100).toString(16).slice(1));
        }
        function unsafeStringify(arr, offset = 0) {
          // Note: Be careful editing this code!  It's been tuned for performance
          // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
          return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
        }
        const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
        const native = {
          randomUUID
        };
        function v4(options, buf, offset) {
          if (native.randomUUID && true && !options) {
            return native.randomUUID();
          }
          options = options || {};
          const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

          rnds[6] = rnds[6] & 0x0f | 0x40;
          rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

          return unsafeStringify(rnds);
        }

        /* wp:polyfill */
        /**
         * External dependencies
         */
        const uuidCache = new Set();
        // Use a weak map so that when the container is detached it's automatically
        // dereferenced to avoid memory leak.
        const containerCacheMap = new WeakMap();
        const memoizedCreateCacheWithContainer = container => {
          if (containerCacheMap.has(container)) {
            return containerCacheMap.get(container);
          }

          // Emotion only accepts alphabetical and hyphenated keys so we just
          // strip the numbers from the UUID. It _should_ be fine.
          let key = v4().replace(/[0-9]/g, '');
          while (uuidCache.has(key)) {
            key = v4().replace(/[0-9]/g, '');
          }
          uuidCache.add(key);
          const cache = createCache({
            container,
            key
          });
          containerCacheMap.set(container, cache);
          return cache;
        };
        function StyleProvider(props) {
          const {
            children,
            document
          } = props;
          if (!document) {
            return null;
          }
          const cache = memoizedCreateCacheWithContainer(document.head);
          return /*#__PURE__*/jsxRuntimeExports.jsx(CacheProvider, {
            value: cache,
            children: children
          });
        }

        /**
         * WordPress dependencies
         */
        function maybeWarnDeprecated36pxSize({
          componentName,
          __next40pxDefaultSize,
          size,
          __shouldNotWarnDeprecated36pxSize
        }) {
          if (__shouldNotWarnDeprecated36pxSize || __next40pxDefaultSize || size !== undefined) {
            return;
          }
          deprecated(`36px default size for wp.components.${componentName}`, {
            since: '6.8',
            version: '7.1',
            hint: 'Set the `__next40pxDefaultSize` prop to true to start opting into the new default size, which will become the default in a future version.'
          });
        }

        /**
         * External dependencies
         */
        function UnforwardedColorIndicator(props, forwardedRef) {
          const {
            className,
            colorValue,
            ...additionalProps
          } = props;
          return /*#__PURE__*/jsxRuntimeExports.jsx("span", {
            className: clsx('component-color-indicator', className),
            style: {
              background: colorValue
            },
            ref: forwardedRef,
            ...additionalProps
          });
        }

        /**
         * ColorIndicator is a React component that renders a specific color in a
         * circle. It's often used to summarize a collection of used colors in a child
         * component.
         *
         * ```jsx
         * import { ColorIndicator } from '@wordpress/components';
         *
         * const MyColorIndicator = () => <ColorIndicator colorValue="#0073aa" />;
         * ```
         */
        const ColorIndicator = reactExports.forwardRef(UnforwardedColorIndicator);

        /**
         * External dependencies
         */

        function UnconnectedInputControlSuffixWrapper(props, forwardedRef) {
          const derivedProps = useContextSystem(props, 'InputControlSuffixWrapper');
          return /*#__PURE__*/jsxRuntimeExports.jsx(PrefixSuffixWrapper, {
            ...derivedProps,
            ref: forwardedRef
          });
        }

        /**
         * A convenience wrapper for the `suffix` when you want to apply
         * standard padding in accordance with the size variant.
         *
         * ```jsx
         * import {
         *   __experimentalInputControl as InputControl,
         *   __experimentalInputControlSuffixWrapper as InputControlSuffixWrapper,
         * } from '@wordpress/components';
         *
         * <InputControl
         *   suffix={<InputControlSuffixWrapper>%</InputControlSuffixWrapper>}
         * />
         * ```
         */
        const InputControlSuffixWrapper = contextConnect(UnconnectedInputControlSuffixWrapper, 'InputControlSuffixWrapper');
        const disabledStyles = ({
          disabled
        }) => {
          if (!disabled) {
            return "";
          }
          return /* @__PURE__ */css("color:", COLORS$1.ui.textDisabled, ";cursor:default;" + "", "");
        };
        var _ref2$1 = {
          name: "1lv1yo7",
          styles: "display:inline-flex"
        };
        const inputBaseVariantStyles = ({
          variant
        }) => {
          if (variant === "minimal") {
            return _ref2$1;
          }
          return "";
        };
        const StyledInputBase = /* @__PURE__ */createStyled(InputBase$1, {
          target: "e1mv6sxx3"
        })("color:", COLORS$1.theme.foreground, ";cursor:pointer;", disabledStyles, " ", inputBaseVariantStyles, ";" + "");
        const sizeStyles = ({
          __next40pxDefaultSize,
          multiple,
          selectSize = "default"
        }) => {
          if (multiple) {
            return;
          }
          const sizes = {
            default: {
              height: 40,
              minHeight: 40,
              paddingTop: 0,
              paddingBottom: 0
            },
            small: {
              height: 24,
              minHeight: 24,
              paddingTop: 0,
              paddingBottom: 0
            },
            compact: {
              height: 32,
              minHeight: 32,
              paddingTop: 0,
              paddingBottom: 0
            },
            "__unstable-large": {
              height: 40,
              minHeight: 40,
              paddingTop: 0,
              paddingBottom: 0
            }
          };
          if (!__next40pxDefaultSize) {
            sizes.default = sizes.compact;
          }
          const style = sizes[selectSize] || sizes.default;
          return /* @__PURE__ */css(style, "", "");
        };
        const chevronIconSize = 18;
        const sizePaddings = ({
          __next40pxDefaultSize,
          multiple,
          selectSize = "default"
        }) => {
          const padding = {
            default: CONFIG.controlPaddingX,
            small: CONFIG.controlPaddingXSmall,
            compact: CONFIG.controlPaddingXSmall,
            "__unstable-large": CONFIG.controlPaddingX
          };
          if (!__next40pxDefaultSize) {
            padding.default = padding.compact;
          }
          const selectedPadding = padding[selectSize] || padding.default;
          return rtl({
            paddingLeft: selectedPadding,
            paddingRight: selectedPadding + chevronIconSize,
            ...(multiple ? {
              paddingTop: selectedPadding,
              paddingBottom: selectedPadding
            } : {})
          });
        };
        const overflowStyles = ({
          multiple
        }) => {
          return {
            overflow: multiple ? "auto" : "hidden"
          };
        };
        var _ref$2 = {
          name: "n1jncc",
          styles: "field-sizing:content"
        };
        const variantStyles = ({
          variant
        }) => {
          if (variant === "minimal") {
            return _ref$2;
          }
          return "";
        };
        const Select = /* @__PURE__ */createStyled("select", {
          target: "e1mv6sxx2"
        })("&&&{appearance:none;background:transparent;box-sizing:border-box;border:none;box-shadow:none!important;color:currentColor;cursor:inherit;display:block;font-family:inherit;margin:0;width:100%;max-width:none;white-space:nowrap;text-overflow:ellipsis;", fontSizeStyles, ";", sizeStyles, ";", sizePaddings, ";", overflowStyles, " ", variantStyles, ";}" + "");
        const DownArrowWrapper = /* @__PURE__ */createStyled("div", {
          target: "e1mv6sxx1"
        })("margin-inline-end:", space(-1), ";line-height:0;path{fill:currentColor;}" + "");
        const InputControlSuffixWrapperWithClickThrough = /* @__PURE__ */createStyled(InputControlSuffixWrapper, {
          target: "e1mv6sxx0"
        })("position:absolute;pointer-events:none;", rtl({
          right: 0
        }), ";" + "");

        /**
         * WordPress dependencies
         */
        const SelectControlChevronDown = () => {
          return /*#__PURE__*/jsxRuntimeExports.jsx(InputControlSuffixWrapperWithClickThrough, {
            children: /*#__PURE__*/jsxRuntimeExports.jsx(DownArrowWrapper, {
              children: /*#__PURE__*/jsxRuntimeExports.jsx(Icon$2, {
                icon: chevronDown,
                size: chevronIconSize
              })
            })
          });
        };

        /**
         * External dependencies
         */
        function useUniqueId$1(idProp) {
          const instanceId = useInstanceId(SelectControl$1);
          const id = `inspector-select-control-${instanceId}`;
          return idProp || id;
        }
        function SelectOptions({
          options
        }) {
          return options.map(({
            id,
            label,
            value,
            ...optionProps
          }, index) => {
            const key = id || `${label}-${value}-${index}`;
            return /*#__PURE__*/jsxRuntimeExports.jsx("option", {
              value: value,
              ...optionProps,
              children: label
            }, key);
          });
        }
        function UnforwardedSelectControl(props, ref) {
          const {
            className,
            disabled = false,
            help,
            hideLabelFromVision,
            id: idProp,
            label,
            multiple = false,
            onChange,
            options = [],
            size = 'default',
            value: valueProp,
            labelPosition = 'top',
            children,
            prefix,
            suffix,
            variant = 'default',
            __next40pxDefaultSize = false,
            __nextHasNoMarginBottom = false,
            ...restProps
          } = useDeprecated36pxDefaultSizeProp(props);
          const id = useUniqueId$1(idProp);
          const helpId = help ? `${id}__help` : undefined;

          // Disable reason: A select with an onchange throws a warning.
          if (!options?.length && !children) {
            return null;
          }
          const handleOnChange = event => {
            if (props.multiple) {
              const selectedOptions = Array.from(event.target.options).filter(({
                selected
              }) => selected);
              const newValues = selectedOptions.map(({
                value
              }) => value);
              props.onChange?.(newValues, {
                event
              });
              return;
            }
            props.onChange?.(event.target.value, {
              event
            });
          };
          const classes = clsx('components-select-control', className);
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            help: help,
            id: id,
            __nextHasNoMarginBottom: __nextHasNoMarginBottom,
            __associatedWPComponentName: "SelectControl",
            children: /*#__PURE__*/jsxRuntimeExports.jsx(StyledInputBase, {
              className: classes,
              disabled: disabled,
              hideLabelFromVision: hideLabelFromVision,
              id: id,
              isBorderless: variant === 'minimal',
              label: label,
              size: size,
              suffix: suffix || !multiple && /*#__PURE__*/jsxRuntimeExports.jsx(SelectControlChevronDown, {}),
              prefix: prefix,
              labelPosition: labelPosition,
              __unstableInputWidth: variant === 'minimal' ? 'auto' : undefined,
              variant: variant,
              __next40pxDefaultSize: __next40pxDefaultSize,
              children: /*#__PURE__*/jsxRuntimeExports.jsx(Select, {
                ...restProps,
                __next40pxDefaultSize: __next40pxDefaultSize,
                "aria-describedby": helpId,
                className: "components-select-control__input",
                disabled: disabled,
                id: id,
                multiple: multiple,
                onChange: handleOnChange,
                ref: ref,
                selectSize: size,
                value: valueProp,
                variant: variant,
                children: children || /*#__PURE__*/jsxRuntimeExports.jsx(SelectOptions, {
                  options: options
                })
              })
            })
          });
        }

        /**
         * `SelectControl` allows users to select from a single or multiple option menu.
         * It functions as a wrapper around the browser's native `<select>` element.
         *
         * ```jsx
         * import { SelectControl } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MySelectControl = () => {
         *   const [ size, setSize ] = useState( '50%' );
         *
         *   return (
         *     <SelectControl
         *       __nextHasNoMarginBottom
         *       label="Size"
         *       value={ size }
         *       options={ [
         *         { label: 'Big', value: '100%' },
         *         { label: 'Medium', value: '50%' },
         *         { label: 'Small', value: '25%' },
         *       ] }
         *       onChange={ setSize }
         *     />
         *   );
         * };
         * ```
         */
        const SelectControl$1 = reactExports.forwardRef(UnforwardedSelectControl);

        /**
         * WordPress dependencies
         */
        /**
         * A float supported clamp function for a specific value.
         *
         * @param value The value to clamp.
         * @param min   The minimum value.
         * @param max   The maximum value.
         *
         * @return A (float) number
         */
        function floatClamp(value, min, max) {
          if (typeof value !== 'number') {
            return null;
          }
          return parseFloat(`${clamp(value, min, max)}`);
        }

        /**
         * Hook to store a clamped value, derived from props.
         *
         * @param settings
         * @return The controlled value and the value setter.
         */
        function useControlledRangeValue(settings) {
          const {
            min,
            max,
            value: valueProp,
            initial
          } = settings;
          const [state, setInternalState] = useControlledState(floatClamp(valueProp, min, max), {
            initial: floatClamp(initial !== null && initial !== void 0 ? initial : null, min, max),
            fallback: null
          });
          const setState = reactExports.useCallback(nextValue => {
            if (nextValue === null) {
              setInternalState(null);
            } else {
              setInternalState(floatClamp(nextValue, min, max));
            }
          }, [min, max, setInternalState]);

          // `state` can't be an empty string because we specified a fallback value of
          // `null` in `useControlledState`
          return [state, setState];
        }
        const rangeHeightValue = 30;
        const railHeight = 4;
        const rangeHeight = () => /* @__PURE__ */css({
          height: rangeHeightValue,
          minHeight: rangeHeightValue
        }, "", "");
        const thumbSize = 12;
        const deprecatedHeight = ({
          __next40pxDefaultSize
        }) => !__next40pxDefaultSize && /* @__PURE__ */css({
          minHeight: rangeHeightValue
        }, "", "");
        const Root = /* @__PURE__ */createStyled("div", {
          target: "e1epgpqk14"
        })("-webkit-tap-highlight-color:transparent;align-items:center;display:flex;justify-content:flex-start;padding:0;position:relative;touch-action:none;width:100%;min-height:40px;", deprecatedHeight, ";" + "");
        const wrapperColor = ({
          color = COLORS$1.ui.borderFocus
        }) => /* @__PURE__ */css({
          color
        }, "", "");
        const wrapperMargin = ({
          marks,
          __nextHasNoMarginBottom
        }) => {
          if (!__nextHasNoMarginBottom) {
            return /* @__PURE__ */css({
              marginBottom: marks ? 16 : void 0
            }, "", "");
          }
          return "";
        };
        const Wrapper$1 = /* @__PURE__ */createStyled("div", {
          shouldForwardProp: prop => !["color", "__nextHasNoMarginBottom", "marks"].includes(prop),
          target: "e1epgpqk13"
        })("display:block;flex:1;position:relative;width:100%;", wrapperColor, ";", rangeHeight, ";", wrapperMargin, ";" + "");
        const BeforeIconWrapper = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk12"
        })("display:flex;margin-top:", railHeight, "px;", rtl({
          marginRight: 6
        }), ";" + "");
        const AfterIconWrapper = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk11"
        })("display:flex;margin-top:", railHeight, "px;", rtl({
          marginLeft: 6
        }), ";" + "");
        const railBackgroundColor = ({
          disabled,
          railColor
        }) => {
          let background = railColor || "";
          if (disabled) {
            background = COLORS$1.ui.backgroundDisabled;
          }
          return /* @__PURE__ */css({
            background
          }, "", "");
        };
        const Rail = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk10"
        })("background-color:", COLORS$1.gray[300], ";left:0;pointer-events:none;right:0;display:block;height:", railHeight, "px;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;border-radius:", CONFIG.radiusFull, ";", railBackgroundColor, ";" + "");
        const trackBackgroundColor = ({
          disabled,
          trackColor
        }) => {
          let background = trackColor || "currentColor";
          if (disabled) {
            background = COLORS$1.gray[400];
          }
          return /* @__PURE__ */css({
            background
          }, "", "");
        };
        const Track = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk9"
        })("background-color:currentColor;border-radius:", CONFIG.radiusFull, ";height:", railHeight, "px;pointer-events:none;display:block;position:absolute;margin-top:", (rangeHeightValue - railHeight) / 2, "px;top:0;", trackBackgroundColor, ";" + "");
        const MarksWrapper = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk8"
        })({
          name: "l7tjj5",
          styles: "display:block;pointer-events:none;position:relative;width:100%;user-select:none"
        });
        const markFill = ({
          disabled,
          isFilled
        }) => {
          let backgroundColor = isFilled ? "currentColor" : COLORS$1.gray[300];
          if (disabled) {
            backgroundColor = COLORS$1.gray[400];
          }
          return /* @__PURE__ */css({
            backgroundColor
          }, "", "");
        };
        const Mark = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk7"
        })("height:", thumbSize, "px;left:0;position:absolute;top:9px;width:1px;", markFill, ";" + "");
        const markLabelFill = ({
          isFilled
        }) => {
          return /* @__PURE__ */css({
            color: isFilled ? COLORS$1.gray[700] : COLORS$1.gray[300]
          }, "", "");
        };
        const MarkLabel = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk6"
        })("color:", COLORS$1.gray[300], ";font-size:11px;position:absolute;top:22px;white-space:nowrap;", rtl({
          left: 0
        }), ";", rtl({
          transform: "translateX( -50% )"
        }, {
          transform: "translateX( 50% )"
        }), ";", markLabelFill, ";" + "");
        const thumbColor = ({
          disabled
        }) => disabled ? /* @__PURE__ */css("background-color:", COLORS$1.gray[400], ";" + "", "") : /* @__PURE__ */css("background-color:", COLORS$1.theme.accent, ";" + "", "");
        const ThumbWrapper = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk5"
        })("align-items:center;display:flex;height:", thumbSize, "px;justify-content:center;margin-top:", (rangeHeightValue - thumbSize) / 2, "px;outline:0;pointer-events:none;position:absolute;top:0;user-select:none;width:", thumbSize, "px;border-radius:", CONFIG.radiusRound, ";", thumbColor, ";", rtl({
          marginLeft: -10
        }), ";", rtl({
          transform: "translateX( 4.5px )"
        }, {
          transform: "translateX( -4.5px )"
        }), ";" + "");
        const thumbFocus = ({
          isFocused
        }) => {
          return isFocused ? /* @__PURE__ */css("&::before{content:' ';position:absolute;background-color:", COLORS$1.theme.accent, ";opacity:0.4;border-radius:", CONFIG.radiusRound, ";height:", thumbSize + 8, "px;width:", thumbSize + 8, "px;top:-4px;left:-4px;}" + "", "") : "";
        };
        const Thumb = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk4"
        })("align-items:center;border-radius:", CONFIG.radiusRound, ";height:100%;outline:0;position:absolute;user-select:none;width:100%;box-shadow:", CONFIG.elevationXSmall, ";", thumbColor, ";", thumbFocus, ";" + "");
        const InputRange$1 = /* @__PURE__ */createStyled("input", {
          target: "e1epgpqk3"
        })("box-sizing:border-box;cursor:pointer;display:block;height:100%;left:0;margin:0 -", thumbSize / 2, "px;opacity:0;outline:none;position:absolute;right:0;top:0;width:calc( 100% + ", thumbSize, "px );" + "");
        const tooltipShow = ({
          show
        }) => {
          return /* @__PURE__ */css("display:", show ? "inline-block" : "none", ";opacity:", show ? 1 : 0, ";@media not ( prefers-reduced-motion ){transition:opacity 120ms ease,display 120ms ease allow-discrete;}@starting-style{opacity:0;}" + "", "");
        };
        var _ref$1 = {
          name: "1cypxip",
          styles: "top:-80%"
        };
        var _ref2 = {
          name: "1lr98c4",
          styles: "bottom:-80%"
        };
        const tooltipPosition = ({
          position
        }) => {
          const isBottom = position === "bottom";
          if (isBottom) {
            return _ref2;
          }
          return _ref$1;
        };
        const Tooltip = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk2"
        })("background:rgba( 0, 0, 0, 0.8 );border-radius:", CONFIG.radiusSmall, ";color:white;font-size:12px;min-width:32px;padding:4px 8px;pointer-events:none;position:absolute;text-align:center;user-select:none;line-height:1.4;", tooltipShow, ";", tooltipPosition, ";", rtl({
          transform: "translateX(-50%)"
        }, {
          transform: "translateX(50%)"
        }), ";" + "");
        const InputNumber = /* @__PURE__ */createStyled(NumberControl, {
          target: "e1epgpqk1"
        })("display:inline-block;font-size:13px;margin-top:0;input[type='number']&{", rangeHeight, ";}", rtl({
          marginLeft: `${space(4)} !important`
        }), ";" + "");
        const ActionRightWrapper = /* @__PURE__ */createStyled("span", {
          target: "e1epgpqk0"
        })("display:block;margin-top:0;button,button.is-small{margin-left:0;", rangeHeight, ";}", rtl({
          marginLeft: 8
        }), ";" + "");

        /**
         * WordPress dependencies
         */
        function InputRange(props, ref) {
          const {
            describedBy,
            label,
            value,
            ...otherProps
          } = props;
          return /*#__PURE__*/jsxRuntimeExports.jsx(InputRange$1, {
            ...otherProps,
            "aria-describedby": describedBy,
            "aria-label": label,
            "aria-hidden": false,
            ref: ref,
            tabIndex: 0,
            type: "range",
            value: value
          });
        }
        const ForwardedComponent = reactExports.forwardRef(InputRange);

        /**
         * External dependencies
         */
        function RangeMark(props) {
          const {
            className,
            isFilled = false,
            label,
            style = {},
            ...otherProps
          } = props;
          const classes = clsx('components-range-control__mark', isFilled && 'is-filled', className);
          const labelClasses = clsx('components-range-control__mark-label', isFilled && 'is-filled');
          return /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(Mark, {
              ...otherProps,
              "aria-hidden": "true",
              className: classes,
              isFilled: isFilled,
              style: style
            }), label && /*#__PURE__*/jsxRuntimeExports.jsx(MarkLabel, {
              "aria-hidden": "true",
              className: labelClasses,
              isFilled: isFilled,
              style: style,
              children: label
            })]
          });
        }

        /**
         * WordPress dependencies
         */
        function RangeRail(props) {
          const {
            disabled = false,
            marks = false,
            min = 0,
            max = 100,
            step = 1,
            value = 0,
            ...restProps
          } = props;
          return /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(Rail, {
              disabled: disabled,
              ...restProps
            }), marks && /*#__PURE__*/jsxRuntimeExports.jsx(Marks, {
              disabled: disabled,
              marks: marks,
              min: min,
              max: max,
              step: step,
              value: value
            })]
          });
        }
        function Marks(props) {
          const {
            disabled = false,
            marks = false,
            min = 0,
            max = 100,
            step: stepProp = 1,
            value = 0
          } = props;
          const step = stepProp === 'any' ? 1 : stepProp;
          const marksData = useMarks({
            marks,
            min,
            max,
            step,
            value
          });
          return /*#__PURE__*/jsxRuntimeExports.jsx(MarksWrapper, {
            "aria-hidden": "true",
            className: "components-range-control__marks",
            children: marksData.map(mark => /*#__PURE__*/reactExports.createElement(RangeMark, {
              ...mark,
              key: mark.key,
              "aria-hidden": "true",
              disabled: disabled
            }))
          });
        }
        function useMarks({
          marks,
          min = 0,
          max = 100,
          step = 1,
          value = 0
        }) {
          if (!marks) {
            return [];
          }
          const range = max - min;
          if (!Array.isArray(marks)) {
            marks = [];
            const count = 1 + Math.round(range / step);
            while (count > marks.push({
              value: step * marks.length + min
            })) {}
          }
          const placedMarks = [];
          marks.forEach((mark, index) => {
            if (mark.value < min || mark.value > max) {
              return;
            }
            const key = `mark-${index}`;
            const isFilled = mark.value <= value;
            const offset = `${(mark.value - min) / range * 100}%`;
            const offsetStyle = {
              [isRTL$1() ? 'right' : 'left']: offset
            };
            placedMarks.push({
              ...mark,
              isFilled,
              key,
              style: offsetStyle
            });
          });
          return placedMarks;
        }

        /**
         * External dependencies
         */
        function SimpleTooltip(props) {
          const {
            className,
            inputRef,
            tooltipPosition,
            show = false,
            style = {},
            value = 0,
            renderTooltipContent = v => v,
            zIndex = 100,
            ...restProps
          } = props;
          const position = useTooltipPosition({
            inputRef,
            tooltipPosition
          });
          const classes = clsx('components-simple-tooltip', className);
          const styles = {
            ...style,
            zIndex
          };
          return /*#__PURE__*/jsxRuntimeExports.jsx(Tooltip, {
            ...restProps,
            "aria-hidden": "false",
            className: classes,
            position: position,
            show: show,
            role: "tooltip",
            style: styles,
            children: renderTooltipContent(value)
          });
        }
        function useTooltipPosition({
          inputRef,
          tooltipPosition
        }) {
          const [position, setPosition] = reactExports.useState();
          const setTooltipPosition = reactExports.useCallback(() => {
            if (inputRef && inputRef.current) {
              setPosition(tooltipPosition);
            }
          }, [tooltipPosition, inputRef]);
          reactExports.useEffect(() => {
            setTooltipPosition();
          }, [setTooltipPosition]);
          reactExports.useEffect(() => {
            window.addEventListener('resize', setTooltipPosition);
            return () => {
              window.removeEventListener('resize', setTooltipPosition);
            };
          });
          return position;
        }

        /**
         * External dependencies
         */
        const noop$3 = () => {};

        /**
         * Computes the value that `RangeControl` should reset to when pressing
         * the reset button.
         */
        function computeResetValue({
          resetFallbackValue,
          initialPosition
        }) {
          if (resetFallbackValue !== undefined) {
            return !Number.isNaN(resetFallbackValue) ? resetFallbackValue : null;
          }
          if (initialPosition !== undefined) {
            return !Number.isNaN(initialPosition) ? initialPosition : null;
          }
          return null;
        }
        function UnforwardedRangeControl(props, forwardedRef) {
          const {
            __nextHasNoMarginBottom = false,
            afterIcon,
            allowReset = false,
            beforeIcon,
            className,
            color: colorProp = COLORS$1.theme.accent,
            currentInput,
            disabled = false,
            help,
            hideLabelFromVision = false,
            initialPosition,
            isShiftStepEnabled = true,
            label,
            marks = false,
            max = 100,
            min = 0,
            onBlur = noop$3,
            onChange = noop$3,
            onFocus = noop$3,
            onMouseLeave = noop$3,
            onMouseMove = noop$3,
            railColor,
            renderTooltipContent = v => v,
            resetFallbackValue,
            __next40pxDefaultSize = false,
            shiftStep = 10,
            showTooltip: showTooltipProp,
            step = 1,
            trackColor,
            value: valueProp,
            withInputField = true,
            __shouldNotWarnDeprecated36pxSize,
            ...otherProps
          } = props;
          const [value, setValue] = useControlledRangeValue({
            min,
            max,
            value: valueProp !== null && valueProp !== void 0 ? valueProp : null,
            initial: initialPosition
          });
          const isResetPendent = reactExports.useRef(false);
          let hasTooltip = showTooltipProp;
          let hasInputField = withInputField;
          if (step === 'any') {
            // The tooltip and number input field are hidden when the step is "any"
            // because the decimals get too lengthy to fit well.
            hasTooltip = false;
            hasInputField = false;
          }
          const [showTooltip, setShowTooltip] = reactExports.useState(hasTooltip);
          const [isFocused, setIsFocused] = reactExports.useState(false);
          const inputRef = reactExports.useRef();
          const isCurrentlyFocused = inputRef.current?.matches(':focus');
          const isThumbFocused = !disabled && isFocused;
          const isValueReset = value === null;
          const currentValue = value !== undefined ? value : currentInput;
          const inputSliderValue = isValueReset ? '' : currentValue;
          const rangeFillValue = isValueReset ? (max - min) / 2 + min : value;
          const fillValue = isValueReset ? 50 : (value - min) / (max - min) * 100;
          const fillValueOffset = `${clamp(fillValue, 0, 100)}%`;
          const classes = clsx('components-range-control', className);
          const wrapperClasses = clsx('components-range-control__wrapper', !!marks && 'is-marked');
          const id = useInstanceId(UnforwardedRangeControl, 'inspector-range-control');
          const describedBy = !!help ? `${id}__help` : undefined;
          const enableTooltip = hasTooltip !== false && Number.isFinite(value);
          const handleOnRangeChange = event => {
            const nextValue = parseFloat(event.target.value);
            setValue(nextValue);
            onChange(nextValue);
          };
          const handleOnChange = next => {
            // @ts-expect-error TODO: Investigate if it's problematic for setValue() to
            // potentially receive a NaN when next is undefined.
            let nextValue = parseFloat(next);
            setValue(nextValue);

            /*
             * Calls onChange only when nextValue is numeric
             * otherwise may queue a reset for the blur event.
             */
            if (!isNaN(nextValue)) {
              if (nextValue < min || nextValue > max) {
                nextValue = floatClamp(nextValue, min, max);
              }
              onChange(nextValue);
              isResetPendent.current = false;
            } else if (allowReset) {
              isResetPendent.current = true;
            }
          };
          const handleOnInputNumberBlur = () => {
            if (isResetPendent.current) {
              handleOnReset();
              isResetPendent.current = false;
            }
          };
          const handleOnReset = () => {
            // Reset to `resetFallbackValue` if defined, otherwise set internal value
            // to `null` — which, if propagated to the `value` prop, will cause
            // the value to be reset to the `initialPosition` prop if defined.
            const resetValue = Number.isNaN(resetFallbackValue) ? null : resetFallbackValue !== null && resetFallbackValue !== void 0 ? resetFallbackValue : null;
            setValue(resetValue);

            /**
             * Previously, this callback would always receive undefined as
             * an argument. This behavior is unexpected, specifically
             * when resetFallbackValue is defined.
             *
             * The value of undefined is not ideal. Passing it through
             * to internal <input /> elements would change it from a
             * controlled component to an uncontrolled component.
             *
             * For now, to minimize unexpected regressions, we're going to
             * preserve the undefined callback argument, except when a
             * resetFallbackValue is defined.
             */
            onChange(resetValue !== null && resetValue !== void 0 ? resetValue : undefined);
          };
          const handleShowTooltip = () => setShowTooltip(true);
          const handleHideTooltip = () => setShowTooltip(false);
          const handleOnBlur = event => {
            onBlur(event);
            setIsFocused(false);
            handleHideTooltip();
          };
          const handleOnFocus = event => {
            onFocus(event);
            setIsFocused(true);
            handleShowTooltip();
          };
          const offsetStyle = {
            [isRTL$1() ? 'right' : 'left']: fillValueOffset
          };

          // Add default size deprecation warning.
          maybeWarnDeprecated36pxSize({
            componentName: 'RangeControl',
            __next40pxDefaultSize,
            size: undefined,
            __shouldNotWarnDeprecated36pxSize
          });
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            __nextHasNoMarginBottom: __nextHasNoMarginBottom,
            __associatedWPComponentName: "RangeControl",
            className: classes,
            label: label,
            hideLabelFromVision: hideLabelFromVision,
            id: `${id}`,
            help: help,
            children: /*#__PURE__*/jsxRuntimeExports.jsxs(Root, {
              className: "components-range-control__root",
              __next40pxDefaultSize: __next40pxDefaultSize,
              children: [beforeIcon && /*#__PURE__*/jsxRuntimeExports.jsx(BeforeIconWrapper, {
                children: /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
                  icon: beforeIcon
                })
              }), /*#__PURE__*/jsxRuntimeExports.jsxs(Wrapper$1, {
                __nextHasNoMarginBottom: __nextHasNoMarginBottom,
                className: wrapperClasses,
                color: colorProp,
                marks: !!marks,
                children: [/*#__PURE__*/jsxRuntimeExports.jsx(ForwardedComponent, {
                  ...otherProps,
                  className: "components-range-control__slider",
                  describedBy: describedBy,
                  disabled: disabled,
                  id: `${id}`,
                  label: label,
                  max: max,
                  min: min,
                  onBlur: handleOnBlur,
                  onChange: handleOnRangeChange,
                  onFocus: handleOnFocus,
                  onMouseMove: onMouseMove,
                  onMouseLeave: onMouseLeave,
                  ref: useMergeRefs$1([inputRef, forwardedRef]),
                  step: step,
                  value: inputSliderValue !== null && inputSliderValue !== void 0 ? inputSliderValue : undefined
                }), /*#__PURE__*/jsxRuntimeExports.jsx(RangeRail, {
                  "aria-hidden": true,
                  disabled: disabled,
                  marks: marks,
                  max: max,
                  min: min,
                  railColor: railColor,
                  step: step,
                  value: rangeFillValue
                }), /*#__PURE__*/jsxRuntimeExports.jsx(Track, {
                  "aria-hidden": true,
                  className: "components-range-control__track",
                  disabled: disabled,
                  style: {
                    width: fillValueOffset
                  },
                  trackColor: trackColor
                }), /*#__PURE__*/jsxRuntimeExports.jsx(ThumbWrapper, {
                  className: "components-range-control__thumb-wrapper",
                  style: offsetStyle,
                  disabled: disabled,
                  children: /*#__PURE__*/jsxRuntimeExports.jsx(Thumb, {
                    "aria-hidden": true,
                    isFocused: isThumbFocused,
                    disabled: disabled
                  })
                }), enableTooltip && /*#__PURE__*/jsxRuntimeExports.jsx(SimpleTooltip, {
                  className: "components-range-control__tooltip",
                  inputRef: inputRef,
                  tooltipPosition: "bottom",
                  renderTooltipContent: renderTooltipContent,
                  show: isCurrentlyFocused || showTooltip,
                  style: offsetStyle,
                  value: value
                })]
              }), afterIcon && /*#__PURE__*/jsxRuntimeExports.jsx(AfterIconWrapper, {
                children: /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
                  icon: afterIcon
                })
              }), hasInputField && /*#__PURE__*/jsxRuntimeExports.jsx(InputNumber, {
                "aria-label": label,
                className: "components-range-control__number",
                disabled: disabled,
                inputMode: "decimal",
                isShiftStepEnabled: isShiftStepEnabled,
                max: max,
                min: min,
                onBlur: handleOnInputNumberBlur,
                onChange: handleOnChange,
                shiftStep: shiftStep,
                size: __next40pxDefaultSize ? '__unstable-large' : 'default',
                __unstableInputWidth: __next40pxDefaultSize ? space(20) : space(16),
                step: step
                // @ts-expect-error TODO: Investigate if the `null` value is necessary
                ,

                value: inputSliderValue
              }), allowReset && /*#__PURE__*/jsxRuntimeExports.jsx(ActionRightWrapper, {
                children: /*#__PURE__*/jsxRuntimeExports.jsx(Button, {
                  className: "components-range-control__reset"
                  // If the RangeControl itself is disabled, the reset button shouldn't be in the tab sequence.
                  ,

                  accessibleWhenDisabled: !disabled
                  // The reset button should be disabled if RangeControl itself is disabled,
                  // or if the current `value` is equal to the value that would be currently
                  // assigned when clicking the button.
                  ,

                  disabled: disabled || value === computeResetValue({
                    resetFallbackValue,
                    initialPosition
                  }),
                  variant: "secondary",
                  size: "small",
                  onClick: handleOnReset,
                  children: __('Reset')
                })
              })]
            })
          });
        }

        /**
         * RangeControls are used to make selections from a range of incremental values.
         *
         * ```jsx
         * import { RangeControl } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyRangeControl = () => {
         *   const [ isChecked, setChecked ] = useState( true );
         *   return (
         *     <RangeControl
         *       __nextHasNoMarginBottom
         *       __next40pxDefaultSize
         *       help="Please select how transparent you would like this."
         *       initialPosition={50}
         *       label="Opacity"
         *       max={100}
         *       min={0}
         *       onChange={() => {}}
         *     />
         *   );
         * };
         * ```
         */
        const RangeControl$1 = reactExports.forwardRef(UnforwardedRangeControl);
        const NumberControlWrapper = /* @__PURE__ */createStyled(NumberControl, {
          target: "ez9hsf46"
        })("width:", space(24), ";" + "");
        const SelectControl = /* @__PURE__ */createStyled(SelectControl$1, {
          target: "ez9hsf45"
        })("margin-left:", space(-2), ";" + "");
        const RangeControl = /* @__PURE__ */createStyled(RangeControl$1, {
          target: "ez9hsf44"
        })("flex:1;margin-right:", space(2), ";" + "");
        const interactiveHueStyles = `
.react-colorful__interactive {
	width: calc( 100% - ${space(2)} );
	margin-left: ${space(1)};
}`;
        const AuxiliaryColorArtefactWrapper = /* @__PURE__ */createStyled("div", {
          target: "ez9hsf43"
        })("padding-top:", space(2), ";padding-right:0;padding-left:0;padding-bottom:0;" + "");
        const AuxiliaryColorArtefactHStackHeader = /* @__PURE__ */createStyled(HStack, {
          target: "ez9hsf42"
        })("padding-left:", space(4), ";padding-right:", space(4), ";" + "");
        const ColorInputWrapper = /* @__PURE__ */createStyled(Flex, {
          target: "ez9hsf41"
        })("padding-top:", space(4), ";padding-left:", space(4), ";padding-right:", space(3), ";padding-bottom:", space(5), ";" + "");
        const ColorfulWrapper = /* @__PURE__ */createStyled("div", {
          target: "ez9hsf40"
        })(boxSizingReset, ";width:216px;.react-colorful{display:flex;flex-direction:column;align-items:center;width:216px;height:auto;}.react-colorful__saturation{width:100%;border-radius:0;height:216px;margin-bottom:", space(4), ";border-bottom:none;}.react-colorful__hue,.react-colorful__alpha{width:184px;height:16px;border-radius:", CONFIG.radiusFull, ";margin-bottom:", space(2), ";}.react-colorful__pointer{height:16px;width:16px;border:none;box-shadow:0 0 2px 0 rgba( 0, 0, 0, 0.25 );outline:2px solid transparent;}.react-colorful__pointer-fill{box-shadow:inset 0 0 0 ", CONFIG.borderWidthFocus, " #fff;}", interactiveHueStyles, ";" + "");

        /**
         * WordPress dependencies
         */
        const ColorCopyButton = props => {
          const {
            color,
            colorType
          } = props;
          const [copiedColor, setCopiedColor] = reactExports.useState(null);
          const copyTimerRef = reactExports.useRef();
          const copyRef = useCopyToClipboard(() => {
            switch (colorType) {
              case 'hsl':
                {
                  return color.toHslString();
                }
              case 'rgb':
                {
                  return color.toRgbString();
                }
              default:
              case 'hex':
                {
                  return color.toHex();
                }
            }
          }, () => {
            if (copyTimerRef.current) {
              clearTimeout(copyTimerRef.current);
            }
            setCopiedColor(color.toHex());
            copyTimerRef.current = setTimeout(() => {
              setCopiedColor(null);
              copyTimerRef.current = undefined;
            }, 3000);
          });
          reactExports.useEffect(() => {
            // Clear copyTimerRef on component unmount.
            return () => {
              if (copyTimerRef.current) {
                clearTimeout(copyTimerRef.current);
              }
            };
          }, []);
          const label = copiedColor === color.toHex() ? __('Copied!') : __('Copy');
          return /*#__PURE__*/jsxRuntimeExports.jsx(Tooltip$1, {
            delay: 0,
            hideOnClick: false,
            text: label,
            children: /*#__PURE__*/jsxRuntimeExports.jsx(Button, {
              size: "compact",
              "aria-label": label,
              ref: copyRef,
              icon: copy$1,
              showTooltip: false
            })
          });
        };

        /**
         * External dependencies
         */

        function UnconnectedInputControlPrefixWrapper(props, forwardedRef) {
          const derivedProps = useContextSystem(props, 'InputControlPrefixWrapper');
          return /*#__PURE__*/jsxRuntimeExports.jsx(PrefixSuffixWrapper, {
            ...derivedProps,
            isPrefix: true,
            ref: forwardedRef
          });
        }

        /**
         * A convenience wrapper for the `prefix` when you want to apply
         * standard padding in accordance with the size variant.
         *
         * ```jsx
         * import {
         *   __experimentalInputControl as InputControl,
         *   __experimentalInputControlPrefixWrapper as InputControlPrefixWrapper,
         * } from '@wordpress/components';
         *
         * <InputControl
         *   prefix={<InputControlPrefixWrapper>@</InputControlPrefixWrapper>}
         * />
         * ```
         */
        const InputControlPrefixWrapper = contextConnect(UnconnectedInputControlPrefixWrapper, 'InputControlPrefixWrapper');

        /**
         * Internal dependencies
         */
        const InputWithSlider = ({
          min,
          max,
          label,
          abbreviation,
          onChange,
          value
        }) => {
          const onNumberControlChange = newValue => {
            if (!newValue) {
              onChange(0);
              return;
            }
            if (typeof newValue === 'string') {
              onChange(parseInt(newValue, 10));
              return;
            }
            onChange(newValue);
          };
          return /*#__PURE__*/jsxRuntimeExports.jsxs(HStack, {
            spacing: 4,
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(NumberControlWrapper, {
              min: min,
              max: max,
              label: label,
              hideLabelFromVision: true,
              value: value,
              onChange: onNumberControlChange,
              prefix: /*#__PURE__*/jsxRuntimeExports.jsx(InputControlPrefixWrapper, {
                children: /*#__PURE__*/jsxRuntimeExports.jsx(Text, {
                  color: COLORS$1.theme.accent,
                  lineHeight: 1,
                  children: abbreviation
                })
              }),
              spinControls: "none",
              size: "__unstable-large"
            }), /*#__PURE__*/jsxRuntimeExports.jsx(RangeControl, {
              __nextHasNoMarginBottom: true,
              __next40pxDefaultSize: true,
              label: label,
              hideLabelFromVision: true,
              min: min,
              max: max,
              value: value
              // @ts-expect-error
              // See: https://github.com/WordPress/gutenberg/pull/40535#issuecomment-1172418185
              ,

              onChange: onChange,
              withInputField: false
            })]
          });
        };

        /**
         * External dependencies
         */
        const RgbInput = ({
          color,
          onChange,
          enableAlpha
        }) => {
          const {
            r,
            g,
            b,
            a
          } = color.toRgb();
          return /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 255,
              label: "Red",
              abbreviation: "R",
              value: r,
              onChange: nextR => onChange(w$1({
                r: nextR,
                g,
                b,
                a
              }))
            }), /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 255,
              label: "Green",
              abbreviation: "G",
              value: g,
              onChange: nextG => onChange(w$1({
                r,
                g: nextG,
                b,
                a
              }))
            }), /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 255,
              label: "Blue",
              abbreviation: "B",
              value: b,
              onChange: nextB => onChange(w$1({
                r,
                g,
                b: nextB,
                a
              }))
            }), enableAlpha && /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 100,
              label: "Alpha",
              abbreviation: "A",
              value: Math.trunc(a * 100),
              onChange: nextA => onChange(w$1({
                r,
                g,
                b,
                a: nextA / 100
              }))
            })]
          });
        };

        /**
         * External dependencies
         */
        const HslInput = ({
          color,
          onChange,
          enableAlpha
        }) => {
          const colorPropHSLA = reactExports.useMemo(() => color.toHsl(), [color]);
          const [internalHSLA, setInternalHSLA] = reactExports.useState({
            ...colorPropHSLA
          });
          const isInternalColorSameAsReceivedColor = color.isEqual(w$1(internalHSLA));
          reactExports.useEffect(() => {
            if (!isInternalColorSameAsReceivedColor) {
              // Keep internal HSLA color up to date with the received color prop
              setInternalHSLA(colorPropHSLA);
            }
          }, [colorPropHSLA, isInternalColorSameAsReceivedColor]);

          // If the internal color is equal to the received color prop, we can use the
          // HSLA values from the local state which, compared to the received color prop,
          // retain more details about the actual H and S values that the user selected,
          // and thus allow for better UX when interacting with the H and S sliders.
          const colorValue = isInternalColorSameAsReceivedColor ? internalHSLA : colorPropHSLA;
          const updateHSLAValue = partialNewValue => {
            const nextOnChangeValue = w$1({
              ...colorValue,
              ...partialNewValue
            });

            // Fire `onChange` only if the resulting color is different from the
            // current one.
            // Otherwise, update the internal HSLA color to cause a re-render.
            if (!color.isEqual(nextOnChangeValue)) {
              onChange(nextOnChangeValue);
            } else {
              setInternalHSLA(prevHSLA => ({
                ...prevHSLA,
                ...partialNewValue
              }));
            }
          };
          return /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 359,
              label: "Hue",
              abbreviation: "H",
              value: colorValue.h,
              onChange: nextH => {
                updateHSLAValue({
                  h: nextH
                });
              }
            }), /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 100,
              label: "Saturation",
              abbreviation: "S",
              value: colorValue.s,
              onChange: nextS => {
                updateHSLAValue({
                  s: nextS
                });
              }
            }), /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 100,
              label: "Lightness",
              abbreviation: "L",
              value: colorValue.l,
              onChange: nextL => {
                updateHSLAValue({
                  l: nextL
                });
              }
            }), enableAlpha && /*#__PURE__*/jsxRuntimeExports.jsx(InputWithSlider, {
              min: 0,
              max: 100,
              label: "Alpha",
              abbreviation: "A",
              value: Math.trunc(100 * colorValue.a),
              onChange: nextA => {
                updateHSLAValue({
                  a: nextA / 100
                });
              }
            })]
          });
        };

        /**
         * External dependencies
         */
        const HexInput = ({
          color,
          onChange,
          enableAlpha
        }) => {
          const handleChange = nextValue => {
            if (!nextValue) {
              return;
            }
            const hexValue = nextValue.startsWith('#') ? nextValue : '#' + nextValue;
            onChange(w$1(hexValue));
          };
          const stateReducer = (state, action) => {
            const nativeEvent = action.payload?.event?.nativeEvent;
            if ('insertFromPaste' !== nativeEvent?.inputType) {
              return {
                ...state
              };
            }
            const value = state.value?.startsWith('#') ? state.value.slice(1).toUpperCase() : state.value?.toUpperCase();
            return {
              ...state,
              value
            };
          };
          return /*#__PURE__*/jsxRuntimeExports.jsx(InputControl, {
            prefix: /*#__PURE__*/jsxRuntimeExports.jsx(InputControlPrefixWrapper, {
              children: /*#__PURE__*/jsxRuntimeExports.jsx(Text, {
                color: COLORS$1.theme.accent,
                lineHeight: 1,
                children: "#"
              })
            }),
            value: color.toHex().slice(1).toUpperCase(),
            onChange: handleChange,
            maxLength: enableAlpha ? 9 : 7,
            label: __('Hex color'),
            hideLabelFromVision: true,
            size: "__unstable-large",
            __unstableStateReducer: stateReducer,
            __unstableInputWidth: "9em"
          });
        };

        /**
         * Internal dependencies
         */
        const ColorInput = ({
          colorType,
          color,
          onChange,
          enableAlpha
        }) => {
          const props = {
            color,
            onChange,
            enableAlpha
          };
          switch (colorType) {
            case 'hsl':
              return /*#__PURE__*/jsxRuntimeExports.jsx(HslInput, {
                ...props
              });
            case 'rgb':
              return /*#__PURE__*/jsxRuntimeExports.jsx(RgbInput, {
                ...props
              });
            default:
            case 'hex':
              return /*#__PURE__*/jsxRuntimeExports.jsx(HexInput, {
                ...props
              });
          }
        };
        function u() {
          return (u = Object.assign || function (e) {
            for (var r = 1; r < arguments.length; r++) {
              var t = arguments[r];
              for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }
            return e;
          }).apply(this, arguments);
        }
        function c(e, r) {
          if (null == e) return {};
          var t,
            n,
            o = {},
            a = Object.keys(e);
          for (n = 0; n < a.length; n++) r.indexOf(t = a[n]) >= 0 || (o[t] = e[t]);
          return o;
        }
        function i(e) {
          var t = reactExports.useRef(e),
            n = reactExports.useRef(function (e) {
              t.current && t.current(e);
            });
          return t.current = e, n.current;
        }
        var s = function (e, r, t) {
            return void 0 === r && (r = 0), void 0 === t && (t = 1), e > t ? t : e < r ? r : e;
          },
          f$1 = function (e) {
            return "touches" in e;
          },
          v$1 = function (e) {
            return e && e.ownerDocument.defaultView || self;
          },
          d = function (e, r, t) {
            var n = e.getBoundingClientRect(),
              o = f$1(r) ? function (e, r) {
                for (var t = 0; t < e.length; t++) if (e[t].identifier === r) return e[t];
                return e[0];
              }(r.touches, t) : r;
            return {
              left: s((o.pageX - (n.left + v$1(e).pageXOffset)) / n.width),
              top: s((o.pageY - (n.top + v$1(e).pageYOffset)) / n.height)
            };
          },
          h = function (e) {
            !f$1(e) && e.preventDefault();
          },
          m$1 = React$1.memo(function (o) {
            var a = o.onMove,
              l = o.onKey,
              s = c(o, ["onMove", "onKey"]),
              m = reactExports.useRef(null),
              g = i(a),
              p = i(l),
              b = reactExports.useRef(null),
              _ = reactExports.useRef(false),
              x = reactExports.useMemo(function () {
                var e = function (e) {
                    h(e), (f$1(e) ? e.touches.length > 0 : e.buttons > 0) && m.current ? g(d(m.current, e, b.current)) : t(false);
                  },
                  r = function () {
                    return t(false);
                  };
                function t(t) {
                  var n = _.current,
                    o = v$1(m.current),
                    a = t ? o.addEventListener : o.removeEventListener;
                  a(n ? "touchmove" : "mousemove", e), a(n ? "touchend" : "mouseup", r);
                }
                return [function (e) {
                  var r = e.nativeEvent,
                    n = m.current;
                  if (n && (h(r), !function (e, r) {
                    return r && !f$1(e);
                  }(r, _.current) && n)) {
                    if (f$1(r)) {
                      _.current = true;
                      var o = r.changedTouches || [];
                      o.length && (b.current = o[0].identifier);
                    }
                    n.focus(), g(d(n, r, b.current)), t(true);
                  }
                }, function (e) {
                  var r = e.which || e.keyCode;
                  r < 37 || r > 40 || (e.preventDefault(), p({
                    left: 39 === r ? .05 : 37 === r ? -0.05 : 0,
                    top: 40 === r ? .05 : 38 === r ? -0.05 : 0
                  }));
                }, t];
              }, [p, g]),
              C = x[0],
              E = x[1],
              H = x[2];
            return reactExports.useEffect(function () {
              return H;
            }, [H]), React$1.createElement("div", u({}, s, {
              onTouchStart: C,
              onMouseDown: C,
              className: "react-colorful__interactive",
              ref: m,
              onKeyDown: E,
              tabIndex: 0,
              role: "slider"
            }));
          }),
          g$1 = function (e) {
            return e.filter(Boolean).join(" ");
          },
          p = function (r) {
            var t = r.color,
              n = r.left,
              o = r.top,
              a = void 0 === o ? .5 : o,
              l = g$1(["react-colorful__pointer", r.className]);
            return React$1.createElement("div", {
              className: l,
              style: {
                top: 100 * a + "%",
                left: 100 * n + "%"
              }
            }, React$1.createElement("div", {
              className: "react-colorful__pointer-fill",
              style: {
                backgroundColor: t
              }
            }));
          },
          b = function (e, r, t) {
            return void 0 === r && (r = 0), void 0 === t && (t = Math.pow(10, r)), Math.round(t * e) / t;
          },
          y$1 = function (e) {
            var r = e.s,
              t = e.v,
              n = e.a,
              o = (200 - r) * t / 100;
            return {
              h: b(e.h),
              s: b(o > 0 && o < 200 ? r * t / 100 / (o <= 100 ? o : 200 - o) * 100 : 0),
              l: b(o / 2),
              a: b(n, 2)
            };
          },
          q$1 = function (e) {
            var r = y$1(e);
            return "hsl(" + r.h + ", " + r.s + "%, " + r.l + "%)";
          },
          k$1 = function (e) {
            var r = y$1(e);
            return "hsla(" + r.h + ", " + r.s + "%, " + r.l + "%, " + r.a + ")";
          },
          I$1 = function (e) {
            var r = e.h,
              t = e.s,
              n = e.v,
              o = e.a;
            r = r / 360 * 6, t /= 100, n /= 100;
            var a = Math.floor(r),
              l = n * (1 - t),
              u = n * (1 - (r - a) * t),
              c = n * (1 - (1 - r + a) * t),
              i = a % 6;
            return {
              r: b(255 * [n, u, l, l, c, n][i]),
              g: b(255 * [c, n, n, u, l, l][i]),
              b: b(255 * [l, l, c, n, n, u][i]),
              a: b(o, 2)
            };
          },
          z$1 = function (e) {
            var r = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i.exec(e);
            return r ? L$1({
              r: Number(r[1]) / (r[2] ? 100 / 255 : 1),
              g: Number(r[3]) / (r[4] ? 100 / 255 : 1),
              b: Number(r[5]) / (r[6] ? 100 / 255 : 1),
              a: void 0 === r[7] ? 1 : Number(r[7]) / (r[8] ? 100 : 1)
            }) : {
              h: 0,
              s: 0,
              v: 0,
              a: 1
            };
          },
          B$1 = z$1,
          L$1 = function (e) {
            var r = e.r,
              t = e.g,
              n = e.b,
              o = e.a,
              a = Math.max(r, t, n),
              l = a - Math.min(r, t, n),
              u = l ? a === r ? (t - n) / l : a === t ? 2 + (n - r) / l : 4 + (r - t) / l : 0;
            return {
              h: b(60 * (u < 0 ? u + 6 : u)),
              s: b(a ? l / a * 100 : 0),
              v: b(a / 255 * 100),
              a: o
            };
          },
          S$1 = React$1.memo(function (r) {
            var t = r.hue,
              n = r.onChange,
              o = g$1(["react-colorful__hue", r.className]);
            return React$1.createElement("div", {
              className: o
            }, React$1.createElement(m$1, {
              onMove: function (e) {
                n({
                  h: 360 * e.left
                });
              },
              onKey: function (e) {
                n({
                  h: s(t + 360 * e.left, 0, 360)
                });
              },
              "aria-label": "Hue",
              "aria-valuenow": b(t),
              "aria-valuemax": "360",
              "aria-valuemin": "0"
            }, React$1.createElement(p, {
              className: "react-colorful__hue-pointer",
              left: t / 360,
              color: q$1({
                h: t,
                s: 100,
                v: 100,
                a: 1
              })
            })));
          }),
          T$1 = React$1.memo(function (r) {
            var t = r.hsva,
              n = r.onChange,
              o = {
                backgroundColor: q$1({
                  h: t.h,
                  s: 100,
                  v: 100,
                  a: 1
                })
              };
            return React$1.createElement("div", {
              className: "react-colorful__saturation",
              style: o
            }, React$1.createElement(m$1, {
              onMove: function (e) {
                n({
                  s: 100 * e.left,
                  v: 100 - 100 * e.top
                });
              },
              onKey: function (e) {
                n({
                  s: s(t.s + 100 * e.left, 0, 100),
                  v: s(t.v - 100 * e.top, 0, 100)
                });
              },
              "aria-label": "Color",
              "aria-valuetext": "Saturation " + b(t.s) + "%, Brightness " + b(t.v) + "%"
            }, React$1.createElement(p, {
              className: "react-colorful__saturation-pointer",
              top: 1 - t.v / 100,
              left: t.s / 100,
              color: q$1(t)
            })));
          }),
          F$1 = function (e, r) {
            if (e === r) return true;
            for (var t in e) if (e[t] !== r[t]) return false;
            return true;
          },
          P = function (e, r) {
            return e.replace(/\s/g, "") === r.replace(/\s/g, "");
          };
        function Y$1(e, t, l) {
          var u = i(l),
            c = reactExports.useState(function () {
              return e.toHsva(t);
            }),
            s = c[0],
            f = c[1],
            v = reactExports.useRef({
              color: t,
              hsva: s
            });
          reactExports.useEffect(function () {
            if (!e.equal(t, v.current.color)) {
              var r = e.toHsva(t);
              v.current = {
                hsva: r,
                color: t
              }, f(r);
            }
          }, [t, e]), reactExports.useEffect(function () {
            var r;
            F$1(s, v.current.hsva) || e.equal(r = e.fromHsva(s), v.current.color) || (v.current = {
              hsva: s,
              color: r
            }, u(r));
          }, [s, e, u]);
          var d = reactExports.useCallback(function (e) {
            f(function (r) {
              return Object.assign({}, r, e);
            });
          }, []);
          return [s, d];
        }
        var V$1 = "undefined" != typeof window ? reactExports.useLayoutEffect : reactExports.useEffect,
          $$1 = function () {
            return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : void 0;
          },
          J$1 = new Map(),
          Q$1 = function (e) {
            V$1(function () {
              var r = e.current ? e.current.ownerDocument : document;
              if (void 0 !== r && !J$1.has(r)) {
                var t = r.createElement("style");
                t.innerHTML = '.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}', J$1.set(r, t);
                var n = $$1();
                n && t.setAttribute("nonce", n), r.head.appendChild(t);
              }
            }, []);
          },
          U$1 = function (t) {
            var n = t.className,
              o = t.colorModel,
              a = t.color,
              l = void 0 === a ? o.defaultColor : a,
              i = t.onChange,
              s = c(t, ["className", "colorModel", "color", "onChange"]),
              f = reactExports.useRef(null);
            Q$1(f);
            var v = Y$1(o, l, i),
              d = v[0],
              h = v[1],
              m = g$1(["react-colorful", n]);
            return React$1.createElement("div", u({}, s, {
              ref: f,
              className: m
            }), React$1.createElement(T$1, {
              hsva: d,
              onChange: h
            }), React$1.createElement(S$1, {
              hue: d.h,
              onChange: h,
              className: "react-colorful__last-control"
            }));
          },
          ee$1 = function (r) {
            var t = r.className,
              n = r.hsva,
              o = r.onChange,
              a = {
                backgroundImage: "linear-gradient(90deg, " + k$1(Object.assign({}, n, {
                  a: 0
                })) + ", " + k$1(Object.assign({}, n, {
                  a: 1
                })) + ")"
              },
              l = g$1(["react-colorful__alpha", t]),
              u = b(100 * n.a);
            return React$1.createElement("div", {
              className: l
            }, React$1.createElement("div", {
              className: "react-colorful__alpha-gradient",
              style: a
            }), React$1.createElement(m$1, {
              onMove: function (e) {
                o({
                  a: e.left
                });
              },
              onKey: function (e) {
                o({
                  a: s(n.a + e.left)
                });
              },
              "aria-label": "Alpha",
              "aria-valuetext": u + "%",
              "aria-valuenow": u,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, React$1.createElement(p, {
              className: "react-colorful__alpha-pointer",
              left: n.a,
              color: k$1(n)
            })));
          },
          re$1 = function (t) {
            var n = t.className,
              o = t.colorModel,
              a = t.color,
              l = void 0 === a ? o.defaultColor : a,
              i = t.onChange,
              s = c(t, ["className", "colorModel", "color", "onChange"]),
              f = reactExports.useRef(null);
            Q$1(f);
            var v = Y$1(o, l, i),
              d = v[0],
              h = v[1],
              m = g$1(["react-colorful", n]);
            return React$1.createElement("div", u({}, s, {
              ref: f,
              className: m
            }), React$1.createElement(T$1, {
              hsva: d,
              onChange: h
            }), React$1.createElement(S$1, {
              hue: d.h,
              onChange: h
            }), React$1.createElement(ee$1, {
              hsva: d,
              onChange: h,
              className: "react-colorful__last-control"
            }));
          },
          Ee$1 = {
            defaultColor: "rgba(0, 0, 0, 1)",
            toHsva: z$1,
            fromHsva: function (e) {
              var r = I$1(e);
              return "rgba(" + r.r + ", " + r.g + ", " + r.b + ", " + r.a + ")";
            },
            equal: P
          },
          He$1 = function (r) {
            return React$1.createElement(re$1, u({}, r, {
              colorModel: Ee$1
            }));
          },
          we$1 = {
            defaultColor: "rgb(0, 0, 0)",
            toHsva: B$1,
            fromHsva: function (e) {
              var r = I$1(e);
              return "rgb(" + r.r + ", " + r.g + ", " + r.b + ")";
            },
            equal: P
          },
          ye$1 = function (r) {
            return React$1.createElement(U$1, u({}, r, {
              colorModel: we$1
            }));
          };

        /**
         * External dependencies
         */
        const Picker = ({
          color,
          enableAlpha,
          onChange
        }) => {
          const Component = enableAlpha ? He$1 : ye$1;
          const rgbColor = reactExports.useMemo(() => color.toRgbString(), [color]);
          return /*#__PURE__*/jsxRuntimeExports.jsx(Component, {
            color: rgbColor,
            onChange: nextColor => {
              onChange(w$1(nextColor));
            }
            // Pointer capture fortifies drag gestures so that they continue to
            // work while dragging outside the component over objects like
            // iframes. If a newer version of react-colorful begins to employ
            // pointer capture this will be redundant and should be removed.
            ,

            onPointerDown: ({
              currentTarget,
              pointerId
            }) => {
              currentTarget.setPointerCapture(pointerId);
            },
            onPointerUp: ({
              currentTarget,
              pointerId
            }) => {
              currentTarget.releasePointerCapture(pointerId);
            }
          });
        };

        /**
         * External dependencies
         */

        k$2([namesPlugin]);
        const options = [{
          label: 'RGB',
          value: 'rgb'
        }, {
          label: 'HSL',
          value: 'hsl'
        }, {
          label: 'Hex',
          value: 'hex'
        }];
        const UnconnectedColorPicker = (props, forwardedRef) => {
          const {
            enableAlpha = false,
            color: colorProp,
            onChange,
            defaultValue = '#fff',
            copyFormat,
            ...divProps
          } = useContextSystem(props, 'ColorPicker');

          // Use a safe default value for the color and remove the possibility of `undefined`.
          const [color, setColor] = useControlledValue({
            onChange,
            value: colorProp,
            defaultValue
          });
          const safeColordColor = reactExports.useMemo(() => {
            return w$1(color || '');
          }, [color]);
          const debouncedSetColor = useDebounce(setColor);
          const handleChange = reactExports.useCallback(nextValue => {
            debouncedSetColor(nextValue.toHex());
          }, [debouncedSetColor]);
          const [colorType, setColorType] = reactExports.useState(copyFormat || 'hex');
          return /*#__PURE__*/jsxRuntimeExports.jsxs(ColorfulWrapper, {
            ref: forwardedRef,
            ...divProps,
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(Picker, {
              onChange: handleChange,
              color: safeColordColor,
              enableAlpha: enableAlpha
            }), /*#__PURE__*/jsxRuntimeExports.jsxs(AuxiliaryColorArtefactWrapper, {
              children: [/*#__PURE__*/jsxRuntimeExports.jsxs(AuxiliaryColorArtefactHStackHeader, {
                justify: "space-between",
                children: [/*#__PURE__*/jsxRuntimeExports.jsx(SelectControl, {
                  __nextHasNoMarginBottom: true,
                  size: "compact",
                  options: options,
                  value: colorType,
                  onChange: nextColorType => setColorType(nextColorType),
                  label: __('Color format'),
                  hideLabelFromVision: true,
                  variant: "minimal"
                }), /*#__PURE__*/jsxRuntimeExports.jsx(ColorCopyButton, {
                  color: safeColordColor,
                  colorType: copyFormat || colorType
                })]
              }), /*#__PURE__*/jsxRuntimeExports.jsx(ColorInputWrapper, {
                direction: "column",
                gap: 2,
                children: /*#__PURE__*/jsxRuntimeExports.jsx(ColorInput, {
                  colorType: colorType,
                  color: safeColordColor,
                  onChange: handleChange,
                  enableAlpha: enableAlpha
                })
              })]
            })]
          });
        };
        const ColorPicker = contextConnect(UnconnectedColorPicker, 'ColorPicker');

        /**
         * External dependencies
         */

        /**
         * Internal dependencies
         */

        function isLegacyProps(props) {
          return typeof props.onChangeComplete !== 'undefined' || typeof props.disableAlpha !== 'undefined' || typeof props.color?.hex === 'string';
        }
        function getColorFromLegacyProps(color) {
          if (color === undefined) {
            return;
          }
          if (typeof color === 'string') {
            return color;
          }
          if (color.hex) {
            return color.hex;
          }
          return undefined;
        }
        const transformColorStringToLegacyColor = memize(color => {
          const colordColor = w$1(color);
          const hex = colordColor.toHex();
          const rgb = colordColor.toRgb();
          const hsv = colordColor.toHsv();
          const hsl = colordColor.toHsl();
          return {
            hex,
            rgb,
            hsv,
            hsl,
            source: 'hex',
            oldHue: hsl.h
          };
        });
        function useDeprecatedProps$1(props) {
          const {
            onChangeComplete
          } = props;
          const legacyChangeHandler = reactExports.useCallback(color => {
            onChangeComplete(transformColorStringToLegacyColor(color));
          }, [onChangeComplete]);
          if (isLegacyProps(props)) {
            return {
              color: getColorFromLegacyProps(props.color),
              enableAlpha: !props.disableAlpha,
              onChange: legacyChangeHandler
            };
          }
          return {
            ...props,
            color: props.color,
            enableAlpha: props.enableAlpha,
            onChange: props.onChange
          };
        }

        /**
         * Internal dependencies
         */
        const LegacyAdapter = props => {
          return /*#__PURE__*/jsxRuntimeExports.jsx(ColorPicker, {
            ...useDeprecatedProps$1(props)
          });
        };

        /**
         * Internal dependencies
         */

        function useHeading(props) {
          const {
            as: asProp,
            level = 2,
            color = COLORS$1.gray[900],
            isBlock = true,
            weight = CONFIG.fontWeightHeading,
            ...otherProps
          } = useContextSystem(props, 'Heading');
          const as = asProp || `h${level}`;
          const a11yProps = {};
          if (typeof as === 'string' && as[0] !== 'h') {
            // If not a semantic `h` element, add a11y props:
            a11yProps.role = 'heading';
            a11yProps['aria-level'] = typeof level === 'string' ? parseInt(level) : level;
          }
          const textProps = useText({
            color,
            isBlock,
            weight,
            size: getHeadingFontSize(level),
            ...otherProps
          });
          return {
            ...textProps,
            ...a11yProps,
            as
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedHeading(props, forwardedRef) {
          const headerProps = useHeading(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...headerProps,
            ref: forwardedRef
          });
        }

        /**
         * `Heading` renders headings and titles using the library's typography system.
         *
         * ```jsx
         * import { __experimentalHeading as Heading } from "@wordpress/components";
         *
         * function Example() {
         *   return <Heading>Code is Poetry</Heading>;
         * }
         * ```
         */
        const Heading = contextConnect(UnconnectedHeading, 'Heading');

        /**
         * External dependencies
         */

        const ALIGNMENTS = {
          bottom: {
            alignItems: 'flex-end',
            justifyContent: 'center'
          },
          bottomLeft: {
            alignItems: 'flex-start',
            justifyContent: 'flex-end'
          },
          bottomRight: {
            alignItems: 'flex-end',
            justifyContent: 'flex-end'
          },
          center: {
            alignItems: 'center',
            justifyContent: 'center'
          },
          spaced: {
            alignItems: 'center',
            justifyContent: 'space-between'
          },
          left: {
            alignItems: 'center',
            justifyContent: 'flex-start'
          },
          right: {
            alignItems: 'center',
            justifyContent: 'flex-end'
          },
          stretch: {
            alignItems: 'stretch'
          },
          top: {
            alignItems: 'flex-start',
            justifyContent: 'center'
          },
          topLeft: {
            alignItems: 'flex-start',
            justifyContent: 'flex-start'
          },
          topRight: {
            alignItems: 'flex-start',
            justifyContent: 'flex-end'
          }
        };
        function getAlignmentProps(alignment) {
          const alignmentProps = alignment ? ALIGNMENTS[alignment] : {};
          return alignmentProps;
        }
        function useGrid(props) {
          const {
            align,
            alignment,
            className,
            columnGap,
            columns = 2,
            gap = 3,
            isInline = false,
            justify,
            rowGap,
            rows,
            templateColumns,
            templateRows,
            ...otherProps
          } = useContextSystem(props, "Grid");
          const columnsAsArray = Array.isArray(columns) ? columns : [columns];
          const column = useResponsiveValue(columnsAsArray);
          const rowsAsArray = Array.isArray(rows) ? rows : [rows];
          const row = useResponsiveValue(rowsAsArray);
          const gridTemplateColumns = templateColumns || !!columns && `repeat( ${column}, 1fr )`;
          const gridTemplateRows = templateRows || !!rows && `repeat( ${row}, 1fr )`;
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            const alignmentProps = getAlignmentProps(alignment);
            const gridClasses = /* @__PURE__ */css({
              alignItems: align,
              display: isInline ? "inline-grid" : "grid",
              gap: `calc( ${CONFIG.gridBase} * ${gap} )`,
              gridTemplateColumns: gridTemplateColumns || void 0,
              gridTemplateRows: gridTemplateRows || void 0,
              gridRowGap: rowGap,
              gridColumnGap: columnGap,
              justifyContent: justify,
              verticalAlign: isInline ? "middle" : void 0,
              ...alignmentProps
            }, "", "");
            return cx(gridClasses, className);
          }, [align, alignment, className, columnGap, cx, gap, gridTemplateColumns, gridTemplateRows, isInline, justify, rowGap]);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedGrid(props, forwardedRef) {
          const gridProps = useGrid(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...gridProps,
            ref: forwardedRef
          });
        }

        /**
         * `Grid` is a primitive layout component that can arrange content in a grid configuration.
         *
         * ```jsx
         * import {
         * 	__experimentalGrid as Grid,
         * 	__experimentalText as Text
         * } from `@wordpress/components`;
         *
         * function Example() {
         * 	return (
         * 		<Grid columns={ 3 }>
         * 			<Text>Code</Text>
         * 			<Text>is</Text>
         * 			<Text>Poetry</Text>
         * 		</Grid>
         * 	);
         * }
         * ```
         */
        const Grid = contextConnect(UnconnectedGrid, 'Grid');

        /**
         * External dependencies
         */
        function UnforwardedButtonGroup(props, ref) {
          const {
            className,
            ...restProps
          } = props;
          const classes = clsx('components-button-group', className);
          return /*#__PURE__*/jsxRuntimeExports.jsx("div", {
            ref: ref,
            role: "group",
            className: classes,
            ...restProps
          });
        }

        /**
         * ButtonGroup can be used to group any related buttons together. To emphasize
         * related buttons, a group should share a common container.
         *
         * ```jsx
         * import { Button, ButtonGroup } from '@wordpress/components';
         *
         * const MyButtonGroup = () => (
         *   <ButtonGroup>
         *     <Button variant="primary">Button 1</Button>
         *     <Button variant="primary">Button 2</Button>
         *   </ButtonGroup>
         * );
         * ```
         */
        const ButtonGroup = reactExports.forwardRef(UnforwardedButtonGroup);
        const Elevation$1 = {
          name: "12ip69d",
          styles: "background:transparent;display:block;margin:0!important;pointer-events:none;position:absolute;will-change:box-shadow"
        };
        function getBoxShadow(value) {
          const boxShadowColor = `rgba(0, 0, 0, ${value / 20})`;
          const boxShadow = `0 ${value}px ${value * 2}px 0
	${boxShadowColor}`;
          return boxShadow;
        }
        function useElevation(props) {
          const {
            active,
            borderRadius = "inherit",
            className,
            focus,
            hover,
            isInteractive = false,
            offset = 0,
            value = 0,
            ...otherProps
          } = useContextSystem(props, "Elevation");
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            let hoverValue = isValueDefined(hover) ? hover : value * 2;
            let activeValue = isValueDefined(active) ? active : value / 2;
            if (!isInteractive) {
              hoverValue = isValueDefined(hover) ? hover : void 0;
              activeValue = isValueDefined(active) ? active : void 0;
            }
            const transition = `box-shadow ${CONFIG.transitionDuration} ${CONFIG.transitionTimingFunction}`;
            const sx = {};
            sx.Base = /* @__PURE__ */css({
              borderRadius,
              bottom: offset,
              boxShadow: getBoxShadow(value),
              opacity: CONFIG.elevationIntensity,
              left: offset,
              right: offset,
              top: offset
            }, /* @__PURE__ */css("@media not ( prefers-reduced-motion ){transition:", transition, ";}" + "", ""), "", "");
            if (isValueDefined(hoverValue)) {
              sx.hover = /* @__PURE__ */css("*:hover>&{box-shadow:", getBoxShadow(hoverValue), ";}" + "", "");
            }
            if (isValueDefined(activeValue)) {
              sx.active = /* @__PURE__ */css("*:active>&{box-shadow:", getBoxShadow(activeValue), ";}" + "", "");
            }
            if (isValueDefined(focus)) {
              sx.focus = /* @__PURE__ */css("*:focus>&{box-shadow:", getBoxShadow(focus), ";}" + "", "");
            }
            return cx(Elevation$1, sx.Base, sx.hover, sx.focus, sx.active, className);
          }, [active, borderRadius, className, cx, focus, hover, isInteractive, offset, value]);
          return {
            ...otherProps,
            className: classes,
            "aria-hidden": true
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedElevation(props, forwardedRef) {
          const elevationProps = useElevation(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...elevationProps,
            ref: forwardedRef
          });
        }

        /**
         * `Elevation` is a core component that renders shadow, using the component
         * system's shadow system.
         *
         * The shadow effect is generated using the `value` prop.
         *
         * ```jsx
         * import {
         *	__experimentalElevation as Elevation,
         *	__experimentalSurface as Surface,
         *	__experimentalText as Text,
         * } from '@wordpress/components';
         *
         * function Example() {
         *   return (
         *     <Surface>
         *       <Text>Code is Poetry</Text>
         *       <Elevation value={ 5 } />
         *     </Surface>
         *   );
         * }
         * ```
         */
        const Elevation = contextConnect(UnconnectedElevation, 'Elevation');
        const adjustedBorderRadius = `calc(${CONFIG.radiusLarge} - 1px)`;
        const Card$1 = /* @__PURE__ */css("box-shadow:0 0 0 1px ", CONFIG.surfaceBorderColor, ";outline:none;" + "", "");
        const Header = {
          name: "1showjb",
          styles: "border-bottom:1px solid;box-sizing:border-box;&:last-child{border-bottom:none;}"
        };
        const Footer = {
          name: "14n5oej",
          styles: "border-top:1px solid;box-sizing:border-box;&:first-of-type{border-top:none;}"
        };
        const Content = {
          name: "13udsys",
          styles: "height:100%"
        };
        const Body = {
          name: "6ywzd",
          styles: "box-sizing:border-box;height:auto;max-height:100%"
        };
        const Divider$1 = {
          name: "c990dr",
          styles: "box-sizing:border-box;display:block;width:100%"
        };
        const borderRadius = /* @__PURE__ */css("&:first-of-type{border-top-left-radius:", adjustedBorderRadius, ";border-top-right-radius:", adjustedBorderRadius, ";}&:last-of-type{border-bottom-left-radius:", adjustedBorderRadius, ";border-bottom-right-radius:", adjustedBorderRadius, ";}" + "", "");
        const borderColor = /* @__PURE__ */css("border-color:", CONFIG.colorDivider, ";" + "", "");
        const boxShadowless = {
          name: "1t90u8d",
          styles: "box-shadow:none"
        };
        const borderless = {
          name: "1e1ncky",
          styles: "border:none"
        };
        const rounded = /* @__PURE__ */css("border-radius:", adjustedBorderRadius, ";" + "", "");
        const xSmallCardPadding = /* @__PURE__ */css("padding:", CONFIG.cardPaddingXSmall, ";" + "", "");
        const cardPaddings = {
          large: /* @__PURE__ */css("padding:", CONFIG.cardPaddingLarge, ";" + "", ""),
          medium: /* @__PURE__ */css("padding:", CONFIG.cardPaddingMedium, ";" + "", ""),
          small: /* @__PURE__ */css("padding:", CONFIG.cardPaddingSmall, ";" + "", ""),
          xSmall: xSmallCardPadding,
          // The `extraSmall` size is not officially documented, but the following styles
          // are kept for legacy reasons to support older values of the `size` prop.
          extraSmall: xSmallCardPadding
        };
        const shady = /* @__PURE__ */css("background-color:", COLORS$1.ui.backgroundDisabled, ";" + "", "");
        const Surface = /* @__PURE__ */css("background-color:", CONFIG.surfaceColor, ";color:", COLORS$1.gray[900], ";position:relative;" + "", "");
        /* @__PURE__ */
        css("background-color:", CONFIG.surfaceBackgroundColor, ";" + "", "");
        function getBorders({
          borderBottom,
          borderLeft,
          borderRight,
          borderTop
        }) {
          const borderStyle = `1px solid ${CONFIG.surfaceBorderColor}`;
          return /* @__PURE__ */css({
            borderBottom: borderBottom ? borderStyle : void 0,
            borderLeft: borderLeft ? borderStyle : void 0,
            borderRight: borderRight ? borderStyle : void 0,
            borderTop: borderTop ? borderStyle : void 0
          }, "", "");
        }
        const primary = /* @__PURE__ */css("", "");
        const secondary = /* @__PURE__ */css("background:", CONFIG.surfaceBackgroundTintColor, ";" + "", "");
        const tertiary = /* @__PURE__ */css("background:", CONFIG.surfaceBackgroundTertiaryColor, ";" + "", "");
        const customBackgroundSize = surfaceBackgroundSize => [surfaceBackgroundSize, surfaceBackgroundSize].join(" ");
        const dottedBackground1 = surfaceBackgroundSizeDotted => ["90deg", [CONFIG.surfaceBackgroundColor, surfaceBackgroundSizeDotted].join(" "), "transparent 1%"].join(",");
        const dottedBackground2 = surfaceBackgroundSizeDotted => [[CONFIG.surfaceBackgroundColor, surfaceBackgroundSizeDotted].join(" "), "transparent 1%"].join(",");
        const dottedBackgroundCombined = surfaceBackgroundSizeDotted => [`linear-gradient( ${dottedBackground1(surfaceBackgroundSizeDotted)} ) center`, `linear-gradient( ${dottedBackground2(surfaceBackgroundSizeDotted)} ) center`, CONFIG.surfaceBorderBoldColor].join(",");
        const getDotted = (surfaceBackgroundSize, surfaceBackgroundSizeDotted) => /* @__PURE__ */css("background:", dottedBackgroundCombined(surfaceBackgroundSizeDotted), ";background-size:", customBackgroundSize(surfaceBackgroundSize), ";" + "", "");
        const gridBackground1 = [`${CONFIG.surfaceBorderSubtleColor} 1px`, "transparent 1px"].join(",");
        const gridBackground2 = ["90deg", `${CONFIG.surfaceBorderSubtleColor} 1px`, "transparent 1px"].join(",");
        const gridBackgroundCombined = [`linear-gradient( ${gridBackground1} )`, `linear-gradient( ${gridBackground2} )`].join(",");
        const getGrid = surfaceBackgroundSize => {
          return /* @__PURE__ */css("background:", CONFIG.surfaceBackgroundColor, ";background-image:", gridBackgroundCombined, ";background-size:", customBackgroundSize(surfaceBackgroundSize), ";" + "", "");
        };
        const getVariant = (variant, surfaceBackgroundSize, surfaceBackgroundSizeDotted) => {
          switch (variant) {
            case "dotted":
              {
                return getDotted(surfaceBackgroundSize, surfaceBackgroundSizeDotted);
              }
            case "grid":
              {
                return getGrid(surfaceBackgroundSize);
              }
            case "primary":
              {
                return primary;
              }
            case "secondary":
              {
                return secondary;
              }
            case "tertiary":
              {
                return tertiary;
              }
          }
        };

        /**
         * WordPress dependencies
         */
        function useSurface(props) {
          const {
            backgroundSize = 12,
            borderBottom = false,
            borderLeft = false,
            borderRight = false,
            borderTop = false,
            className,
            variant = 'primary',
            ...otherProps
          } = useContextSystem(props, 'Surface');
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            const sx = {
              borders: getBorders({
                borderBottom,
                borderLeft,
                borderRight,
                borderTop
              })
            };
            return cx(Surface, sx.borders, getVariant(variant, `${backgroundSize}px`, `${backgroundSize - 1}px`), className);
          }, [backgroundSize, borderBottom, borderLeft, borderRight, borderTop, className, cx, variant]);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * WordPress dependencies
         */
        function useDeprecatedProps({
          elevation,
          isElevated,
          ...otherProps
        }) {
          const propsToReturn = {
            ...otherProps
          };
          let computedElevation = elevation;
          if (isElevated) {
            var _computedElevation;
            deprecated('Card isElevated prop', {
              since: '5.9',
              alternative: 'elevation'
            });
            (_computedElevation = computedElevation) !== null && _computedElevation !== void 0 ? _computedElevation : computedElevation = 2;
          }

          // The `elevation` prop should only be passed when it's not `undefined`,
          // otherwise it will override the value that gets derived from `useContextSystem`.
          if (typeof computedElevation !== 'undefined') {
            propsToReturn.elevation = computedElevation;
          }
          return propsToReturn;
        }
        function useCard(props) {
          const {
            className,
            elevation = 0,
            isBorderless = false,
            isRounded = true,
            size = 'medium',
            ...otherProps
          } = useContextSystem(useDeprecatedProps(props), 'Card');
          const cx = useCx();
          const classes = reactExports.useMemo(() => {
            return cx(Card$1, isBorderless && boxShadowless, isRounded && rounded, className);
          }, [className, cx, isBorderless, isRounded]);
          const surfaceProps = useSurface({
            ...otherProps,
            className: classes
          });
          return {
            ...surfaceProps,
            elevation,
            isBorderless,
            isRounded,
            size
          };
        }
        function UnconnectedCard(props, forwardedRef) {
          const {
            children,
            elevation,
            isBorderless,
            isRounded,
            size,
            ...otherProps
          } = useCard(props);
          const elevationBorderRadius = isRounded ? CONFIG.radiusLarge : 0;
          const cx = useCx();
          const elevationClassName = reactExports.useMemo(() => cx(/* @__PURE__ */css({
            borderRadius: elevationBorderRadius
          }, "", "")), [cx, elevationBorderRadius]);
          const contextProviderValue = reactExports.useMemo(() => {
            const contextProps = {
              size,
              isBorderless
            };
            return {
              CardBody: contextProps,
              CardHeader: contextProps,
              CardFooter: contextProps
            };
          }, [isBorderless, size]);
          return /* @__PURE__ */jsxRuntimeExports.jsx(ContextSystemProvider, {
            value: contextProviderValue,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(View, {
              ...otherProps,
              ref: forwardedRef,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(View, {
                className: cx(Content),
                children
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Elevation, {
                className: elevationClassName,
                isInteractive: false,
                value: elevation ? 1 : 0
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Elevation, {
                className: elevationClassName,
                isInteractive: false,
                value: elevation
              })]
            })
          });
        }
        const Card = contextConnect(UnconnectedCard, "Card");
        const scrollableScrollbar = /* @__PURE__ */css("@media only screen and ( min-device-width: 40em ){&::-webkit-scrollbar{height:12px;width:12px;}&::-webkit-scrollbar-track{background-color:transparent;}&::-webkit-scrollbar-track{background:", CONFIG.colorScrollbarTrack, ";border-radius:8px;}&::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:", CONFIG.colorScrollbarThumb, ";border:2px solid rgba( 0, 0, 0, 0 );border-radius:7px;}&:hover::-webkit-scrollbar-thumb{background-color:", CONFIG.colorScrollbarThumbHover, ";}}" + "", "");
        const Scrollable$1 = {
          name: "13udsys",
          styles: "height:100%"
        };
        const smoothScroll = {
          name: "7zq9w",
          styles: "scroll-behavior:smooth"
        };
        const scrollX = {
          name: "q33xhg",
          styles: "overflow-x:auto;overflow-y:hidden"
        };
        const scrollY = {
          name: "103x71s",
          styles: "overflow-x:hidden;overflow-y:auto"
        };
        const scrollAuto = {
          name: "umwchj",
          styles: "overflow-y:auto"
        };

        /**
         * WordPress dependencies
         */
        function useScrollable(props) {
          const {
            className,
            scrollDirection = 'y',
            smoothScroll: smoothScroll$1 = false,
            ...otherProps
          } = useContextSystem(props, 'Scrollable');
          const cx = useCx();
          const classes = reactExports.useMemo(() => cx(Scrollable$1, scrollableScrollbar, smoothScroll$1 && smoothScroll, scrollDirection === 'x' && scrollX, scrollDirection === 'y' && scrollY, scrollDirection === 'auto' && scrollAuto, className), [className, cx, scrollDirection, smoothScroll$1]);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedScrollable(props, forwardedRef) {
          const scrollableProps = useScrollable(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...scrollableProps,
            ref: forwardedRef
          });
        }

        /**
         * `Scrollable` is a layout component that content in a scrollable container.
         *
         * ```jsx
         * import { __experimentalScrollable as Scrollable } from `@wordpress/components`;
         *
         * function Example() {
         * 	return (
         * 		<Scrollable style={ { maxHeight: 200 } }>
         * 			<div style={ { height: 500 } }>...</div>
         * 		</Scrollable>
         * 	);
         * }
         * ```
         */
        const Scrollable = contextConnect(UnconnectedScrollable, 'Scrollable');

        /**
         * WordPress dependencies
         */
        function useCardBody(props) {
          const {
            className,
            isScrollable = false,
            isShady = false,
            size = 'medium',
            ...otherProps
          } = useContextSystem(props, 'CardBody');
          const cx = useCx();
          const classes = reactExports.useMemo(() => cx(Body, borderRadius, cardPaddings[size], isShady && shady,
          // This classname is added for legacy compatibility reasons.
          'components-card__body', className), [className, cx, isShady, size]);
          return {
            ...otherProps,
            className: classes,
            isScrollable
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedCardBody(props, forwardedRef) {
          const {
            isScrollable,
            ...otherProps
          } = useCardBody(props);
          if (isScrollable) {
            return /*#__PURE__*/jsxRuntimeExports.jsx(Scrollable, {
              ...otherProps,
              ref: forwardedRef
            });
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx(View, {
            ...otherProps,
            ref: forwardedRef
          });
        }

        /**
         * `CardBody` renders an optional content area for a `Card`.
         * Multiple `CardBody` components can be used within `Card` if needed.
         *
         * ```jsx
         * import { Card, CardBody } from `@wordpress/components`;
         *
         * <Card>
         * 	<CardBody>
         * 		...
         * 	</CardBody>
         * </Card>
         * ```
         */
        const CardBody = contextConnect(UnconnectedCardBody, 'CardBody');
        const MARGIN_DIRECTIONS = {
          vertical: {
            start: "marginLeft",
            end: "marginRight"
          },
          horizontal: {
            start: "marginTop",
            end: "marginBottom"
          }
        };
        const renderMargin = ({
          "aria-orientation": orientation = "horizontal",
          margin,
          marginStart,
          marginEnd
        }) => /* @__PURE__ */css(rtl({
          [MARGIN_DIRECTIONS[orientation].start]: space(marginStart !== null && marginStart !== void 0 ? marginStart : margin),
          [MARGIN_DIRECTIONS[orientation].end]: space(marginEnd !== null && marginEnd !== void 0 ? marginEnd : margin)
        })(), "", "");
        var _ref = {
          name: "1u4hpl4",
          styles: "display:inline"
        };
        const renderDisplay = ({
          "aria-orientation": orientation = "horizontal"
        }) => {
          return orientation === "vertical" ? _ref : void 0;
        };
        const renderBorder = ({
          "aria-orientation": orientation = "horizontal"
        }) => {
          return /* @__PURE__ */css({
            [orientation === "vertical" ? "borderRight" : "borderBottom"]: "1px solid currentColor"
          }, "", "");
        };
        const renderSize = ({
          "aria-orientation": orientation = "horizontal"
        }) => /* @__PURE__ */css({
          height: orientation === "vertical" ? "auto" : 0,
          width: orientation === "vertical" ? 0 : "auto"
        }, "", "");
        const DividerView = /* @__PURE__ */createStyled("hr", {
          target: "e19on6iw0"
        })("border:0;margin:0;", renderDisplay, " ", renderBorder, " ", renderSize, " ", renderMargin, ";" + "");

        /**
         * External dependencies
         */
        function UnconnectedDivider(props, forwardedRef) {
          const contextProps = useContextSystem(props, 'Divider');
          return /*#__PURE__*/jsxRuntimeExports.jsx(Separator, {
            render: /*#__PURE__*/jsxRuntimeExports.jsx(DividerView, {}),
            ...contextProps,
            ref: forwardedRef
          });
        }

        /**
         * `Divider` is a layout component that separates groups of related content.
         *
         * ```js
         * import {
         * 		__experimentalDivider as Divider,
         * 		__experimentalText as Text,
         * 		__experimentalVStack as VStack,
         * } from `@wordpress/components`;
         *
         * function Example() {
         * 	return (
         * 		<VStack spacing={4}>
         * 			<Text>Some text here</Text>
         * 			<Divider />
         * 			<Text>Some more text here</Text>
         * 		</VStack>
         * 	);
         * }
         * ```
         */
        const Divider = contextConnect(UnconnectedDivider, 'Divider');

        /**
         * WordPress dependencies
         */
        function useCardDivider(props) {
          const {
            className,
            ...otherProps
          } = useContextSystem(props, 'CardDivider');
          const cx = useCx();
          const classes = reactExports.useMemo(() => cx(Divider$1, borderColor,
          // This classname is added for legacy compatibility reasons.
          'components-card__divider', className), [className, cx]);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedCardDivider(props, forwardedRef) {
          const dividerProps = useCardDivider(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(Divider, {
            ...dividerProps,
            ref: forwardedRef
          });
        }

        /**
         * `CardDivider` renders an optional divider within a `Card`.
         * It is typically used to divide multiple `CardBody` components from each other.
         *
         * ```jsx
         * import { Card, CardBody, CardDivider } from `@wordpress/components`;
         *
         * <Card>
         *  <CardBody>...</CardBody>
         *  <CardDivider />
         *  <CardBody>...</CardBody>
         * </Card>
         * ```
         */
        const CardDivider = contextConnect(UnconnectedCardDivider, 'CardDivider');

        /**
         * WordPress dependencies
         */
        function useCardFooter(props) {
          const {
            className,
            justify,
            isBorderless = false,
            isShady = false,
            size = 'medium',
            ...otherProps
          } = useContextSystem(props, 'CardFooter');
          const cx = useCx();
          const classes = reactExports.useMemo(() => cx(Footer, borderRadius, borderColor, cardPaddings[size], isBorderless && borderless, isShady && shady,
          // This classname is added for legacy compatibility reasons.
          'components-card__footer', className), [className, cx, isBorderless, isShady, size]);
          return {
            ...otherProps,
            className: classes,
            justify
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedCardFooter(props, forwardedRef) {
          const footerProps = useCardFooter(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(Flex, {
            ...footerProps,
            ref: forwardedRef
          });
        }

        /**
         * `CardFooter` renders an optional footer within a `Card`.
         *
         * ```jsx
         * import { Card, CardBody, CardFooter } from `@wordpress/components`;
         *
         * <Card>
         * 	<CardBody>...</CardBody>
         * 	<CardFooter>...</CardFooter>
         * </Card>
         * ```
         */
        const CardFooter = contextConnect(UnconnectedCardFooter, 'CardFooter');

        /**
         * WordPress dependencies
         */
        function useCardHeader(props) {
          const {
            className,
            isBorderless = false,
            isShady = false,
            size = 'medium',
            ...otherProps
          } = useContextSystem(props, 'CardHeader');
          const cx = useCx();
          const classes = reactExports.useMemo(() => cx(Header, borderRadius, borderColor, cardPaddings[size], isBorderless && borderless, isShady && shady,
          // This classname is added for legacy compatibility reasons.
          'components-card__header', className), [className, cx, isBorderless, isShady, size]);
          return {
            ...otherProps,
            className: classes
          };
        }

        /**
         * External dependencies
         */

        function UnconnectedCardHeader(props, forwardedRef) {
          const headerProps = useCardHeader(props);
          return /*#__PURE__*/jsxRuntimeExports.jsx(Flex, {
            ...headerProps,
            ref: forwardedRef
          });
        }

        /**
         * `CardHeader` renders an optional header within a `Card`.
         *
         * ```jsx
         * import { Card, CardBody, CardHeader } from `@wordpress/components`;
         *
         * <Card>
         * 	<CardHeader>...</CardHeader>
         * 	<CardBody>...</CardBody>
         * </Card>
         * ```
         */
        const CardHeader = contextConnect(UnconnectedCardHeader, 'CardHeader');

        /**
         * External dependencies
         */
        /**
         * Checkboxes allow the user to select one or more items from a set.
         *
         * ```jsx
         * import { CheckboxControl } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyCheckboxControl = () => {
         *   const [ isChecked, setChecked ] = useState( true );
         *   return (
         *     <CheckboxControl
         *       __nextHasNoMarginBottom
         *       label="Is author"
         *       help="Is the user a author or not?"
         *       checked={ isChecked }
         *       onChange={ setChecked }
         *     />
         *   );
         * };
         * ```
         */
        function CheckboxControl(props) {
          const {
            __nextHasNoMarginBottom,
            label,
            className,
            heading,
            checked,
            indeterminate,
            help,
            id: idProp,
            onChange,
            ...additionalProps
          } = props;
          if (heading) {
            deprecated('`heading` prop in `CheckboxControl`', {
              alternative: 'a separate element to implement a heading',
              since: '5.8'
            });
          }
          const [showCheckedIcon, setShowCheckedIcon] = reactExports.useState(false);
          const [showIndeterminateIcon, setShowIndeterminateIcon] = reactExports.useState(false);

          // Run the following callback every time the `ref` (and the additional
          // dependencies) change.
          const ref = useRefEffect(node => {
            if (!node) {
              return;
            }

            // It cannot be set using an HTML attribute.
            node.indeterminate = !!indeterminate;
            setShowCheckedIcon(node.matches(':checked'));
            setShowIndeterminateIcon(node.matches(':indeterminate'));
          }, [checked, indeterminate]);
          const id = useInstanceId(CheckboxControl, 'inspector-checkbox-control', idProp);
          const onChangeValue = event => onChange(event.target.checked);
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            __nextHasNoMarginBottom: __nextHasNoMarginBottom,
            __associatedWPComponentName: "CheckboxControl",
            label: heading,
            id: id,
            help: help && /*#__PURE__*/jsxRuntimeExports.jsx("span", {
              className: "components-checkbox-control__help",
              children: help
            }),
            className: clsx('components-checkbox-control', className),
            children: /*#__PURE__*/jsxRuntimeExports.jsxs(HStack, {
              spacing: 0,
              justify: "start",
              alignment: "top",
              children: [/*#__PURE__*/jsxRuntimeExports.jsxs("span", {
                className: "components-checkbox-control__input-container",
                children: [/*#__PURE__*/jsxRuntimeExports.jsx("input", {
                  ref: ref,
                  id: id,
                  className: "components-checkbox-control__input",
                  type: "checkbox",
                  value: "1",
                  onChange: onChangeValue,
                  checked: checked,
                  "aria-describedby": !!help ? id + '__help' : undefined,
                  ...additionalProps
                }), showIndeterminateIcon ? /*#__PURE__*/jsxRuntimeExports.jsx(Icon$2, {
                  icon: reset,
                  className: "components-checkbox-control__indeterminate",
                  role: "presentation"
                }) : null, showCheckedIcon ? /*#__PURE__*/jsxRuntimeExports.jsx(Icon$2, {
                  icon: check,
                  className: "components-checkbox-control__checked",
                  role: "presentation"
                }) : null]
              }), label && /*#__PURE__*/jsxRuntimeExports.jsx("label", {
                className: "components-checkbox-control__label",
                htmlFor: id,
                children: label
              })]
            })
          });
        }

        /**
         * External dependencies
         */
        const TIMEOUT = 4000;
        function ClipboardButton({
          className,
          children,
          onCopy,
          onFinishCopy,
          text,
          ...buttonProps
        }) {
          deprecated('wp.components.ClipboardButton', {
            since: '5.8',
            alternative: 'wp.compose.useCopyToClipboard'
          });
          const timeoutIdRef = reactExports.useRef();
          const ref = useCopyToClipboard(text, () => {
            onCopy();
            if (timeoutIdRef.current) {
              clearTimeout(timeoutIdRef.current);
            }
            if (onFinishCopy) {
              timeoutIdRef.current = setTimeout(() => onFinishCopy(), TIMEOUT);
            }
          });
          reactExports.useEffect(() => {
            if (timeoutIdRef.current) {
              clearTimeout(timeoutIdRef.current);
            }
          }, []);
          const classes = clsx('components-clipboard-button', className);

          // Workaround for inconsistent behavior in Safari, where <textarea> is not
          // the document.activeElement at the moment when the copy event fires.
          // This causes documentHasSelection() in the copy-handler component to
          // mistakenly override the ClipboardButton, and copy a serialized string
          // of the current block instead.
          const focusOnCopyEventTarget = event => {
            // @ts-expect-error: Should be currentTarget, but not changing because this component is deprecated.
            event.target.focus();
          };
          return /*#__PURE__*/jsxRuntimeExports.jsx(Button, {
            ...buttonProps,
            className: classes,
            ref: ref,
            onCopy: focusOnCopyEventTarget,
            children: children
          });
        }

        /* wp:polyfill */
        const LIVE_REGION_ARIA_ROLES = new Set(['alert', 'status', 'log', 'marquee', 'timer']);
        const hiddenElementsByDepth = [];

        /**
         * Hides all elements in the body element from screen-readers except
         * the provided element and elements that should not be hidden from
         * screen-readers.
         *
         * The reason we do this is because `aria-modal="true"` currently is bugged
         * in Safari, and support is spotty in other browsers overall. In the future
         * we should consider removing these helper functions in favor of
         * `aria-modal="true"`.
         *
         * @param modalElement The element that should not be hidden.
         */
        function modalize(modalElement) {
          const elements = Array.from(document.body.children);
          const hiddenElements = [];
          hiddenElementsByDepth.push(hiddenElements);
          for (const element of elements) {
            if (element === modalElement) {
              continue;
            }
            if (elementShouldBeHidden(element)) {
              element.setAttribute('aria-hidden', 'true');
              hiddenElements.push(element);
            }
          }
        }

        /**
         * Determines if the passed element should not be hidden from screen readers.
         *
         * @param element The element that should be checked.
         *
         * @return Whether the element should not be hidden from screen-readers.
         */
        function elementShouldBeHidden(element) {
          const role = element.getAttribute('role');
          return !(element.tagName === 'SCRIPT' || element.hasAttribute('hidden') || element.hasAttribute('aria-hidden') || element.hasAttribute('aria-live') || role && LIVE_REGION_ARIA_ROLES.has(role));
        }

        /**
         * Accessibly reveals the elements hidden by the latest modal.
         */
        function unmodalize() {
          const hiddenElements = hiddenElementsByDepth.pop();
          if (!hiddenElements) {
            return;
          }
          for (const element of hiddenElements) {
            element.removeAttribute('aria-hidden');
          }
        }

        /**
         * WordPress dependencies
         */

        // Animation duration (ms) extracted to JS in order to be used on a setTimeout.
        const FRAME_ANIMATION_DURATION = CONFIG.transitionDuration;
        const FRAME_ANIMATION_DURATION_NUMBER = Number.parseInt(CONFIG.transitionDuration);
        const EXIT_ANIMATION_NAME = 'components-modal__disappear-animation';
        function useModalExitAnimation() {
          const frameRef = reactExports.useRef();
          const [isAnimatingOut, setIsAnimatingOut] = reactExports.useState(false);
          const isReducedMotion = useReducedMotion();
          const closeModal = reactExports.useCallback(() => new Promise(closeModalResolve => {
            // Grab a "stable" reference of the frame element, since
            // the value held by the react ref might change at runtime.
            const frameEl = frameRef.current;
            if (isReducedMotion) {
              closeModalResolve();
              return;
            }
            if (!frameEl) {
              globalThis.SCRIPT_DEBUG === true ? warning("wp.components.Modal: the Modal component can't be closed with an exit animation because of a missing reference to the modal frame element.") : void 0;
              closeModalResolve();
              return;
            }
            let handleAnimationEnd;
            const startAnimation = () => new Promise(animationResolve => {
              handleAnimationEnd = e => {
                if (e.animationName === EXIT_ANIMATION_NAME) {
                  animationResolve();
                }
              };
              frameEl.addEventListener('animationend', handleAnimationEnd);
              setIsAnimatingOut(true);
            });
            const animationTimeout = () => new Promise(timeoutResolve => {
              setTimeout(() => timeoutResolve(),
              // Allow an extra 20% of the animation duration for the
              // animationend event to fire, in case the animation frame is
              // slightly delayes by some other events in the event loop.
              FRAME_ANIMATION_DURATION_NUMBER * 1.2);
            });
            Promise.race([startAnimation(), animationTimeout()]).then(() => {
              if (handleAnimationEnd) {
                frameEl.removeEventListener('animationend', handleAnimationEnd);
              }
              setIsAnimatingOut(false);
              closeModalResolve();
            });
          }), [isReducedMotion]);
          return {
            overlayClassname: isAnimatingOut ? 'is-animating-out' : undefined,
            frameRef,
            frameStyle: {
              '--modal-frame-animation-duration': `${FRAME_ANIMATION_DURATION}`
            },
            closeModal
          };
        }

        /* wp:polyfill */
        /**
         * External dependencies
         */
        const ModalContext = reactExports.createContext(new Set());

        // Used to track body class names applied while modals are open.
        const bodyOpenClasses = new Map();
        function UnforwardedModal(props, forwardedRef) {
          const {
            bodyOpenClassName = 'modal-open',
            role = 'dialog',
            title = null,
            focusOnMount = true,
            shouldCloseOnEsc = true,
            shouldCloseOnClickOutside = true,
            isDismissible = true,
            /* Accessibility. */
            aria = {
              labelledby: undefined,
              describedby: undefined
            },
            onRequestClose,
            icon,
            closeButtonLabel,
            children,
            style,
            overlayClassName: overlayClassnameProp,
            className,
            contentLabel,
            onKeyDown,
            isFullScreen = false,
            size,
            headerActions = null,
            __experimentalHideHeader = false
          } = props;
          const ref = reactExports.useRef();
          const instanceId = useInstanceId(Modal);
          const headingId = title ? `components-modal-header-${instanceId}` : aria.labelledby;

          // The focus hook does not support 'firstContentElement' but this is a valid
          // value for the Modal's focusOnMount prop. The following code ensures the focus
          // hook will focus the first focusable node within the element to which it is applied.
          // When `firstContentElement` is passed as the value of the focusOnMount prop,
          // the focus hook is applied to the Modal's content element.
          // Otherwise, the focus hook is applied to the Modal's ref. This ensures that the
          // focus hook will focus the first element in the Modal's **content** when
          // `firstContentElement` is passed.
          const focusOnMountRef = useFocusOnMount(focusOnMount === 'firstContentElement' ? 'firstElement' : focusOnMount);
          const constrainedTabbingRef = useConstrainedTabbing();
          const focusReturnRef = useFocusReturn();
          const contentRef = reactExports.useRef(null);
          const childrenContainerRef = reactExports.useRef(null);
          const [hasScrolledContent, setHasScrolledContent] = reactExports.useState(false);
          const [hasScrollableContent, setHasScrollableContent] = reactExports.useState(false);
          let sizeClass;
          if (isFullScreen || size === 'fill') {
            sizeClass = 'is-full-screen';
          } else if (size) {
            sizeClass = `has-size-${size}`;
          }

          // Determines whether the Modal content is scrollable and updates the state.
          const isContentScrollable = reactExports.useCallback(() => {
            if (!contentRef.current) {
              return;
            }
            const closestScrollContainer = getScrollContainer(contentRef.current);
            if (contentRef.current === closestScrollContainer) {
              setHasScrollableContent(true);
            } else {
              setHasScrollableContent(false);
            }
          }, [contentRef]);

          // Accessibly isolates/unisolates the modal.
          reactExports.useEffect(() => {
            modalize(ref.current);
            return () => unmodalize();
          }, []);

          // Keeps a fresh ref for the subsequent effect.
          const onRequestCloseRef = reactExports.useRef();
          reactExports.useEffect(() => {
            onRequestCloseRef.current = onRequestClose;
          }, [onRequestClose]);

          // The list of `onRequestClose` callbacks of open (non-nested) Modals. Only
          // one should remain open at a time and the list enables closing prior ones.
          const dismissers = reactExports.useContext(ModalContext);
          // Used for the tracking and dismissing any nested modals.
          const [nestedDismissers] = reactExports.useState(() => new Set());

          // Updates the stack tracking open modals at this level and calls
          // onRequestClose for any prior and/or nested modals as applicable.
          reactExports.useEffect(() => {
            // add this modal instance to the dismissers set
            dismissers.add(onRequestCloseRef);
            // request that all the other modals close themselves
            for (const dismisser of dismissers) {
              if (dismisser !== onRequestCloseRef) {
                dismisser.current?.();
              }
            }
            return () => {
              // request that all the nested modals close themselves
              for (const dismisser of nestedDismissers) {
                dismisser.current?.();
              }
              // remove this modal instance from the dismissers set
              dismissers.delete(onRequestCloseRef);
            };
          }, [dismissers, nestedDismissers]);

          // Adds/removes the value of bodyOpenClassName to body element.
          reactExports.useEffect(() => {
            var _bodyOpenClasses$get;
            const theClass = bodyOpenClassName;
            const oneMore = 1 + ((_bodyOpenClasses$get = bodyOpenClasses.get(theClass)) !== null && _bodyOpenClasses$get !== void 0 ? _bodyOpenClasses$get : 0);
            bodyOpenClasses.set(theClass, oneMore);
            document.body.classList.add(bodyOpenClassName);
            return () => {
              const oneLess = bodyOpenClasses.get(theClass) - 1;
              if (oneLess === 0) {
                document.body.classList.remove(theClass);
                bodyOpenClasses.delete(theClass);
              } else {
                bodyOpenClasses.set(theClass, oneLess);
              }
            };
          }, [bodyOpenClassName]);
          const {
            closeModal,
            frameRef,
            frameStyle,
            overlayClassname
          } = useModalExitAnimation();

          // Calls the isContentScrollable callback when the Modal children container resizes.
          reactExports.useLayoutEffect(() => {
            if (!window.ResizeObserver || !childrenContainerRef.current) {
              return;
            }
            const resizeObserver = new ResizeObserver(isContentScrollable);
            resizeObserver.observe(childrenContainerRef.current);
            isContentScrollable();
            return () => {
              resizeObserver.disconnect();
            };
          }, [isContentScrollable, childrenContainerRef]);
          function handleEscapeKeyDown(event) {
            if (shouldCloseOnEsc && (event.code === 'Escape' || event.key === 'Escape') && !event.defaultPrevented) {
              event.preventDefault();
              closeModal().then(() => onRequestClose(event));
            }
          }
          const onContentContainerScroll = reactExports.useCallback(e => {
            var _e$currentTarget$scro;
            const scrollY = (_e$currentTarget$scro = e?.currentTarget?.scrollTop) !== null && _e$currentTarget$scro !== void 0 ? _e$currentTarget$scro : -1;
            if (!hasScrolledContent && scrollY > 0) {
              setHasScrolledContent(true);
            } else if (hasScrolledContent && scrollY <= 0) {
              setHasScrolledContent(false);
            }
          }, [hasScrolledContent]);
          let pressTarget = null;
          const overlayPressHandlers = {
            onPointerDown: event => {
              if (event.target === event.currentTarget) {
                pressTarget = event.target;
                // Avoids focus changing so that focus return works as expected.
                event.preventDefault();
              }
            },
            // Closes the modal with two exceptions. 1. Opening the context menu on
            // the overlay. 2. Pressing on the overlay then dragging the pointer
            // over the modal and releasing. Due to the modal being a child of the
            // overlay, such a gesture is a `click` on the overlay and cannot be
            // excepted by a `click` handler. Thus the tactic of handling
            // `pointerup` and comparing its target to that of the `pointerdown`.
            onPointerUp: ({
              target,
              button
            }) => {
              const isSameTarget = target === pressTarget;
              pressTarget = null;
              if (button === 0 && isSameTarget) {
                closeModal().then(() => onRequestClose());
              }
            }
          };
          const modal = /*#__PURE__*/
          // eslint-disable-next-line jsx-a11y/no-static-element-interactions
          jsxRuntimeExports.jsx("div", {
            ref: useMergeRefs$1([ref, forwardedRef]),
            className: clsx('components-modal__screen-overlay', overlayClassname, overlayClassnameProp),
            onKeyDown: withIgnoreIMEEvents(handleEscapeKeyDown),
            ...(shouldCloseOnClickOutside ? overlayPressHandlers : {}),
            children: /*#__PURE__*/jsxRuntimeExports.jsx(StyleProvider, {
              document: document,
              children: /*#__PURE__*/jsxRuntimeExports.jsx("div", {
                className: clsx('components-modal__frame', sizeClass, className),
                style: {
                  ...frameStyle,
                  ...style
                },
                ref: useMergeRefs$1([frameRef, constrainedTabbingRef, focusReturnRef, focusOnMount !== 'firstContentElement' ? focusOnMountRef : null]),
                role: role,
                "aria-label": contentLabel,
                "aria-labelledby": contentLabel ? undefined : headingId,
                "aria-describedby": aria.describedby,
                tabIndex: -1,
                onKeyDown: onKeyDown,
                children: /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
                  className: clsx('components-modal__content', {
                    'hide-header': __experimentalHideHeader,
                    'is-scrollable': hasScrollableContent,
                    'has-scrolled-content': hasScrolledContent
                  }),
                  role: "document",
                  onScroll: onContentContainerScroll,
                  ref: contentRef,
                  "aria-label": hasScrollableContent ? __('Scrollable section') : undefined,
                  tabIndex: hasScrollableContent ? 0 : undefined,
                  children: [!__experimentalHideHeader && /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
                    className: "components-modal__header",
                    children: [/*#__PURE__*/jsxRuntimeExports.jsxs("div", {
                      className: "components-modal__header-heading-container",
                      children: [icon && /*#__PURE__*/jsxRuntimeExports.jsx("span", {
                        className: "components-modal__icon-container",
                        "aria-hidden": true,
                        children: icon
                      }), title && /*#__PURE__*/jsxRuntimeExports.jsx("h1", {
                        id: headingId,
                        className: "components-modal__header-heading",
                        children: title
                      })]
                    }), headerActions, isDismissible && /*#__PURE__*/jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                      children: [/*#__PURE__*/jsxRuntimeExports.jsx(Spacer, {
                        marginBottom: 0,
                        marginLeft: 2
                      }), /*#__PURE__*/jsxRuntimeExports.jsx(Button, {
                        size: "compact",
                        onClick: event => closeModal().then(() => onRequestClose(event)),
                        icon: close,
                        label: closeButtonLabel || __('Close')
                      })]
                    })]
                  }), /*#__PURE__*/jsxRuntimeExports.jsx("div", {
                    ref: useMergeRefs$1([childrenContainerRef, focusOnMount === 'firstContentElement' ? focusOnMountRef : null]),
                    children: children
                  })]
                })
              })
            })
          });
          return reactDomExports.createPortal(/*#__PURE__*/jsxRuntimeExports.jsx(ModalContext.Provider, {
            value: nestedDismissers,
            children: modal
          }), document.body);
        }

        /**
         * Modals give users information and choices related to a task they’re trying to
         * accomplish. They can contain critical information, require decisions, or
         * involve multiple tasks.
         *
         * ```jsx
         * import { Button, Modal } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyModal = () => {
         *   const [ isOpen, setOpen ] = useState( false );
         *   const openModal = () => setOpen( true );
         *   const closeModal = () => setOpen( false );
         *
         *   return (
         *     <>
         *       <Button variant="secondary" onClick={ openModal }>
         *         Open Modal
         *       </Button>
         *       { isOpen && (
         *         <Modal title="This is my modal" onRequestClose={ closeModal }>
         *           <Button variant="secondary" onClick={ closeModal }>
         *             My custom close button
         *           </Button>
         *         </Modal>
         *       ) }
         *     </>
         *   );
         * };
         * ```
         */
        const Modal = reactExports.forwardRef(UnforwardedModal);

        /**
         * External dependencies
         */
        const noop$2 = () => {};
        function UnforwardedFormToggle(props, ref) {
          const {
            className,
            checked,
            id,
            disabled,
            onChange = noop$2,
            ...additionalProps
          } = props;
          const wrapperClasses = clsx('components-form-toggle', className, {
            'is-checked': checked,
            'is-disabled': disabled
          });
          return /*#__PURE__*/jsxRuntimeExports.jsxs("span", {
            className: wrapperClasses,
            children: [/*#__PURE__*/jsxRuntimeExports.jsx("input", {
              className: "components-form-toggle__input",
              id: id,
              type: "checkbox",
              checked: checked,
              onChange: onChange,
              disabled: disabled,
              ...additionalProps,
              ref: ref
            }), /*#__PURE__*/jsxRuntimeExports.jsx("span", {
              className: "components-form-toggle__track"
            }), /*#__PURE__*/jsxRuntimeExports.jsx("span", {
              className: "components-form-toggle__thumb"
            })]
          });
        }

        /**
         * FormToggle switches a single setting on or off.
         *
         * ```jsx
         * import { FormToggle } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyFormToggle = () => {
         *   const [ isChecked, setChecked ] = useState( true );
         *
         *   return (
         *     <FormToggle
         *       checked={ isChecked }
         *       onChange={ () => setChecked( ( state ) => ! state ) }
         *     />
         *   );
         * };
         * ```
         */
        const FormToggle = reactExports.forwardRef(UnforwardedFormToggle);

        /**
         * Internal dependencies
         */

        /**
         * `PanelHeader` renders the header for the `Panel`.
         * This is used by the `Panel` component under the hood,
         * so it does not typically need to be used.
         */
        function PanelHeader({
          label,
          children
        }) {
          return /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
            className: "components-panel__header",
            children: [label && /*#__PURE__*/jsxRuntimeExports.jsx("h2", {
              children: label
            }), children]
          });
        }

        /**
         * External dependencies
         */
        function UnforwardedPanel({
          header,
          className,
          children
        }, ref) {
          const classNames = clsx(className, 'components-panel');
          return /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
            className: classNames,
            ref: ref,
            children: [header && /*#__PURE__*/jsxRuntimeExports.jsx(PanelHeader, {
              label: header
            }), children]
          });
        }

        /**
         * `Panel` expands and collapses multiple sections of content.
         *
         * ```jsx
         * import { Panel, PanelBody, PanelRow } from '@wordpress/components';
         * import { more } from '@wordpress/icons';
         *
         * const MyPanel = () => (
         * 	<Panel header="My Panel">
         * 		<PanelBody title="My Block Settings" icon={ more } initialOpen={ true }>
         * 			<PanelRow>My Panel Inputs and Labels</PanelRow>
         * 		</PanelBody>
         * 	</Panel>
         * );
         * ```
         */
        const Panel = reactExports.forwardRef(UnforwardedPanel);

        /**
         * External dependencies
         */
        const noop$1 = () => {};
        function UnforwardedPanelBody(props, ref) {
          const {
            buttonProps = {},
            children,
            className,
            icon,
            initialOpen,
            onToggle = noop$1,
            opened,
            title,
            scrollAfterOpen = true
          } = props;
          const [isOpened, setIsOpened] = useControlledState(opened, {
            initial: initialOpen === undefined ? true : initialOpen,
            fallback: false
          });
          const nodeRef = reactExports.useRef(null);

          // Defaults to 'smooth' scrolling
          // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView
          const scrollBehavior = useReducedMotion() ? 'auto' : 'smooth';
          const handleOnToggle = event => {
            event.preventDefault();
            const next = !isOpened;
            setIsOpened(next);
            onToggle(next);
          };

          // Ref is used so that the effect does not re-run upon scrollAfterOpen changing value.
          const scrollAfterOpenRef = reactExports.useRef();
          scrollAfterOpenRef.current = scrollAfterOpen;
          // Runs after initial render.
          useUpdateEffect(() => {
            if (isOpened && scrollAfterOpenRef.current && nodeRef.current?.scrollIntoView) {
              /*
               * Scrolls the content into view when visible.
               * This improves the UX when there are multiple stacking <PanelBody />
               * components in a scrollable container.
               */
              nodeRef.current.scrollIntoView({
                inline: 'nearest',
                block: 'nearest',
                behavior: scrollBehavior
              });
            }
          }, [isOpened, scrollBehavior]);
          const classes = clsx('components-panel__body', className, {
            'is-opened': isOpened
          });
          return /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
            className: classes,
            ref: useMergeRefs$1([nodeRef, ref]),
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(PanelBodyTitle, {
              icon: icon,
              isOpened: Boolean(isOpened),
              onClick: handleOnToggle,
              title: title,
              ...buttonProps
            }), typeof children === 'function' ? children({
              opened: Boolean(isOpened)
            }) : isOpened && children]
          });
        }
        const PanelBodyTitle = reactExports.forwardRef(({
          isOpened,
          icon,
          title,
          ...props
        }, ref) => {
          if (!title) {
            return null;
          }
          return /*#__PURE__*/jsxRuntimeExports.jsx("h2", {
            className: "components-panel__body-title",
            children: /*#__PURE__*/jsxRuntimeExports.jsxs(Button, {
              __next40pxDefaultSize: true,
              className: "components-panel__body-toggle",
              "aria-expanded": isOpened,
              ref: ref,
              ...props,
              children: [/*#__PURE__*/jsxRuntimeExports.jsx("span", {
                "aria-hidden": "true",
                children: /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
                  className: "components-panel__arrow",
                  icon: isOpened ? chevronUp : chevronDown
                })
              }), title, icon && /*#__PURE__*/jsxRuntimeExports.jsx(Icon, {
                icon: icon,
                className: "components-panel__icon",
                size: 20
              })]
            })
          });
        });
        const PanelBody = reactExports.forwardRef(UnforwardedPanelBody);

        /**
         * External dependencies
         */
        // Separate the actual tab name from the instance ID. This is
        // necessary because Ariakit internally uses the element ID when
        // a new tab is selected, but our implementation looks specifically
        // for the tab name to be passed to the `onSelect` callback.
        const extractTabName = id => {
          if (typeof id === 'undefined' || id === null) {
            return;
          }
          return id.match(/^tab-panel-[0-9]*-(.*)/)?.[1];
        };

        /**
         * TabPanel is an ARIA-compliant tabpanel.
         *
         * TabPanels organize content across different screens, data sets, and interactions.
         * It has two sections: a list of tabs, and the view to show when tabs are chosen.
         *
         * ```jsx
         * import { TabPanel } from '@wordpress/components';
         *
         * const onSelect = ( tabName ) => {
         *   console.log( 'Selecting tab', tabName );
         * };
         *
         * const MyTabPanel = () => (
         *   <TabPanel
         *     className="my-tab-panel"
         *     activeClass="active-tab"
         *     onSelect={ onSelect }
         *     tabs={ [
         *       {
         *         name: 'tab1',
         *         title: 'Tab 1',
         *         className: 'tab-one',
         *       },
         *       {
         *         name: 'tab2',
         *         title: 'Tab 2',
         *         className: 'tab-two',
         *       },
         *     ] }
         *   >
         *     { ( tab ) => <p>{ tab.title }</p> }
         *   </TabPanel>
         * );
         * ```
         */
        const UnforwardedTabPanel = ({
          className,
          children,
          tabs,
          selectOnMove = true,
          initialTabName,
          orientation = 'horizontal',
          activeClass = 'is-active',
          onSelect
        }, ref) => {
          const instanceId = useInstanceId(TabPanel, 'tab-panel');
          const prependInstanceId = reactExports.useCallback(tabName => {
            if (typeof tabName === 'undefined') {
              return;
            }
            return `${instanceId}-${tabName}`;
          }, [instanceId]);
          const tabStore = useTabStore({
            setSelectedId: newTabValue => {
              if (typeof newTabValue === 'undefined' || newTabValue === null) {
                return;
              }
              const newTab = tabs.find(t => prependInstanceId(t.name) === newTabValue);
              if (newTab?.disabled || newTab === selectedTab) {
                return;
              }
              const simplifiedTabName = extractTabName(newTabValue);
              if (typeof simplifiedTabName === 'undefined') {
                return;
              }
              onSelect?.(simplifiedTabName);
            },
            orientation,
            selectOnMove,
            defaultSelectedId: prependInstanceId(initialTabName),
            rtl: isRTL$1()
          });
          const selectedTabName = extractTabName(useStoreState(tabStore, 'selectedId'));
          const setTabStoreSelectedId = reactExports.useCallback(tabName => {
            tabStore.setState('selectedId', prependInstanceId(tabName));
          }, [prependInstanceId, tabStore]);
          const selectedTab = tabs.find(({
            name
          }) => name === selectedTabName);
          const previousSelectedTabName = usePrevious$1(selectedTabName);

          // Ensure `onSelect` is called when the initial tab is selected.
          reactExports.useEffect(() => {
            if (previousSelectedTabName !== selectedTabName && selectedTabName === initialTabName && !!selectedTabName) {
              onSelect?.(selectedTabName);
            }
          }, [selectedTabName, initialTabName, onSelect, previousSelectedTabName]);

          // Handle selecting the initial tab.
          reactExports.useLayoutEffect(() => {
            // If there's a selected tab, don't override it.
            if (selectedTab) {
              return;
            }
            const initialTab = tabs.find(tab => tab.name === initialTabName);
            // Wait for the denoted initial tab to be declared before making a
            // selection. This ensures that if a tab is declared lazily it can
            // still receive initial selection.
            if (initialTabName && !initialTab) {
              return;
            }
            if (initialTab && !initialTab.disabled) {
              // Select the initial tab if it's not disabled.
              setTabStoreSelectedId(initialTab.name);
            } else {
              // Fallback to the first enabled tab when the initial tab is
              // disabled or it can't be found.
              const firstEnabledTab = tabs.find(tab => !tab.disabled);
              if (firstEnabledTab) {
                setTabStoreSelectedId(firstEnabledTab.name);
              }
            }
          }, [tabs, selectedTab, initialTabName, instanceId, setTabStoreSelectedId]);

          // Handle the currently selected tab becoming disabled.
          reactExports.useEffect(() => {
            // This effect only runs when the selected tab is defined and becomes disabled.
            if (!selectedTab?.disabled) {
              return;
            }
            const firstEnabledTab = tabs.find(tab => !tab.disabled);
            // If the currently selected tab becomes disabled, select the first enabled tab.
            // (if there is one).
            if (firstEnabledTab) {
              setTabStoreSelectedId(firstEnabledTab.name);
            }
          }, [tabs, selectedTab?.disabled, setTabStoreSelectedId, instanceId]);
          return /*#__PURE__*/jsxRuntimeExports.jsxs("div", {
            className: className,
            ref: ref,
            children: [/*#__PURE__*/jsxRuntimeExports.jsx(TabList, {
              store: tabStore,
              className: "components-tab-panel__tabs",
              children: tabs.map(tab => {
                return /*#__PURE__*/jsxRuntimeExports.jsx(Tab, {
                  id: prependInstanceId(tab.name),
                  className: clsx('components-tab-panel__tabs-item', tab.className, {
                    [activeClass]: tab.name === selectedTabName
                  }),
                  disabled: tab.disabled,
                  "aria-controls": `${prependInstanceId(tab.name)}-view`,
                  render: /*#__PURE__*/jsxRuntimeExports.jsx(Button, {
                    __next40pxDefaultSize: true,
                    icon: tab.icon,
                    label: tab.icon && tab.title,
                    showTooltip: !!tab.icon
                  }),
                  children: !tab.icon && tab.title
                }, tab.name);
              })
            }), selectedTab && /*#__PURE__*/jsxRuntimeExports.jsx(TabPanel$1, {
              id: `${prependInstanceId(selectedTab.name)}-view`,
              store: tabStore,
              tabId: prependInstanceId(selectedTab.name),
              className: "components-tab-panel__tab-content",
              children: children(selectedTab)
            })]
          });
        };
        const TabPanel = reactExports.forwardRef(UnforwardedTabPanel);

        /**
         * External dependencies
         */

        function UnforwardedTextControl(props, ref) {
          const {
            __nextHasNoMarginBottom,
            __next40pxDefaultSize = false,
            label,
            hideLabelFromVision,
            value,
            help,
            id: idProp,
            className,
            onChange,
            type = 'text',
            ...additionalProps
          } = props;
          const id = useInstanceId(TextControl, 'inspector-text-control', idProp);
          const onChangeValue = event => onChange(event.target.value);
          maybeWarnDeprecated36pxSize({
            componentName: 'TextControl',
            size: undefined,
            __next40pxDefaultSize
          });
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            __nextHasNoMarginBottom: __nextHasNoMarginBottom,
            __associatedWPComponentName: "TextControl",
            label: label,
            hideLabelFromVision: hideLabelFromVision,
            id: id,
            help: help,
            className: className,
            children: /*#__PURE__*/jsxRuntimeExports.jsx("input", {
              className: clsx('components-text-control__input', {
                'is-next-40px-default-size': __next40pxDefaultSize
              }),
              type: type,
              id: id,
              value: value,
              onChange: onChangeValue,
              "aria-describedby": !!help ? id + '__help' : undefined,
              ref: ref,
              ...additionalProps
            })
          });
        }

        /**
         * TextControl components let users enter and edit text.
         *
         * ```jsx
         * import { TextControl } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyTextControl = () => {
         *   const [ className, setClassName ] = useState( '' );
         *
         *   return (
         *     <TextControl
         *       __nextHasNoMarginBottom
         *       __next40pxDefaultSize
         *       label="Additional CSS Class"
         *       value={ className }
         *       onChange={ ( value ) => setClassName( value ) }
         *     />
         *   );
         * };
         * ```
         */
        const TextControl = reactExports.forwardRef(UnforwardedTextControl);
        const inputStyleNeutral = /* @__PURE__ */css("box-shadow:0 0 0 transparent;border-radius:", CONFIG.radiusSmall, ";border:", CONFIG.borderWidth, " solid ", COLORS$1.ui.border, ";@media not ( prefers-reduced-motion ){transition:box-shadow 0.1s linear;}" + "", "");
        const inputStyleFocus = /* @__PURE__ */css("border-color:", COLORS$1.theme.accent, ";box-shadow:0 0 0 calc( ", CONFIG.borderWidthFocus, " - ", CONFIG.borderWidth, " ) ", COLORS$1.theme.accent, ";outline:2px solid transparent;" + "", "");
        const StyledTextarea$1 = /* @__PURE__ */createStyled("textarea", {
          target: "e1w5nnrk0"
        })("width:100%;display:block;font-family:", font("default.fontFamily"), ";line-height:20px;padding:9px 11px;", inputStyleNeutral, ";font-size:", font("mobileTextMinFontSize"), ";", breakpoint("small"), "{font-size:", font("default.fontSize"), ";}&:focus{", inputStyleFocus, ";}&::-webkit-input-placeholder{color:", COLORS$1.ui.darkGrayPlaceholder, ";}&::-moz-placeholder{opacity:1;color:", COLORS$1.ui.darkGrayPlaceholder, ";}&:-ms-input-placeholder{color:", COLORS$1.ui.darkGrayPlaceholder, ";}.is-dark-theme &{&::-webkit-input-placeholder{color:", COLORS$1.ui.lightGrayPlaceholder, ";}&::-moz-placeholder{opacity:1;color:", COLORS$1.ui.lightGrayPlaceholder, ";}&:-ms-input-placeholder{color:", COLORS$1.ui.lightGrayPlaceholder, ";}}" + "");

        /**
         * WordPress dependencies
         */
        function UnforwardedTextareaControl(props, ref) {
          const {
            __nextHasNoMarginBottom,
            label,
            hideLabelFromVision,
            value,
            help,
            onChange,
            rows = 4,
            className,
            ...additionalProps
          } = props;
          const instanceId = useInstanceId(TextareaControl);
          const id = `inspector-textarea-control-${instanceId}`;
          const onChangeValue = event => onChange(event.target.value);
          return /*#__PURE__*/jsxRuntimeExports.jsx(BaseControl, {
            __nextHasNoMarginBottom: __nextHasNoMarginBottom,
            __associatedWPComponentName: "TextareaControl",
            label: label,
            hideLabelFromVision: hideLabelFromVision,
            id: id,
            help: help,
            className: className,
            children: /*#__PURE__*/jsxRuntimeExports.jsx(StyledTextarea$1, {
              className: "components-textarea-control__input",
              id: id,
              rows: rows,
              onChange: onChangeValue,
              "aria-describedby": !!help ? id + '__help' : undefined,
              value: value,
              ref: ref,
              ...additionalProps
            })
          });
        }

        /**
         * TextareaControls are TextControls that allow for multiple lines of text, and
         * wrap overflow text onto a new line. They are a fixed height and scroll
         * vertically when the cursor reaches the bottom of the field.
         *
         * ```jsx
         * import { TextareaControl } from '@wordpress/components';
         * import { useState } from '@wordpress/element';
         *
         * const MyTextareaControl = () => {
         *   const [ text, setText ] = useState( '' );
         *
         *   return (
         *     <TextareaControl
         *       __nextHasNoMarginBottom
         *       label="Text"
         *       help="Enter some text"
         *       value={ text }
         *       onChange={ ( value ) => setText( value ) }
         *     />
         *   );
         * };
         * ```
         */
        const TextareaControl = reactExports.forwardRef(UnforwardedTextareaControl);
        function UnforwardedToggleControl({
          __nextHasNoMarginBottom,
          label,
          checked,
          help,
          className,
          onChange,
          disabled
        }, ref) {
          function onChangeToggle(event) {
            onChange(event.target.checked);
          }
          const instanceId = useInstanceId(ToggleControl);
          const id = `inspector-toggle-control-${instanceId}`;
          const cx = useCx();
          const classes = cx("components-toggle-control", className, !__nextHasNoMarginBottom && /* @__PURE__ */css({
            marginBottom: space(3)
          }, "", ""));
          if (!__nextHasNoMarginBottom) {
            deprecated("Bottom margin styles for wp.components.ToggleControl", {
              since: "6.7",
              version: "7.0",
              hint: "Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version."
            });
          }
          let describedBy, helpLabel;
          if (help) {
            if (typeof help === "function") {
              if (checked !== void 0) {
                helpLabel = help(checked);
              }
            } else {
              helpLabel = help;
            }
            if (helpLabel) {
              describedBy = id + "__help";
            }
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(BaseControl, {
            id,
            help: helpLabel && /* @__PURE__ */jsxRuntimeExports.jsx("span", {
              className: "components-toggle-control__help",
              children: helpLabel
            }),
            className: classes,
            __nextHasNoMarginBottom: true,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(HStack, {
              justify: "flex-start",
              spacing: 2,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(FormToggle, {
                id,
                checked,
                onChange: onChangeToggle,
                "aria-describedby": describedBy,
                disabled,
                ref
              }), /* @__PURE__ */jsxRuntimeExports.jsx(FlexBlock, {
                as: "label",
                htmlFor: id,
                className: clsx("components-toggle-control__label", {
                  "is-disabled": disabled
                }),
                children: label
              })]
            })
          });
        }
        const ToggleControl = reactExports.forwardRef(UnforwardedToggleControl);
        function ResendButton(props) {
          const {
            id,
            confirmation_token
          } = props.item;
          const [isResent, setIsResent] = reactExports.useState(false);
          if (window?.petitionerData?.approval_state === "Declined" || !confirmation_token) {
            return null;
          }
          const handleResendEmail = async id2 => {
            if (window.confirm("Resend confirmation email to this signee?")) {
              const response = await fetch(`${ajaxurl}?action=petitioner_resend_confirmation_email`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                },
                body: new URLSearchParams({
                  id: id2.toString()
                })
              });
              const data = await response.json();
              if (data.success) {
                setIsResent(true);
                setTimeout(() => setIsResent(false), 3e3);
              } else {
                console.log(data.message || "Failed to resend email.");
              }
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
            disabled: isResent,
            size: "small",
            variant: "link",
            onClick: () => handleResendEmail(id),
            children: !isResent ? "Resend verification" : "Resent successfully"
          });
        }
        function ResendAllButton() {
          const form_id = window?.petitionerData?.form_id;
          if (!form_id) return null;
          const [isResentAll, setIsResentAll] = reactExports.useState(false);
          const handleResendAll = async () => {
            const checkResponse = await fetch(`${ajaxurl}?action=petitioner_check_unconfirmed_count`, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: new URLSearchParams({
                form_id: String(form_id)
              })
            });
            const checkData = await checkResponse.json();
            if (!checkData.success || !checkData.data.count) {
              alert("No unconfirmed users found for this petition.");
              return;
            }
            const count = checkData.data.count;
            const confirmSend = window.confirm(`This will resend confirmation emails to ${count} unconfirmed signees. Proceed?`);
            if (!confirmSend) return;
            const resendResponse = await fetch(`${ajaxurl}?action=petitioner_resend_all_confirmation_emails`, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body: new URLSearchParams({
                form_id: String(form_id)
              })
            });
            const resendData = await resendResponse.json();
            if (resendData.success) {
              setIsResentAll(true);
              setTimeout(() => setIsResentAll(false), 3e3);
            } else {
              console.log(resendData.message || "Failed to resend emails.");
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
              disabled: isResentAll,
              variant: "primary",
              onClick: handleResendAll,
              children: !isResentAll ? "Resend all unconfirmed emails" : "Emails resent successfully"
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("strong", {
                style: {
                  color: "salmon"
                },
                children: "Warning"
              }), ": This action will resend confirmation emails to all unconfirmed signees. Proceed with caution: sending a large number of emails at once may negatively impact your domain’s reputation."]
            })]
          });
        }
        function ApprovalStatus(props) {
          const {
            item,
            onStatusChange = () => {},
            defaultApprovalState
          } = props;
          const {
            id,
            approval_status
          } = item;
          const currentStatus = approval_status ?? defaultApprovalState;
          const changeAction = currentStatus === "Confirmed" ? "Decline" : "Confirm";
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
              style: {
                color: currentStatus === "Confirmed" ? "green" : "red"
              },
              children: currentStatus
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              style: {
                display: "flex",
                gap: "5px"
              },
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                size: "small",
                isDestructive: currentStatus === "Confirmed",
                variant: "secondary",
                onClick: e => {
                  e.stopPropagation();
                  onStatusChange(id, currentStatus === "Confirmed" ? "Declined" : "Confirmed", changeAction);
                },
                children: changeAction
              }), window?.petitionerData?.approval_state === "Email" && /* @__PURE__ */jsxRuntimeExports.jsx(ResendButton, {
                item
              })]
            })]
          });
        }

        /******************************************************************************
        Copyright (c) Microsoft Corporation.
        	Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise, SuppressedError, Symbol */

        var __assign = function () {
          __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          };
          return __assign.apply(this, arguments);
        };
        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };
        var MS = '-ms-';
        var MOZ = '-moz-';
        var WEBKIT = '-webkit-';
        var COMMENT = 'comm';
        var RULESET = 'rule';
        var DECLARATION = 'decl';
        var IMPORT = '@import';
        var KEYFRAMES = '@keyframes';
        var LAYER = '@layer';

        /**
         * @param {number}
         * @return {number}
         */
        var abs = Math.abs;

        /**
         * @param {number}
         * @return {string}
         */
        var from = String.fromCharCode;

        /**
         * @param {object}
         * @return {object}
         */
        var assign = Object.assign;

        /**
         * @param {string} value
         * @param {number} length
         * @return {number}
         */
        function hash(value, length) {
          return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
        }

        /**
         * @param {string} value
         * @return {string}
         */
        function trim(value) {
          return value.trim();
        }

        /**
         * @param {string} value
         * @param {RegExp} pattern
         * @return {string?}
         */
        function match(value, pattern) {
          return (value = pattern.exec(value)) ? value[0] : value;
        }

        /**
         * @param {string} value
         * @param {(string|RegExp)} pattern
         * @param {string} replacement
         * @return {string}
         */
        function replace(value, pattern, replacement) {
          return value.replace(pattern, replacement);
        }

        /**
         * @param {string} value
         * @param {string} search
         * @param {number} position
         * @return {number}
         */
        function indexof(value, search, position) {
          return value.indexOf(search, position);
        }

        /**
         * @param {string} value
         * @param {number} index
         * @return {number}
         */
        function charat(value, index) {
          return value.charCodeAt(index) | 0;
        }

        /**
         * @param {string} value
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function substr(value, begin, end) {
          return value.slice(begin, end);
        }

        /**
         * @param {string} value
         * @return {number}
         */
        function strlen(value) {
          return value.length;
        }

        /**
         * @param {any[]} value
         * @return {number}
         */
        function sizeof(value) {
          return value.length;
        }

        /**
         * @param {any} value
         * @param {any[]} array
         * @return {any}
         */
        function append(value, array) {
          return array.push(value), value;
        }

        /**
         * @param {string[]} array
         * @param {function} callback
         * @return {string}
         */
        function combine(array, callback) {
          return array.map(callback).join('');
        }

        /**
         * @param {string[]} array
         * @param {RegExp} pattern
         * @return {string[]}
         */
        function filter(array, pattern) {
          return array.filter(function (value) {
            return !match(value, pattern);
          });
        }
        var line = 1;
        var column = 1;
        var length = 0;
        var position = 0;
        var character = 0;
        var characters = '';

        /**
         * @param {string} value
         * @param {object | null} root
         * @param {object | null} parent
         * @param {string} type
         * @param {string[] | string} props
         * @param {object[] | string} children
         * @param {object[]} siblings
         * @param {number} length
         */
        function node(value, root, parent, type, props, children, length, siblings) {
          return {
            value: value,
            root: root,
            parent: parent,
            type: type,
            props: props,
            children: children,
            line: line,
            column: column,
            length: length,
            return: '',
            siblings: siblings
          };
        }

        /**
         * @param {object} root
         * @param {object} props
         * @return {object}
         */
        function copy(root, props) {
          return assign(node('', null, null, '', null, null, 0, root.siblings), root, {
            length: -root.length
          }, props);
        }

        /**
         * @param {object} root
         */
        function lift(root) {
          while (root.root) root = copy(root.root, {
            children: [root]
          });
          append(root, root.siblings);
        }

        /**
         * @return {number}
         */
        function char() {
          return character;
        }

        /**
         * @return {number}
         */
        function prev() {
          character = position > 0 ? charat(characters, --position) : 0;
          if (column--, character === 10) column = 1, line--;
          return character;
        }

        /**
         * @return {number}
         */
        function next() {
          character = position < length ? charat(characters, position++) : 0;
          if (column++, character === 10) column = 1, line++;
          return character;
        }

        /**
         * @return {number}
         */
        function peek() {
          return charat(characters, position);
        }

        /**
         * @return {number}
         */
        function caret() {
          return position;
        }

        /**
         * @param {number} begin
         * @param {number} end
         * @return {string}
         */
        function slice(begin, end) {
          return substr(characters, begin, end);
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function token(type) {
          switch (type) {
            // \0 \t \n \r \s whitespace token
            case 0:
            case 9:
            case 10:
            case 13:
            case 32:
              return 5;
            // ! + , / > @ ~ isolate token
            case 33:
            case 43:
            case 44:
            case 47:
            case 62:
            case 64:
            case 126:
            // ; { } breakpoint token
            case 59:
            case 123:
            case 125:
              return 4;
            // : accompanied token
            case 58:
              return 3;
            // " ' ( [ opening delimit token
            case 34:
            case 39:
            case 40:
            case 91:
              return 2;
            // ) ] closing delimit token
            case 41:
            case 93:
              return 1;
          }
          return 0;
        }

        /**
         * @param {string} value
         * @return {any[]}
         */
        function alloc(value) {
          return line = column = 1, length = strlen(characters = value), position = 0, [];
        }

        /**
         * @param {any} value
         * @return {any}
         */
        function dealloc(value) {
          return characters = '', value;
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function delimit(type) {
          return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
        }

        /**
         * @param {number} type
         * @return {string}
         */
        function whitespace(type) {
          while (character = peek()) if (character < 33) next();else break;
          return token(type) > 2 || token(character) > 3 ? '' : ' ';
        }

        /**
         * @param {number} index
         * @param {number} count
         * @return {string}
         */
        function escaping(index, count) {
          while (--count && next())
          // not 0-9 A-F a-f
          if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;
          return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
        }

        /**
         * @param {number} type
         * @return {number}
         */
        function delimiter(type) {
          while (next()) switch (character) {
            // ] ) " '
            case type:
              return position;
            // " '
            case 34:
            case 39:
              if (type !== 34 && type !== 39) delimiter(character);
              break;
            // (
            case 40:
              if (type === 41) delimiter(type);
              break;
            // \
            case 92:
              next();
              break;
          }
          return position;
        }

        /**
         * @param {number} type
         * @param {number} index
         * @return {number}
         */
        function commenter(type, index) {
          while (next())
          // //
          if (type + character === 47 + 10) break;
          // /*
          else if (type + character === 42 + 42 && peek() === 47) break;
          return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next());
        }

        /**
         * @param {number} index
         * @return {string}
         */
        function identifier(index) {
          while (!token(peek())) next();
          return slice(index, position);
        }

        /**
         * @param {string} value
         * @return {object[]}
         */
        function compile(value) {
          return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value));
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {string[]} rule
         * @param {string[]} rules
         * @param {string[]} rulesets
         * @param {number[]} pseudo
         * @param {number[]} points
         * @param {string[]} declarations
         * @return {object}
         */
        function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
          var index = 0;
          var offset = 0;
          var length = pseudo;
          var atrule = 0;
          var property = 0;
          var previous = 0;
          var variable = 1;
          var scanning = 1;
          var ampersand = 1;
          var character = 0;
          var type = '';
          var props = rules;
          var children = rulesets;
          var reference = rule;
          var characters = type;
          while (scanning) switch (previous = character, character = next()) {
            // (
            case 40:
              if (previous != 108 && charat(characters, length - 1) == 58) {
                if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f', abs(index ? points[index - 1] : 0)) != -1) ampersand = -1;
                break;
              }
            // " ' [
            case 34:
            case 39:
            case 91:
              characters += delimit(character);
              break;
            // \t \n \r \s
            case 9:
            case 10:
            case 13:
            case 32:
              characters += whitespace(previous);
              break;
            // \
            case 92:
              characters += escaping(caret() - 1, 7);
              continue;
            // /
            case 47:
              switch (peek()) {
                case 42:
                case 47:
                  append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
                  break;
                default:
                  characters += '/';
              }
              break;
            // {
            case 123 * variable:
              points[index++] = strlen(characters) * ampersand;
            // } ; \0
            case 125 * variable:
            case 59:
            case 0:
              switch (character) {
                // \0 }
                case 0:
                case 125:
                  scanning = 0;
                // ;
                case 59 + offset:
                  if (ampersand == -1) characters = replace(characters, /\f/g, '');
                  if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1, declarations) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2, declarations), declarations);
                  break;
                // @ ;
                case 59:
                  characters += ';';
                // { rule/at-rule
                default:
                  append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);
                  if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);
                      break;
                    default:
                      parse(characters, reference, reference, reference, [''], children, 0, points, children);
                  }
              }
              index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
              break;
            // :
            case 58:
              length = 1 + strlen(characters), property = previous;
            default:
              if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;
              switch (characters += from(character), character * variable) {
                // &
                case 38:
                  ampersand = offset > 0 ? 1 : (characters += '\f', -1);
                  break;
                // ,
                case 44:
                  points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
                  break;
                // @
                case 64:
                  // -
                  if (peek() === 45) characters += delimit(next());
                  atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
                  break;
                // -
                case 45:
                  if (previous === 45 && strlen(characters) == 2) variable = 0;
              }
          }
          return rulesets;
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} index
         * @param {number} offset
         * @param {string[]} rules
         * @param {number[]} points
         * @param {string} type
         * @param {string[]} props
         * @param {string[]} children
         * @param {number} length
         * @param {object[]} siblings
         * @return {object}
         */
        function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {
          var post = offset - 1;
          var rule = offset === 0 ? rules : [''];
          var size = sizeof(rule);
          for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;
          return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length, siblings);
        }

        /**
         * @param {number} value
         * @param {object} root
         * @param {object?} parent
         * @param {object[]} siblings
         * @return {object}
         */
        function comment(value, root, parent, siblings) {
          return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
        }

        /**
         * @param {string} value
         * @param {object} root
         * @param {object?} parent
         * @param {number} length
         * @param {object[]} siblings
         * @return {object}
         */
        function declaration(value, root, parent, length, siblings) {
          return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings);
        }

        /**
         * @param {string} value
         * @param {number} length
         * @param {object[]} children
         * @return {string}
         */
        function prefix(value, length, children) {
          switch (hash(value, length)) {
            // color-adjust
            case 5103:
              return WEBKIT + 'print-' + value + value;
            // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
            case 5737:
            case 4201:
            case 3177:
            case 3433:
            case 1641:
            case 4457:
            case 2921:
            // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
            case 5572:
            case 6356:
            case 5844:
            case 3191:
            case 6645:
            case 3005:
            // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
            case 6391:
            case 5879:
            case 5623:
            case 6135:
            case 4599:
            case 4855:
            // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
            case 4215:
            case 6389:
            case 5109:
            case 5365:
            case 5621:
            case 3829:
              return WEBKIT + value + value;
            // tab-size
            case 4789:
              return MOZ + value + value;
            // appearance, user-select, transform, hyphens, text-size-adjust
            case 5349:
            case 4246:
            case 4810:
            case 6968:
            case 2756:
              return WEBKIT + value + MOZ + value + MS + value + value;
            // writing-mode
            case 5936:
              switch (charat(value, length + 11)) {
                // vertical-l(r)
                case 114:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
                // vertical-r(l)
                case 108:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
                // horizontal(-)tb
                case 45:
                  return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
                // default: fallthrough to below
              }
            // flex, flex-direction, scroll-snap-type, writing-mode
            case 6828:
            case 4268:
            case 2903:
              return WEBKIT + value + MS + value + value;
            // order
            case 6165:
              return WEBKIT + value + MS + 'flex-' + value + value;
            // align-items
            case 5187:
              return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
            // align-self
            case 5443:
              return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/g, '') + (!match(value, /flex-|baseline/) ? MS + 'grid-row-' + replace(value, /flex-|-self/g, '') : '') + value;
            // align-content
            case 4675:
              return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/g, '') + value;
            // flex-shrink
            case 5548:
              return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
            // flex-basis
            case 5292:
              return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
            // flex-grow
            case 6060:
              return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
            // transition
            case 4554:
              return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
            // cursor
            case 6187:
              return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
            // background, background-image
            case 5495:
            case 3959:
              return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
            // justify-content
            case 4968:
              return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
            // justify-self
            case 4200:
              if (!match(value, /flex-|baseline/)) return MS + 'grid-column-align' + substr(value, length) + value;
              break;
            // grid-template-(columns|rows)
            case 2592:
            case 3360:
              return MS + replace(value, 'template-', '') + value;
            // grid-(row|column)-start
            case 4384:
            case 3616:
              if (children && children.some(function (element, index) {
                return length = index, match(element.props, /grid-\w+-end/);
              })) {
                return ~indexof(value + (children = children[length].value), 'span', 0) ? value : MS + replace(value, '-start', '') + value + MS + 'grid-row-span:' + (~indexof(children, 'span', 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ';';
              }
              return MS + replace(value, '-start', '') + value;
            // grid-(row|column)-end
            case 4896:
            case 4128:
              return children && children.some(function (element) {
                return match(element.props, /grid-\w+-start/);
              }) ? value : MS + replace(replace(value, '-end', '-span'), 'span ', '') + value;
            // (margin|padding)-inline-(start|end)
            case 4095:
            case 3583:
            case 4068:
            case 2532:
              return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
            // (min|max)?(width|height|inline-size|block-size)
            case 8116:
            case 7059:
            case 5753:
            case 5535:
            case 5445:
            case 5701:
            case 4933:
            case 4677:
            case 5533:
            case 5789:
            case 5021:
            case 4765:
              // stretch, max-content, min-content, fill-available
              if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
                // (m)ax-content, (m)in-content
                case 109:
                  // -
                  if (charat(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content
                case 102:
                  return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
                // (s)tretch
                case 115:
                  return ~indexof(value, 'stretch', 0) ? prefix(replace(value, 'stretch', 'fill-available'), length, children) + value : value;
              }
              break;
            // grid-(column|row)
            case 5152:
            case 5920:
              return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function (_, a, b, c, d, e, f) {
                return MS + a + ':' + b + f + (c ? MS + a + '-span:' + (d ? e : +e - +b) + f : '') + value;
              });
            // position: sticky
            case 4949:
              // stick(y)?
              if (charat(value, length + 6) === 121) return replace(value, ':', ':' + WEBKIT) + value;
              break;
            // display: (flex|inline-flex|grid|inline-grid)
            case 6444:
              switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
                // (inline-)?fle(x)
                case 120:
                  return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
                // (inline-)?gri(d)
                case 100:
                  return replace(value, ':', ':' + MS) + value;
              }
              break;
            // scroll-margin, scroll-margin-(top|right|bottom|left)
            case 5719:
            case 2647:
            case 2135:
            case 3927:
            case 2391:
              return replace(value, 'scroll-', 'scroll-snap-') + value;
          }
          return value;
        }

        /**
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function serialize(children, callback) {
          var output = '';
          for (var i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || '';
          return output;
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         * @return {string}
         */
        function stringify(element, index, children, callback) {
          switch (element.type) {
            case LAYER:
              if (element.children.length) break;
            case IMPORT:
            case DECLARATION:
              return element.return = element.return || element.value;
            case COMMENT:
              return '';
            case KEYFRAMES:
              return element.return = element.value + '{' + serialize(element.children, callback) + '}';
            case RULESET:
              if (!strlen(element.value = element.props.join(','))) return '';
          }
          return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
        }

        /**
         * @param {function[]} collection
         * @return {function}
         */
        function middleware(collection) {
          var length = sizeof(collection);
          return function (element, index, children, callback) {
            var output = '';
            for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';
            return output;
          };
        }

        /**
         * @param {function} callback
         * @return {function}
         */
        function rulesheet(callback) {
          return function (element) {
            if (!element.root) if (element = element.return) callback(element);
          };
        }

        /**
         * @param {object} element
         * @param {number} index
         * @param {object[]} children
         * @param {function} callback
         */
        function prefixer(element, index, children, callback) {
          if (element.length > -1) if (!element.return) switch (element.type) {
            case DECLARATION:
              element.return = prefix(element.value, element.length, children);
              return;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, '@', '@' + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length) return combine(children = element.props, function (value) {
                switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ':read-only':
                  case ':read-write':
                    lift(copy(element, {
                      props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
                    }));
                    lift(copy(element, {
                      props: [value]
                    }));
                    assign(element, {
                      props: filter(children, callback)
                    });
                    break;
                  // :placeholder
                  case '::placeholder':
                    lift(copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
                    }));
                    lift(copy(element, {
                      props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
                    }));
                    lift(copy(element, {
                      props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
                    }));
                    lift(copy(element, {
                      props: [value]
                    }));
                    assign(element, {
                      props: filter(children, callback)
                    });
                    break;
                }
                return '';
              });
          }
        }
        var unitlessKeys = {
          animationIterationCount: 1,
          aspectRatio: 1,
          borderImageOutset: 1,
          borderImageSlice: 1,
          borderImageWidth: 1,
          boxFlex: 1,
          boxFlexGroup: 1,
          boxOrdinalGroup: 1,
          columnCount: 1,
          columns: 1,
          flex: 1,
          flexGrow: 1,
          flexPositive: 1,
          flexShrink: 1,
          flexNegative: 1,
          flexOrder: 1,
          gridRow: 1,
          gridRowEnd: 1,
          gridRowSpan: 1,
          gridRowStart: 1,
          gridColumn: 1,
          gridColumnEnd: 1,
          gridColumnSpan: 1,
          gridColumnStart: 1,
          msGridRow: 1,
          msGridRowSpan: 1,
          msGridColumn: 1,
          msGridColumnSpan: 1,
          fontWeight: 1,
          lineHeight: 1,
          opacity: 1,
          order: 1,
          orphans: 1,
          tabSize: 1,
          widows: 1,
          zIndex: 1,
          zoom: 1,
          WebkitLineClamp: 1,
          // SVG-related properties
          fillOpacity: 1,
          floodOpacity: 1,
          stopOpacity: 1,
          strokeDasharray: 1,
          strokeDashoffset: 1,
          strokeMiterlimit: 1,
          strokeOpacity: 1,
          strokeWidth: 1
        };
        var define_process_env_default = {};
        var f = "undefined" != typeof process && void 0 !== define_process_env_default && (define_process_env_default.REACT_APP_SC_ATTR || define_process_env_default.SC_ATTR) || "data-styled",
          m = "active",
          y = "data-styled-version",
          v = "6.1.19",
          g = "/*!sc*/\n",
          S = "undefined" != typeof window && "undefined" != typeof document,
          w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== define_process_env_default && void 0 !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY && "" !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY && define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== define_process_env_default && void 0 !== define_process_env_default.SC_DISABLE_SPEEDY && "" !== define_process_env_default.SC_DISABLE_SPEEDY ? "false" !== define_process_env_default.SC_DISABLE_SPEEDY && define_process_env_default.SC_DISABLE_SPEEDY : false),
          _ = Object.freeze([]),
          C = Object.freeze({});
        function I(e2, t2, n2) {
          return void 0 === n2 && (n2 = C), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
        }
        var A = /* @__PURE__ */new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]),
          O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
          D = /(^-|-$)/g;
        function R(e2) {
          return e2.replace(O, "-").replace(D, "");
        }
        var T = /(a)(d)/gi,
          k = 52,
          j = function (e2) {
            return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
          };
        function x(e2) {
          var t2,
            n2 = "";
          for (t2 = Math.abs(e2); t2 > k; t2 = t2 / k | 0) n2 = j(t2 % k) + n2;
          return (j(t2 % k) + n2).replace(T, "$1-$2");
        }
        var V,
          F = 5381,
          M = function (e2, t2) {
            for (var n2 = t2.length; n2;) e2 = 33 * e2 ^ t2.charCodeAt(--n2);
            return e2;
          },
          z = function (e2) {
            return M(F, e2);
          };
        function $(e2) {
          return x(z(e2) >>> 0);
        }
        function B(e2) {
          return e2.displayName || e2.name || "Component";
        }
        function L(e2) {
          return "string" == typeof e2 && true;
        }
        var G = "function" == typeof Symbol && Symbol.for,
          Y = G ? Symbol.for("react.memo") : 60115,
          W = G ? Symbol.for("react.forward_ref") : 60112,
          q = {
            childContextTypes: true,
            contextType: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            getDerivedStateFromError: true,
            getDerivedStateFromProps: true,
            mixins: true,
            propTypes: true,
            type: true
          },
          H = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            callee: true,
            arguments: true,
            arity: true
          },
          U = {
            $$typeof: true,
            compare: true,
            defaultProps: true,
            displayName: true,
            propTypes: true,
            type: true
          },
          J = ((V = {})[W] = {
            $$typeof: true,
            render: true,
            defaultProps: true,
            displayName: true,
            propTypes: true
          }, V[Y] = U, V);
        function X(e2) {
          return ("type" in (t2 = e2) && t2.type.$$typeof) === Y ? U : "$$typeof" in e2 ? J[e2.$$typeof] : q;
          var t2;
        }
        var Z = Object.defineProperty,
          K = Object.getOwnPropertyNames,
          Q = Object.getOwnPropertySymbols,
          ee = Object.getOwnPropertyDescriptor,
          te = Object.getPrototypeOf,
          ne = Object.prototype;
        function oe(e2, t2, n2) {
          if ("string" != typeof t2) {
            if (ne) {
              var o2 = te(t2);
              o2 && o2 !== ne && oe(e2, o2, n2);
            }
            var r2 = K(t2);
            Q && (r2 = r2.concat(Q(t2)));
            for (var s2 = X(e2), i2 = X(t2), a2 = 0; a2 < r2.length; ++a2) {
              var c2 = r2[a2];
              if (!(c2 in H || n2 && n2[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
                var l2 = ee(t2, c2);
                try {
                  Z(e2, c2, l2);
                } catch (e3) {}
              }
            }
          }
          return e2;
        }
        function re(e2) {
          return "function" == typeof e2;
        }
        function se(e2) {
          return "object" == typeof e2 && "styledComponentId" in e2;
        }
        function ie(e2, t2) {
          return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
        }
        function ae(e2, t2) {
          if (0 === e2.length) return "";
          for (var n2 = e2[0], o2 = 1; o2 < e2.length; o2++) n2 += e2[o2];
          return n2;
        }
        function ce(e2) {
          return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
        }
        function le(e2, t2, n2) {
          if (void 0 === n2 && (n2 = false), !n2 && !ce(e2) && !Array.isArray(e2)) return t2;
          if (Array.isArray(t2)) for (var o2 = 0; o2 < t2.length; o2++) e2[o2] = le(e2[o2], t2[o2]);else if (ce(t2)) for (var o2 in t2) e2[o2] = le(e2[o2], t2[o2]);
          return e2;
        }
        function ue(e2, t2) {
          Object.defineProperty(e2, "toString", {
            value: t2
          });
        }
        function he(t2) {
          for (var n2 = [], o2 = 1; o2 < arguments.length; o2++) n2[o2 - 1] = arguments[o2];
          return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : ""));
        }
        var fe = function () {
            function e2(e3) {
              this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
            }
            return e2.prototype.indexOfGroup = function (e3) {
              for (var t2 = 0, n2 = 0; n2 < e3; n2++) t2 += this.groupSizes[n2];
              return t2;
            }, e2.prototype.insertRules = function (e3, t2) {
              if (e3 >= this.groupSizes.length) {
                for (var n2 = this.groupSizes, o2 = n2.length, r2 = o2; e3 >= r2;) if ((r2 <<= 1) < 0) throw he(16, "".concat(e3));
                this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n2), this.length = r2;
                for (var s2 = o2; s2 < r2; s2++) this.groupSizes[s2] = 0;
              }
              for (var i2 = this.indexOfGroup(e3 + 1), a2 = (s2 = 0, t2.length); s2 < a2; s2++) this.tag.insertRule(i2, t2[s2]) && (this.groupSizes[e3]++, i2++);
            }, e2.prototype.clearGroup = function (e3) {
              if (e3 < this.length) {
                var t2 = this.groupSizes[e3],
                  n2 = this.indexOfGroup(e3),
                  o2 = n2 + t2;
                this.groupSizes[e3] = 0;
                for (var r2 = n2; r2 < o2; r2++) this.tag.deleteRule(n2);
              }
            }, e2.prototype.getGroup = function (e3) {
              var t2 = "";
              if (e3 >= this.length || 0 === this.groupSizes[e3]) return t2;
              for (var n2 = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r2 = o2 + n2, s2 = o2; s2 < r2; s2++) t2 += "".concat(this.tag.getRule(s2)).concat(g);
              return t2;
            }, e2;
          }(),
          ye = /* @__PURE__ */new Map(),
          ve = /* @__PURE__ */new Map(),
          ge = 1,
          Se = function (e2) {
            if (ye.has(e2)) return ye.get(e2);
            for (; ve.has(ge);) ge++;
            var t2 = ge++;
            return ye.set(e2, t2), ve.set(t2, e2), t2;
          },
          we = function (e2, t2) {
            ge = t2 + 1, ye.set(e2, t2), ve.set(t2, e2);
          },
          be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]'),
          Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),
          Ne = function (e2, t2, n2) {
            for (var o2, r2 = n2.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++) (o2 = r2[s2]) && e2.registerName(t2, o2);
          },
          Pe = function (e2, t2) {
            for (var n2, o2 = (null !== (n2 = t2.textContent) && void 0 !== n2 ? n2 : "").split(g), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
              var a2 = o2[s2].trim();
              if (a2) {
                var c2 = a2.match(Ee);
                if (c2) {
                  var l2 = 0 | parseInt(c2[1], 10),
                    u2 = c2[2];
                  0 !== l2 && (we(u2, l2), Ne(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
                } else r2.push(a2);
              }
            }
          },
          _e = function (e2) {
            for (var t2 = document.querySelectorAll(be), n2 = 0, o2 = t2.length; n2 < o2; n2++) {
              var r2 = t2[n2];
              r2 && r2.getAttribute(f) !== m && (Pe(e2, r2), r2.parentNode && r2.parentNode.removeChild(r2));
            }
          };
        function Ce() {
          return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
        }
        var Ie = function (e2) {
            var t2 = document.head,
              n2 = e2 || t2,
              o2 = document.createElement("style"),
              r2 = function (e3) {
                var t3 = Array.from(e3.querySelectorAll("style[".concat(f, "]")));
                return t3[t3.length - 1];
              }(n2),
              s2 = void 0 !== r2 ? r2.nextSibling : null;
            o2.setAttribute(f, m), o2.setAttribute(y, v);
            var i2 = Ce();
            return i2 && o2.setAttribute("nonce", i2), n2.insertBefore(o2, s2), o2;
          },
          Ae = function () {
            function e2(e3) {
              this.element = Ie(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function (e4) {
                if (e4.sheet) return e4.sheet;
                for (var t2 = document.styleSheets, n2 = 0, o2 = t2.length; n2 < o2; n2++) {
                  var r2 = t2[n2];
                  if (r2.ownerNode === e4) return r2;
                }
                throw he(17);
              }(this.element), this.length = 0;
            }
            return e2.prototype.insertRule = function (e3, t2) {
              try {
                return this.sheet.insertRule(t2, e3), this.length++, true;
              } catch (e4) {
                return false;
              }
            }, e2.prototype.deleteRule = function (e3) {
              this.sheet.deleteRule(e3), this.length--;
            }, e2.prototype.getRule = function (e3) {
              var t2 = this.sheet.cssRules[e3];
              return t2 && t2.cssText ? t2.cssText : "";
            }, e2;
          }(),
          Oe = function () {
            function e2(e3) {
              this.element = Ie(e3), this.nodes = this.element.childNodes, this.length = 0;
            }
            return e2.prototype.insertRule = function (e3, t2) {
              if (e3 <= this.length && e3 >= 0) {
                var n2 = document.createTextNode(t2);
                return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
              }
              return false;
            }, e2.prototype.deleteRule = function (e3) {
              this.element.removeChild(this.nodes[e3]), this.length--;
            }, e2.prototype.getRule = function (e3) {
              return e3 < this.length ? this.nodes[e3].textContent : "";
            }, e2;
          }(),
          De = function () {
            function e2(e3) {
              this.rules = [], this.length = 0;
            }
            return e2.prototype.insertRule = function (e3, t2) {
              return e3 <= this.length && (this.rules.splice(e3, 0, t2), this.length++, true);
            }, e2.prototype.deleteRule = function (e3) {
              this.rules.splice(e3, 1), this.length--;
            }, e2.prototype.getRule = function (e3) {
              return e3 < this.length ? this.rules[e3] : "";
            }, e2;
          }(),
          Re = S,
          Te = {
            isServer: !S,
            useCSSOMInjection: !w
          },
          ke = function () {
            function e2(e3, n2, o2) {
              void 0 === e3 && (e3 = C), void 0 === n2 && (n2 = {});
              var r2 = this;
              this.options = __assign(__assign({}, Te), e3), this.gs = n2, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function () {
                return function (e4) {
                  for (var t2 = e4.getTag(), n3 = t2.length, o3 = "", r3 = function (n4) {
                      var r4 = function (e5) {
                        return ve.get(e5);
                      }(n4);
                      if (void 0 === r4) return "continue";
                      var s3 = e4.names.get(r4),
                        i2 = t2.getGroup(n4);
                      if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
                      var a2 = "".concat(f, ".g").concat(n4, '[id="').concat(r4, '"]'),
                        c2 = "";
                      void 0 !== s3 && s3.forEach(function (e5) {
                        e5.length > 0 && (c2 += "".concat(e5, ","));
                      }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat(g);
                    }, s2 = 0; s2 < n3; s2++) r3(s2);
                  return o3;
                }(r2);
              });
            }
            return e2.registerId = function (e3) {
              return Se(e3);
            }, e2.prototype.rehydrate = function () {
              !this.server && S && _e(this);
            }, e2.prototype.reconstructWithOptions = function (n2, o2) {
              return void 0 === o2 && (o2 = true), new e2(__assign(__assign({}, this.options), n2), this.gs, o2 && this.names || void 0);
            }, e2.prototype.allocateGSInstance = function (e3) {
              return this.gs[e3] = (this.gs[e3] || 0) + 1;
            }, e2.prototype.getTag = function () {
              return this.tag || (this.tag = (e3 = function (e4) {
                var t2 = e4.useCSSOMInjection,
                  n2 = e4.target;
                return e4.isServer ? new De(n2) : t2 ? new Ae(n2) : new Oe(n2);
              }(this.options), new fe(e3)));
              var e3;
            }, e2.prototype.hasNameForId = function (e3, t2) {
              return this.names.has(e3) && this.names.get(e3).has(t2);
            }, e2.prototype.registerName = function (e3, t2) {
              if (Se(e3), this.names.has(e3)) this.names.get(e3).add(t2);else {
                var n2 = /* @__PURE__ */new Set();
                n2.add(t2), this.names.set(e3, n2);
              }
            }, e2.prototype.insertRules = function (e3, t2, n2) {
              this.registerName(e3, t2), this.getTag().insertRules(Se(e3), n2);
            }, e2.prototype.clearNames = function (e3) {
              this.names.has(e3) && this.names.get(e3).clear();
            }, e2.prototype.clearRules = function (e3) {
              this.getTag().clearGroup(Se(e3)), this.clearNames(e3);
            }, e2.prototype.clearTag = function () {
              this.tag = void 0;
            }, e2;
          }(),
          je = /&/g,
          xe = /^\s*\/\/.*$/gm;
        function Ve(e2, t2) {
          return e2.map(function (e3) {
            return "rule" === e3.type && (e3.value = "".concat(t2, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t2, " ")), e3.props = e3.props.map(function (e4) {
              return "".concat(t2, " ").concat(e4);
            })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Ve(e3.children, t2)), e3;
          });
        }
        function Fe(e2) {
          var t2,
            n2,
            o2,
            r2 = C,
            s2 = r2.options,
            i2 = void 0 === s2 ? C : s2,
            a2 = r2.plugins,
            c2 = void 0 === a2 ? _ : a2,
            l2 = function (e3, o3, r3) {
              return r3.startsWith(n2) && r3.endsWith(n2) && r3.replaceAll(n2, "").length > 0 ? ".".concat(t2) : e3;
            },
            u2 = c2.slice();
          u2.push(function (e3) {
            e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(je, n2).replace(o2, l2));
          }), i2.prefix && u2.push(prefixer), u2.push(stringify);
          var p2 = function (e3, r3, s3, a3) {
            void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t2 = a3, n2 = r3, o2 = new RegExp("\\".concat(n2, "\\b"), "g");
            var c3 = e3.replace(xe, ""),
              l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
            i2.namespace && (l3 = Ve(l3, i2.namespace));
            var p3 = [];
            return serialize(l3, middleware(u2.concat(rulesheet(function (e4) {
              return p3.push(e4);
            })))), p3;
          };
          return p2.hash = c2.length ? c2.reduce(function (e3, t3) {
            return t3.name || he(15), M(e3, t3.name);
          }, F).toString() : "", p2;
        }
        var Me = new ke(),
          ze = Fe(),
          $e = React$1.createContext({
            shouldForwardProp: void 0,
            styleSheet: Me,
            stylis: ze
          });
        $e.Consumer;
        React$1.createContext(void 0);
        function Ge() {
          return reactExports.useContext($e);
        }
        var We = function () {
            function e2(e3, t2) {
              var n2 = this;
              this.inject = function (e4, t3) {
                void 0 === t3 && (t3 = ze);
                var o2 = n2.name + t3.hash;
                e4.hasNameForId(n2.id, o2) || e4.insertRules(n2.id, o2, t3(n2.rules, o2, "@keyframes"));
              }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t2, ue(this, function () {
                throw he(12, String(n2.name));
              });
            }
            return e2.prototype.getName = function (e3) {
              return void 0 === e3 && (e3 = ze), this.name + e3.hash;
            }, e2;
          }(),
          qe = function (e2) {
            return e2 >= "A" && e2 <= "Z";
          };
        function He(e2) {
          for (var t2 = "", n2 = 0; n2 < e2.length; n2++) {
            var o2 = e2[n2];
            if (1 === n2 && "-" === o2 && "-" === e2[0]) return e2;
            qe(o2) ? t2 += "-" + o2.toLowerCase() : t2 += o2;
          }
          return t2.startsWith("ms-") ? "-" + t2 : t2;
        }
        var Ue = function (e2) {
            return null == e2 || false === e2 || "" === e2;
          },
          Je = function (t2) {
            var n2,
              o2,
              r2 = [];
            for (var s2 in t2) {
              var i2 = t2[s2];
              t2.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r2.push("".concat(He(s2), ": ").concat((n2 = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n2 in unitlessKeys || n2.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
            }
            return r2;
          };
        function Xe(e2, t2, n2, o2) {
          if (Ue(e2)) return [];
          if (se(e2)) return [".".concat(e2.styledComponentId)];
          if (re(e2)) {
            if (!re(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t2) return [e2];
            var r2 = e2(t2);
            return Xe(r2, t2, n2, o2);
          }
          var s2;
          return e2 instanceof We ? n2 ? (e2.inject(n2, o2), [e2.getName(o2)]) : [e2] : ce(e2) ? Je(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(_, e2.map(function (e3) {
            return Xe(e3, t2, n2, o2);
          })) : [e2.toString()];
        }
        function Ze(e2) {
          for (var t2 = 0; t2 < e2.length; t2 += 1) {
            var n2 = e2[t2];
            if (re(n2) && !se(n2)) return false;
          }
          return true;
        }
        var Ke = z(v),
          Qe = function () {
            function e2(e3, t2, n2) {
              this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && Ze(e3), this.componentId = t2, this.baseHash = M(Ke, t2), this.baseStyle = n2, ke.registerId(t2);
            }
            return e2.prototype.generateAndInjectStyles = function (e3, t2, n2) {
              var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t2, n2) : "";
              if (this.isStatic && !n2.hash) {
                if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId)) o2 = ie(o2, this.staticRulesId);else {
                  var r2 = ae(Xe(this.rules, e3, t2, n2)),
                    s2 = x(M(this.baseHash, r2) >>> 0);
                  if (!t2.hasNameForId(this.componentId, s2)) {
                    var i2 = n2(r2, ".".concat(s2), void 0, this.componentId);
                    t2.insertRules(this.componentId, s2, i2);
                  }
                  o2 = ie(o2, s2), this.staticRulesId = s2;
                }
              } else {
                for (var a2 = M(this.baseHash, n2.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
                  var u2 = this.rules[l2];
                  if ("string" == typeof u2) c2 += u2;else if (u2) {
                    var p2 = ae(Xe(u2, e3, t2, n2));
                    a2 = M(a2, p2 + l2), c2 += p2;
                  }
                }
                if (c2) {
                  var d2 = x(a2 >>> 0);
                  t2.hasNameForId(this.componentId, d2) || t2.insertRules(this.componentId, d2, n2(c2, ".".concat(d2), void 0, this.componentId)), o2 = ie(o2, d2);
                }
              }
              return o2;
            }, e2;
          }(),
          et = React$1.createContext(void 0);
        et.Consumer;
        var rt = {};
        function it(e2, r2, s2) {
          var i2 = se(e2),
            a2 = e2,
            c2 = !L(e2),
            p2 = r2.attrs,
            d2 = void 0 === p2 ? _ : p2,
            h2 = r2.componentId,
            f2 = void 0 === h2 ? function (e3, t2) {
              var n2 = "string" != typeof e3 ? "sc" : R(e3);
              rt[n2] = (rt[n2] || 0) + 1;
              var o2 = "".concat(n2, "-").concat($(v + n2 + rt[n2]));
              return t2 ? "".concat(t2, "-").concat(o2) : o2;
            }(r2.displayName, r2.parentComponentId) : h2,
            m2 = r2.displayName,
            y2 = void 0 === m2 ? function (e3) {
              return L(e3) ? "styled.".concat(e3) : "Styled(".concat(B(e3), ")");
            }(e2) : m2,
            g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2,
            S2 = i2 && a2.attrs ? a2.attrs.concat(d2).filter(Boolean) : d2,
            w2 = r2.shouldForwardProp;
          if (i2 && a2.shouldForwardProp) {
            var b2 = a2.shouldForwardProp;
            if (r2.shouldForwardProp) {
              var E2 = r2.shouldForwardProp;
              w2 = function (e3, t2) {
                return b2(e3, t2) && E2(e3, t2);
              };
            } else w2 = b2;
          }
          var N2 = new Qe(s2, g2, i2 ? a2.componentStyle : void 0);
          function O2(e3, r3) {
            return function (e4, r4, s3) {
              var i3 = e4.attrs,
                a3 = e4.componentStyle,
                c3 = e4.defaultProps,
                p3 = e4.foldedComponentIds,
                d3 = e4.styledComponentId,
                h3 = e4.target,
                f3 = React$1.useContext(et),
                m3 = Ge(),
                y3 = e4.shouldForwardProp || m3.shouldForwardProp;
              var v2 = I(r4, f3, c3) || C,
                g3 = function (e5, n2, o2) {
                  for (var r5, s4 = __assign(__assign({}, n2), {
                      className: void 0,
                      theme: o2
                    }), i4 = 0; i4 < e5.length; i4 += 1) {
                    var a4 = re(r5 = e5[i4]) ? r5(s4) : r5;
                    for (var c4 in a4) s4[c4] = "className" === c4 ? ie(s4[c4], a4[c4]) : "style" === c4 ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
                  }
                  return n2.className && (s4.className = ie(s4.className, n2.className)), s4;
                }(i3, r4, v2),
                S3 = g3.as || h3,
                w3 = {};
              for (var b3 in g3) void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v2 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y3 && !y3(b3, S3) || (w3[b3] = g3[b3], y3 || true));
              var E3 = function (e5, t2) {
                var n2 = Ge(),
                  o2 = e5.generateAndInjectStyles(t2, n2.styleSheet, n2.stylis);
                return o2;
              }(a3, g3);
              var N3 = ie(p3, d3);
              return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, s3 && (w3.ref = s3), reactExports.createElement(S3, w3);
            }(D2, e3, r3);
          }
          O2.displayName = y2;
          var D2 = React$1.forwardRef(O2);
          return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e2, Object.defineProperty(D2, "defaultProps", {
            get: function () {
              return this._foldedDefaultProps;
            },
            set: function (e3) {
              this._foldedDefaultProps = i2 ? function (e4) {
                for (var t2 = [], n2 = 1; n2 < arguments.length; n2++) t2[n2 - 1] = arguments[n2];
                for (var o2 = 0, r3 = t2; o2 < r3.length; o2++) le(e4, r3[o2], true);
                return e4;
              }({}, a2.defaultProps, e3) : e3;
            }
          }), ue(D2, function () {
            return ".".concat(D2.styledComponentId);
          }), c2 && oe(D2, e2, {
            attrs: true,
            componentStyle: true,
            displayName: true,
            foldedComponentIds: true,
            shouldForwardProp: true,
            styledComponentId: true,
            target: true
          }), D2;
        }
        function at(e2, t2) {
          for (var n2 = [e2[0]], o2 = 0, r2 = t2.length; o2 < r2; o2 += 1) n2.push(t2[o2], e2[o2 + 1]);
          return n2;
        }
        var ct = function (e2) {
          return Object.assign(e2, {
            isCss: true
          });
        };
        function lt(t2) {
          for (var n2 = [], o2 = 1; o2 < arguments.length; o2++) n2[o2 - 1] = arguments[o2];
          if (re(t2) || ce(t2)) return ct(Xe(at(_, __spreadArray([t2], n2, true))));
          var r2 = t2;
          return 0 === n2.length && 1 === r2.length && "string" == typeof r2[0] ? Xe(r2) : ct(Xe(at(r2, n2)));
        }
        function ut(n2, o2, r2) {
          if (void 0 === r2 && (r2 = C), !o2) throw he(1, o2);
          var s2 = function (t2) {
            for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
            return n2(o2, r2, lt.apply(void 0, __spreadArray([t2], s3, false)));
          };
          return s2.attrs = function (e2) {
            return ut(n2, o2, __assign(__assign({}, r2), {
              attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean)
            }));
          }, s2.withConfig = function (e2) {
            return ut(n2, o2, __assign(__assign({}, r2), e2));
          }, s2;
        }
        var pt = function (e2) {
            return ut(it, e2);
          },
          dt = pt;
        A.forEach(function (e2) {
          dt[e2] = pt(e2);
        });
        const InputWrapper = dt.p`
	margin-bottom: var(--ptr-admin-spacing-md);
`;
        const ShortcodeControlInner = dt.div`
	display: flex;
	gap: var(--ptr-admin-spacing-sm);
`;
        function ShortcodeElement({
          clipboardValue,
          label,
          help,
          fieldName = "petitioner_shortcode",
          width = "auto"
        }) {
          const [isCopied, setIsCopied] = reactExports.useState(false);
          const handleCopy = () => {
            setIsCopied(true);
            setTimeout(() => setIsCopied(false), 3e3);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(InputWrapper, {
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(BaseControl, {
              help,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(BaseControl.VisualLabel, {
                children: label
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(ShortcodeControlInner, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                  disabled: true,
                  type: "text",
                  name: fieldName,
                  id: fieldName,
                  value: clipboardValue,
                  onChange: () => {},
                  style: {
                    width
                  }
                }), /* @__PURE__ */jsxRuntimeExports.jsx(ClipboardButton, {
                  size: "compact",
                  text: clipboardValue,
                  className: "components-button is-secondary",
                  onCopy: handleCopy,
                  children: !isCopied ? __("Copy", "petitioner") : __("Copied!", "petitioner")
                })]
              })]
            })
          });
        }
        const UPDATE_ACTION = "petitioner_update_submission";
        const FETCH_ACTION = "petitioner_fetch_submissions";
        const DELETE_ACTION = "petitioner_delete_submission";

        /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */

        const {
          entries,
          setPrototypeOf,
          isFrozen,
          getPrototypeOf,
          getOwnPropertyDescriptor
        } = Object;
        let {
          freeze,
          seal,
          create
        } = Object; // eslint-disable-line import/no-mutable-exports
        let {
          apply,
          construct
        } = typeof Reflect !== 'undefined' && Reflect;
        if (!freeze) {
          freeze = function freeze(x) {
            return x;
          };
        }
        if (!seal) {
          seal = function seal(x) {
            return x;
          };
        }
        if (!apply) {
          apply = function apply(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!construct) {
          construct = function construct(Func, args) {
            return new Func(...args);
          };
        }
        const arrayForEach = unapply(Array.prototype.forEach);
        const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
        const arrayPop = unapply(Array.prototype.pop);
        const arrayPush = unapply(Array.prototype.push);
        const arraySplice = unapply(Array.prototype.splice);
        const stringToLowerCase = unapply(String.prototype.toLowerCase);
        const stringToString = unapply(String.prototype.toString);
        const stringMatch = unapply(String.prototype.match);
        const stringReplace = unapply(String.prototype.replace);
        const stringIndexOf = unapply(String.prototype.indexOf);
        const stringTrim = unapply(String.prototype.trim);
        const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
        const regExpTest = unapply(RegExp.prototype.test);
        const typeErrorCreate = unconstruct(TypeError);
        /**
         * Creates a new function that calls the given function with a specified thisArg and arguments.
         *
         * @param func - The function to be wrapped and called.
         * @returns A new function that calls the given function with a specified thisArg and arguments.
         */
        function unapply(func) {
          return function (thisArg) {
            if (thisArg instanceof RegExp) {
              thisArg.lastIndex = 0;
            }
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        /**
         * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
         *
         * @param func - The constructor function to be wrapped and called.
         * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
         */
        function unconstruct(func) {
          return function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        /**
         * Add properties to a lookup table
         *
         * @param set - The set to which elements will be added.
         * @param array - The array containing elements to be added to the set.
         * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
         * @returns The modified set with added elements.
         */
        function addToSet(set, array) {
          let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
          if (setPrototypeOf) {
            // Make 'in' and truthy checks like Boolean(set.constructor)
            // independent of any properties defined on Object.prototype.
            // Prevent prototype setters from intercepting set as a this value.
            setPrototypeOf(set, null);
          }
          let l = array.length;
          while (l--) {
            let element = array[l];
            if (typeof element === 'string') {
              const lcElement = transformCaseFunc(element);
              if (lcElement !== element) {
                // Config presets (e.g. tags.js, attrs.js) are immutable.
                if (!isFrozen(array)) {
                  array[l] = lcElement;
                }
                element = lcElement;
              }
            }
            set[element] = true;
          }
          return set;
        }
        /**
         * Clean up an array to harden against CSPP
         *
         * @param array - The array to be cleaned.
         * @returns The cleaned version of the array
         */
        function cleanArray(array) {
          for (let index = 0; index < array.length; index++) {
            const isPropertyExist = objectHasOwnProperty(array, index);
            if (!isPropertyExist) {
              array[index] = null;
            }
          }
          return array;
        }
        /**
         * Shallow clone an object
         *
         * @param object - The object to be cloned.
         * @returns A new object that copies the original.
         */
        function clone(object) {
          const newObject = create(null);
          for (const [property, value] of entries(object)) {
            const isPropertyExist = objectHasOwnProperty(object, property);
            if (isPropertyExist) {
              if (Array.isArray(value)) {
                newObject[property] = cleanArray(value);
              } else if (value && typeof value === 'object' && value.constructor === Object) {
                newObject[property] = clone(value);
              } else {
                newObject[property] = value;
              }
            }
          }
          return newObject;
        }
        /**
         * This method automatically checks if the prop is function or getter and behaves accordingly.
         *
         * @param object - The object to look up the getter function in its prototype chain.
         * @param prop - The property name for which to find the getter function.
         * @returns The getter function found in the prototype chain or a fallback function.
         */
        function lookupGetter(object, prop) {
          while (object !== null) {
            const desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === 'function') {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue() {
            return null;
          }
          return fallbackValue;
        }
        const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
        const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
        const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
        // List of SVG elements that are disallowed by default.
        // We still need to know them so that we can do namespace
        // checks properly in case one wants to add them to
        // allow-list.
        const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
        const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
        // Similarly to SVG, we want to know all MathML elements,
        // even those that we disallow by default.
        const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
        const text = freeze(['#text']);
        const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
        const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
        const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
        const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

        // eslint-disable-next-line unicorn/better-regex
        const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
        const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
        const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
        const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
        const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
        const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
        );
        const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
        );
        const DOCTYPE_NAME = seal(/^html$/i);
        const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
        var EXPRESSIONS = /*#__PURE__*/Object.freeze({
          __proto__: null,
          ARIA_ATTR: ARIA_ATTR,
          ATTR_WHITESPACE: ATTR_WHITESPACE,
          CUSTOM_ELEMENT: CUSTOM_ELEMENT,
          DATA_ATTR: DATA_ATTR,
          DOCTYPE_NAME: DOCTYPE_NAME,
          ERB_EXPR: ERB_EXPR,
          IS_ALLOWED_URI: IS_ALLOWED_URI,
          IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
          MUSTACHE_EXPR: MUSTACHE_EXPR,
          TMPLIT_EXPR: TMPLIT_EXPR
        });

        /* eslint-disable @typescript-eslint/indent */
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
        const NODE_TYPE = {
          element: 1,
          text: 3,
          // Deprecated
          progressingInstruction: 7,
          comment: 8,
          document: 9
        };
        const getGlobal = function getGlobal() {
          return typeof window === 'undefined' ? null : window;
        };
        /**
         * Creates a no-op policy for internal use only.
         * Don't export this function outside this module!
         * @param trustedTypes The policy factory.
         * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
         * @return The policy created (or null, if Trusted Types
         * are not supported or creating the policy failed).
         */
        const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
          if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
            return null;
          }
          // Allow the callers to control the unique policy name
          // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
          // Policy creation with duplicate names throws in Trusted Types.
          let suffix = null;
          const ATTR_NAME = 'data-tt-policy-suffix';
          if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
            suffix = purifyHostElement.getAttribute(ATTR_NAME);
          }
          const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML(html) {
                return html;
              },
              createScriptURL(scriptUrl) {
                return scriptUrl;
              }
            });
          } catch (_) {
            // Policy creation failed (most likely another DOMPurify script has
            // already run). Skip creating the policy, as this will only cause errors
            // if TT are enforced.
            console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
            return null;
          }
        };
        const _createHooksMap = function _createHooksMap() {
          return {
            afterSanitizeAttributes: [],
            afterSanitizeElements: [],
            afterSanitizeShadowDOM: [],
            beforeSanitizeAttributes: [],
            beforeSanitizeElements: [],
            beforeSanitizeShadowDOM: [],
            uponSanitizeAttribute: [],
            uponSanitizeElement: [],
            uponSanitizeShadowNode: []
          };
        };
        function createDOMPurify() {
          let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
          const DOMPurify = root => createDOMPurify(root);
          DOMPurify.version = '3.2.6';
          DOMPurify.removed = [];
          if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
            // Not running in a browser, provide a factory function
            // so that you can pass your own Window
            DOMPurify.isSupported = false;
            return DOMPurify;
          }
          let {
            document
          } = window;
          const originalDocument = document;
          const currentScript = originalDocument.currentScript;
          const {
            DocumentFragment,
            HTMLTemplateElement,
            Node,
            Element,
            NodeFilter,
            NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
            HTMLFormElement,
            DOMParser,
            trustedTypes
          } = window;
          const ElementPrototype = Element.prototype;
          const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
          const remove = lookupGetter(ElementPrototype, 'remove');
          const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
          const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
          const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
          // As per issue #47, the web-components registry is inherited by a
          // new document created via createHTMLDocument. As per the spec
          // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
          // a new empty registry is used when creating a template contents owner
          // document, so we use that as our parent document to ensure nothing
          // is inherited.
          if (typeof HTMLTemplateElement === 'function') {
            const template = document.createElement('template');
            if (template.content && template.content.ownerDocument) {
              document = template.content.ownerDocument;
            }
          }
          let trustedTypesPolicy;
          let emptyHTML = '';
          const {
            implementation,
            createNodeIterator,
            createDocumentFragment,
            getElementsByTagName
          } = document;
          const {
            importNode
          } = originalDocument;
          let hooks = _createHooksMap();
          /**
           * Expose whether this browser supports running the full DOMPurify.
           */
          DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
          const {
            MUSTACHE_EXPR,
            ERB_EXPR,
            TMPLIT_EXPR,
            DATA_ATTR,
            ARIA_ATTR,
            IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE,
            CUSTOM_ELEMENT
          } = EXPRESSIONS;
          let {
            IS_ALLOWED_URI: IS_ALLOWED_URI$1
          } = EXPRESSIONS;
          /**
           * We consider the elements and attributes below to be safe. Ideally
           * don't add any new ones but feel free to remove unwanted ones.
           */
          /* allowed element names */
          let ALLOWED_TAGS = null;
          const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
          /* Allowed attribute names */
          let ALLOWED_ATTR = null;
          const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
          /*
           * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
           * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
           * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
           * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
           */
          let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
          let FORBID_TAGS = null;
          /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
          let FORBID_ATTR = null;
          /* Decide if ARIA attributes are okay */
          let ALLOW_ARIA_ATTR = true;
          /* Decide if custom data attributes are okay */
          let ALLOW_DATA_ATTR = true;
          /* Decide if unknown protocols are okay */
          let ALLOW_UNKNOWN_PROTOCOLS = false;
          /* Decide if self-closing tags in attributes are allowed.
           * Usually removed due to a mXSS issue in jQuery 3.0 */
          let ALLOW_SELF_CLOSE_IN_ATTR = true;
          /* Output should be safe for common template engines.
           * This means, DOMPurify removes data attributes, mustaches and ERB
           */
          let SAFE_FOR_TEMPLATES = false;
          /* Output should be safe even for XML used within HTML and alike.
           * This means, DOMPurify removes comments when containing risky content.
           */
          let SAFE_FOR_XML = true;
          /* Decide if document with <html>... should be returned */
          let WHOLE_DOCUMENT = false;
          /* Track whether config is already set on this instance of DOMPurify. */
          let SET_CONFIG = false;
          /* Decide if all elements (e.g. style, script) must be children of
           * document.body. By default, browsers might move them to document.head */
          let FORCE_BODY = false;
          /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
           * string (or a TrustedHTML object if Trusted Types are supported).
           * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
           */
          let RETURN_DOM = false;
          /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
           * string  (or a TrustedHTML object if Trusted Types are supported) */
          let RETURN_DOM_FRAGMENT = false;
          /* Try to return a Trusted Type object instead of a string, return a string in
           * case Trusted Types are not supported  */
          let RETURN_TRUSTED_TYPE = false;
          /* Output should be free from DOM clobbering attacks?
           * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
           */
          let SANITIZE_DOM = true;
          /* Achieve full DOM Clobbering protection by isolating the namespace of named
           * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
           *
           * HTML/DOM spec rules that enable DOM Clobbering:
           *   - Named Access on Window (§7.3.3)
           *   - DOM Tree Accessors (§3.1.5)
           *   - Form Element Parent-Child Relations (§4.10.3)
           *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
           *   - HTMLCollection (§4.2.10.2)
           *
           * Namespace isolation is implemented by prefixing `id` and `name` attributes
           * with a constant string, i.e., `user-content-`
           */
          let SANITIZE_NAMED_PROPS = false;
          const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
          /* Keep element content when removing element? */
          let KEEP_CONTENT = true;
          /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
           * of importing it into a new Document and returning a sanitized copy */
          let IN_PLACE = false;
          /* Allow usage of profiles like html, svg and mathMl */
          let USE_PROFILES = {};
          /* Tags to ignore content of when KEEP_CONTENT is true */
          let FORBID_CONTENTS = null;
          const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
          /* Tags that are safe for data: URIs */
          let DATA_URI_TAGS = null;
          const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
          /* Attributes safe for values like "javascript:" */
          let URI_SAFE_ATTRIBUTES = null;
          const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
          const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
          const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
          const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
          /* Document namespace */
          let NAMESPACE = HTML_NAMESPACE;
          let IS_EMPTY_INPUT = false;
          /* Allowed XHTML+XML namespaces */
          let ALLOWED_NAMESPACES = null;
          const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
          let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
          let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
          // Certain elements are allowed in both SVG and HTML
          // namespace. We need to specify them explicitly
          // so that they don't get erroneously deleted from
          // HTML namespace.
          const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
          /* Parsing of strict XHTML documents */
          let PARSER_MEDIA_TYPE = null;
          const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
          const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
          let transformCaseFunc = null;
          /* Keep a reference to config to pass to hooks */
          let CONFIG = null;
          /* Ideally, do not touch anything below this line */
          /* ______________________________________________ */
          const formElement = document.createElement('form');
          const isRegexOrFunction = function isRegexOrFunction(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          /**
           * _parseConfig
           *
           * @param cfg optional config literal
           */
          // eslint-disable-next-line complexity
          const _parseConfig = function _parseConfig() {
            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            /* Shield configuration object from tampering */
            if (!cfg || typeof cfg !== 'object') {
              cfg = {};
            }
            /* Shield configuration object from prototype pollution */
            cfg = clone(cfg);
            PARSER_MEDIA_TYPE =
            // eslint-disable-next-line unicorn/prefer-includes
            SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
            // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
            transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
            /* Set configuration parameters */
            ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
            ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
            URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
            FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
            USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
            ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
            SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
            RETURN_DOM = cfg.RETURN_DOM || false; // Default false
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
            FORCE_BODY = cfg.FORCE_BODY || false; // Default false
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
            SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
            IN_PLACE = cfg.IN_PLACE || false; // Default false
            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
            HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
            CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            /* Parse profile info */
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, text);
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html$1);
                addToSet(ALLOWED_ATTR, html);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg$1);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl$1);
                addToSet(ALLOWED_ATTR, mathMl);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            /* Merge configuration parameters */
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
            }
            /* Add #text in case KEEP_CONTENT is set to true */
            if (KEEP_CONTENT) {
              ALLOWED_TAGS['#text'] = true;
            }
            /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
            }
            /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ['tbody']);
              delete FORBID_TAGS.tbody;
            }
            if (cfg.TRUSTED_TYPES_POLICY) {
              if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              }
              if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              }
              // Overwrite existing TrustedTypes policy.
              trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
              // Sign local variables required by `sanitize`.
              emptyHTML = trustedTypesPolicy.createHTML('');
            } else {
              // Uninitialized policy, attempt to initialize the internal dompurify policy.
              if (trustedTypesPolicy === undefined) {
                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
              }
              // If creating the internal policy succeeded sign internal variables.
              if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
                emptyHTML = trustedTypesPolicy.createHTML('');
              }
            }
            // Prevent further manipulation of configuration.
            // Not available in IE8, Safari 5, etc.
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          /* Keep track of all possible SVG and MathML tags
           * so that we can perform the namespace checks
           * correctly. */
          const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
          const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
          /**
           * @param element a DOM element whose namespace is being checked
           * @returns Return false if the element has a
           *  namespace that a spec-compliant parser would never
           *  return. Return true otherwise.
           */
          const _checkValidNamespace = function _checkValidNamespace(element) {
            let parent = getParentNode(element);
            // In JSDOM, if we're inside shadow DOM, then parentNode
            // can be null. We just simulate parent in this case.
            if (!parent || !parent.tagName) {
              parent = {
                namespaceURI: NAMESPACE,
                tagName: 'template'
              };
            }
            const tagName = stringToLowerCase(element.tagName);
            const parentTagName = stringToLowerCase(parent.tagName);
            if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
              return false;
            }
            if (element.namespaceURI === SVG_NAMESPACE) {
              // The only way to switch from HTML namespace to SVG
              // is via <svg>. If it happens via any other tag, then
              // it should be killed.
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'svg';
              }
              // The only way to switch from MathML to SVG is via`
              // svg if parent is either <annotation-xml> or MathML
              // text integration points.
              if (parent.namespaceURI === MATHML_NAMESPACE) {
                return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              // We only allow elements that are defined in SVG
              // spec. All others are disallowed in SVG namespace.
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              // The only way to switch from HTML namespace to MathML
              // is via <math>. If it happens via any other tag, then
              // it should be killed.
              if (parent.namespaceURI === HTML_NAMESPACE) {
                return tagName === 'math';
              }
              // The only way to switch from SVG to MathML is via
              // <math> and HTML integration points
              if (parent.namespaceURI === SVG_NAMESPACE) {
                return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
              }
              // We only allow elements that are defined in MathML
              // spec. All others are disallowed in MathML namespace.
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              // The only way to switch from SVG to HTML is via
              // HTML integration points, and from MathML to HTML
              // is via MathML text integration points
              if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              // We disallow tags that are specific for MathML
              // or SVG and should never appear in HTML namespace
              return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            // For XHTML and XML documents that support custom namespaces
            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
              return true;
            }
            // The code should never reach this place (this means
            // that the element somehow got namespace that is not
            // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
            // Return false just in case.
            return false;
          };
          /**
           * _forceRemove
           *
           * @param node a DOM node
           */
          const _forceRemove = function _forceRemove(node) {
            arrayPush(DOMPurify.removed, {
              element: node
            });
            try {
              // eslint-disable-next-line unicorn/prefer-dom-node-remove
              getParentNode(node).removeChild(node);
            } catch (_) {
              remove(node);
            }
          };
          /**
           * _removeAttribute
           *
           * @param name an Attribute name
           * @param element a DOM node
           */
          const _removeAttribute = function _removeAttribute(name, element) {
            try {
              arrayPush(DOMPurify.removed, {
                attribute: element.getAttributeNode(name),
                from: element
              });
            } catch (_) {
              arrayPush(DOMPurify.removed, {
                attribute: null,
                from: element
              });
            }
            element.removeAttribute(name);
            // We void attribute values for unremovable "is" attributes
            if (name === 'is') {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(element);
                } catch (_) {}
              } else {
                try {
                  element.setAttribute(name, '');
                } catch (_) {}
              }
            }
          };
          /**
           * _initDocument
           *
           * @param dirty - a string of dirty markup
           * @return a DOM, filled with the dirty markup
           */
          const _initDocument = function _initDocument(dirty) {
            /* Create a HTML document */
            let doc = null;
            let leadingWhitespace = null;
            if (FORCE_BODY) {
              dirty = '<remove></remove>' + dirty;
            } else {
              /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
              const matches = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches && matches[0];
            }
            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
              // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
            }
            const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            /*
             * Use the DOMParser API by default, fallback later if needs be
             * DOMParser not work for svg when has multiple root element.
             */
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_) {}
            }
            /* Use createHTMLDocument in case DOMParser is not available */
            if (!doc || !doc.documentElement) {
              doc = implementation.createDocument(NAMESPACE, 'template', null);
              try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
              } catch (_) {
                // Syntax error if dirtyPayload is invalid xml
              }
            }
            const body = doc.body || doc.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            /* Work on whole document or just its body */
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
            }
            return WHOLE_DOCUMENT ? doc.documentElement : body;
          };
          /**
           * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
           *
           * @param root The root element or node to start traversing on.
           * @return The created NodeIterator
           */
          const _createNodeIterator = function _createNodeIterator(root) {
            return createNodeIterator.call(root.ownerDocument || root, root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
          };
          /**
           * _isClobbered
           *
           * @param element element to check for clobbering attacks
           * @return true if clobbered, false if safe
           */
          const _isClobbered = function _isClobbered(element) {
            return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
          };
          /**
           * Checks whether the given object is a DOM node.
           *
           * @param value object to check whether it's a DOM node
           * @return true is object is a DOM node
           */
          const _isNode = function _isNode(value) {
            return typeof Node === 'function' && value instanceof Node;
          };
          function _executeHooks(hooks, currentNode, data) {
            arrayForEach(hooks, hook => {
              hook.call(DOMPurify, currentNode, data, CONFIG);
            });
          }
          /**
           * _sanitizeElements
           *
           * @protect nodeName
           * @protect textContent
           * @protect removeChild
           * @param currentNode to check for permission to exist
           * @return true if node was killed, false if left alive
           */
          const _sanitizeElements = function _sanitizeElements(currentNode) {
            let content = null;
            /* Execute a hook if present */
            _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
            /* Check if element is clobbered or can clobber */
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Now let's check the element's type and name */
            const tagName = transformCaseFunc(currentNode.nodeName);
            /* Execute a hook if present */
            _executeHooks(hooks.uponSanitizeElement, currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            /* Detect mXSS attempts abusing namespace confusion */
            if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove any occurrence of processing instructions */
            if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove any kind of possibly harmful comments */
            if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Remove element if anything forbids its presence */
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              /* Check if we have a custom element to handle */
              if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
                  return false;
                }
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
                  return false;
                }
              }
              /* Keep content except for bad-listed elements */
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                const parentNode = getParentNode(currentNode) || currentNode.parentNode;
                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  const childCount = childNodes.length;
                  for (let i = childCount - 1; i >= 0; --i) {
                    const childClone = cloneNode(childNodes[i], true);
                    childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                    parentNode.insertBefore(childClone, getNextSibling(currentNode));
                  }
                }
              }
              _forceRemove(currentNode);
              return true;
            }
            /* Check whether element has a valid namespace */
            if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Make sure that older browsers don't get fallback-tag mXSS */
            if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            /* Sanitize element content to be template-safe */
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
              /* Get the element's text content */
              content = currentNode.textContent;
              arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
                content = stringReplace(content, expr, ' ');
              });
              if (currentNode.textContent !== content) {
                arrayPush(DOMPurify.removed, {
                  element: currentNode.cloneNode()
                });
                currentNode.textContent = content;
              }
            }
            /* Execute a hook if present */
            _executeHooks(hooks.afterSanitizeElements, currentNode, null);
            return false;
          };
          /**
           * _isValidAttribute
           *
           * @param lcTag Lowercase tag name of containing element.
           * @param lcName Lowercase attribute name.
           * @param value Attribute value.
           * @return Returns true if `value` is valid, otherwise false.
           */
          // eslint-disable-next-line complexity
          const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
            /* Make sure attribute cannot clobber */
            if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
              return false;
            }
            /* Allow valid data-* attributes: At least one character after "-"
                (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
                XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
                We don't need to check the value; it's always URI safe. */
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
              // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {
                return false;
              }
              /* Check value is safe. First, is attr inert? If so, is safe */
            } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {
              return false;
            } else ;
            return true;
          };
          /**
           * _isBasicCustomElement
           * checks if at least one dash is included in tagName, and it's not the first char
           * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
           *
           * @param tagName name of the tag of the node to sanitize
           * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
           */
          const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
            return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
          };
          /**
           * _sanitizeAttributes
           *
           * @protect attributes
           * @protect nodeName
           * @protect removeAttribute
           * @protect setAttribute
           *
           * @param currentNode to sanitize
           */
          const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
            /* Execute a hook if present */
            _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
            const {
              attributes
            } = currentNode;
            /* Check if we have attributes; if not we might have a text node */
            if (!attributes || _isClobbered(currentNode)) {
              return;
            }
            const hookEvent = {
              attrName: '',
              attrValue: '',
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR,
              forceKeepAttr: undefined
            };
            let l = attributes.length;
            /* Go backwards over all attributes; safely remove bad ones */
            while (l--) {
              const attr = attributes[l];
              const {
                name,
                namespaceURI,
                value: attrValue
              } = attr;
              const lcName = transformCaseFunc(name);
              const initValue = attrValue;
              let value = name === 'value' ? initValue : stringTrim(initValue);
              /* Execute a hook if present */
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
              _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
              value = hookEvent.attrValue;
              /* Full DOM Clobbering protection via namespace isolation,
               * Prefix id and name attributes with `user-content-`
               */
              if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
                // Remove the attribute with this value
                _removeAttribute(name, currentNode);
                // Prefix the value and later re-create the attribute with the sanitized value
                value = SANITIZE_NAMED_PROPS_PREFIX + value;
              }
              /* Work around a security issue with comments inside attributes */
              if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
              }
              /* Did the hooks approve of the attribute? */
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              /* Did the hooks approve of the attribute? */
              if (!hookEvent.keepAttr) {
                _removeAttribute(name, currentNode);
                continue;
              }
              /* Work around a security issue in jQuery 3.0 */
              if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
                _removeAttribute(name, currentNode);
                continue;
              }
              /* Sanitize attribute content to be template-safe */
              if (SAFE_FOR_TEMPLATES) {
                arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
                  value = stringReplace(value, expr, ' ');
                });
              }
              /* Is `value` valid for this attribute? */
              const lcTag = transformCaseFunc(currentNode.nodeName);
              if (!_isValidAttribute(lcTag, lcName, value)) {
                _removeAttribute(name, currentNode);
                continue;
              }
              /* Handle attributes that require Trusted Types */
              if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
                if (namespaceURI) ;else {
                  switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                    case 'TrustedHTML':
                      {
                        value = trustedTypesPolicy.createHTML(value);
                        break;
                      }
                    case 'TrustedScriptURL':
                      {
                        value = trustedTypesPolicy.createScriptURL(value);
                        break;
                      }
                  }
                }
              }
              /* Handle invalid data-* attribute set by try-catching it */
              if (value !== initValue) {
                try {
                  if (namespaceURI) {
                    currentNode.setAttributeNS(namespaceURI, name, value);
                  } else {
                    /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                    currentNode.setAttribute(name, value);
                  }
                  if (_isClobbered(currentNode)) {
                    _forceRemove(currentNode);
                  } else {
                    arrayPop(DOMPurify.removed);
                  }
                } catch (_) {
                  _removeAttribute(name, currentNode);
                }
              }
            }
            /* Execute a hook if present */
            _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
          };
          /**
           * _sanitizeShadowDOM
           *
           * @param fragment to iterate over recursively
           */
          const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
            let shadowNode = null;
            const shadowIterator = _createNodeIterator(fragment);
            /* Execute a hook if present */
            _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              /* Execute a hook if present */
              _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
              /* Sanitize tags and elements */
              _sanitizeElements(shadowNode);
              /* Check attributes next */
              _sanitizeAttributes(shadowNode);
              /* Deep shadow DOM detected */
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(shadowNode.content);
              }
            }
            /* Execute a hook if present */
            _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
          };
          // eslint-disable-next-line complexity
          DOMPurify.sanitize = function (dirty) {
            let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            let body = null;
            let importedNode = null;
            let currentNode = null;
            let returnNode = null;
            /* Make sure we have a string to sanitize.
              DO NOT return early, as this will return the wrong type if
              the user has requested a DOM object rather than a string */
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = '<!-->';
            }
            /* Stringify, in case dirty is an object */
            if (typeof dirty !== 'string' && !_isNode(dirty)) {
              if (typeof dirty.toString === 'function') {
                dirty = dirty.toString();
                if (typeof dirty !== 'string') {
                  throw typeErrorCreate('dirty is not a string, aborting');
                }
              } else {
                throw typeErrorCreate('toString is not a function');
              }
            }
            /* Return dirty HTML if DOMPurify cannot run */
            if (!DOMPurify.isSupported) {
              return dirty;
            }
            /* Assign config vars */
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            /* Clean up removed elements */
            DOMPurify.removed = [];
            /* Check if dirty is correctly typed for IN_PLACE */
            if (typeof dirty === 'string') {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              /* Do some early pre-sanitization to avoid unsafe root nodes */
              if (dirty.nodeName) {
                const tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
                }
              }
            } else if (dirty instanceof Node) {
              /* If dirty is a DOM element, append to an empty document to avoid
                 elements being stripped by the parser */
              body = _initDocument('<!---->');
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
                /* Node is already a body, use as is */
                body = importedNode;
              } else if (importedNode.nodeName === 'HTML') {
                body = importedNode;
              } else {
                // eslint-disable-next-line unicorn/prefer-dom-node-append
                body.appendChild(importedNode);
              }
            } else {
              /* Exit directly if we have nothing to do */
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
              // eslint-disable-next-line unicorn/prefer-includes
              dirty.indexOf('<') === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              /* Initialize the document to work on */
              body = _initDocument(dirty);
              /* Check we have a DOM node from the data */
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
              }
            }
            /* Remove first element node (ours) if FORCE_BODY is set */
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            /* Get node iterator */
            const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
            /* Now start iterating over the created document */
            while (currentNode = nodeIterator.nextNode()) {
              /* Sanitize tags and elements */
              _sanitizeElements(currentNode);
              /* Check attributes next */
              _sanitizeAttributes(currentNode);
              /* Shadow DOM detected, sanitize it */
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
            }
            /* If we sanitized `dirty` in-place, return it. */
            if (IN_PLACE) {
              return dirty;
            }
            /* Return sanitized string or DOM */
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment.call(body.ownerDocument);
                while (body.firstChild) {
                  // eslint-disable-next-line unicorn/prefer-dom-node-append
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
                /*
                  AdoptNode() is not used because internal state is not reset
                  (e.g. the past names map of a HTMLFormElement), this is safe
                  in theory but we would rather not risk another attack vector.
                  The state that is cloned by importNode() is explicitly defined
                  by the specs.
                */
                returnNode = importNode.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            /* Serialize doctype if allowed */
            if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
              serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
            }
            /* Sanitize final string template-safe */
            if (SAFE_FOR_TEMPLATES) {
              arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
                serializedHTML = stringReplace(serializedHTML, expr, ' ');
              });
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify.setConfig = function () {
            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify.clearConfig = function () {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify.isValidAttribute = function (tag, attr, value) {
            /* Initialize shared config vars if necessary. */
            if (!CONFIG) {
              _parseConfig({});
            }
            const lcTag = transformCaseFunc(tag);
            const lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value);
          };
          DOMPurify.addHook = function (entryPoint, hookFunction) {
            if (typeof hookFunction !== 'function') {
              return;
            }
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify.removeHook = function (entryPoint, hookFunction) {
            if (hookFunction !== undefined) {
              const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
              return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
            }
            return arrayPop(hooks[entryPoint]);
          };
          DOMPurify.removeHooks = function (entryPoint) {
            hooks[entryPoint] = [];
          };
          DOMPurify.removeAllHooks = function () {
            hooks = _createHooksMap();
          };
          return DOMPurify;
        }
        var purify = createDOMPurify();
        const isNonEmptyObject = value => {
          return typeof value === "object" && value !== null && !Array.isArray(value) && Object.keys(value).length > 0;
        };
        const updateSearchParams = (key, value) => {
          const currentURL = new URL(window.location.href);
          if (!value) {
            currentURL.searchParams.delete(key);
          } else {
            currentURL.searchParams.set(key, value);
          }
          window.history.replaceState({}, "", currentURL.toString());
        };
        const updateActiveTabURL = (newTab, tabKeys) => {
          if (tabKeys.indexOf(newTab) == -1 || tabKeys[0] == newTab) {
            updateSearchParams("ptr_active_tab");
            return;
          }
          updateSearchParams("ptr_active_tab", newTab);
        };
        const sanitizeField = html => {
          return purify.sanitize(html);
        };
        const FormBuilderContext = reactExports.createContext(null);
        const DRAGGABLE_FIELD_TYPES = [{
          fieldKey: "phone",
          type: "tel",
          fieldName: __("Phone #", "petitioner"),
          label: __("Phone #", "petitioner"),
          value: "",
          required: false,
          removable: true,
          description: __("Allows users to enter their phone number. The pattern is set to allow only digits.", "petitioner")
        }, {
          fieldKey: "country",
          type: "select",
          fieldName: __("Country", "petitioner"),
          label: __("Country", "petitioner"),
          required: false,
          removable: true
        }, {
          fieldKey: "street_address",
          type: "text",
          fieldName: __("Street address", "petitioner"),
          label: __("Street address", "petitioner"),
          value: "",
          required: false,
          removable: true
        }, {
          fieldKey: "city",
          type: "text",
          fieldName: __("City", "petitioner"),
          label: __("City", "petitioner"),
          value: "",
          required: false,
          removable: true
        }, {
          fieldKey: "postal_code",
          type: "text",
          fieldName: __("Postal code", "petitioner"),
          label: __("Postal code", "petitioner"),
          value: "",
          required: false,
          removable: true
        }, {
          fieldKey: "accept_tos",
          type: "checkbox",
          fieldName: "Terms of service checkbox",
          label: __("By submitting this form, I agree to the terms of service", "petitioner"),
          defaultValue: false,
          required: true,
          removable: true
        }, {
          fieldKey: "legal",
          type: "wysiwyg",
          fieldName: __("Legal text", "petitioner"),
          label: "",
          value: __("By submitting, you agree to our terms.", "petitioner"),
          required: false,
          removable: true
        }, {
          fieldKey: "comments",
          type: "textarea",
          fieldName: __("Comments", "petitioner"),
          label: __("Comments", "petitioner"),
          placeholder: "",
          required: false,
          removable: true
        }];
        const DEFAULT_BUILDER_FIELDS = {
          fname: {
            fieldKey: "fname",
            type: "text",
            fieldName: __("First name", "petitioner"),
            label: __("First name", "petitioner"),
            placeholder: __("John", "petitioner"),
            required: true,
            removable: false
          },
          lname: {
            fieldKey: "lname",
            type: "text",
            fieldName: __("Last name", "petitioner"),
            label: __("Last name", "petitioner"),
            placeholder: __("Smith", "petitioner"),
            required: true,
            removable: false
          },
          email: {
            fieldKey: "email",
            type: "email",
            fieldName: __("Your email", "petitioner"),
            label: __("Your email", "petitioner"),
            placeholder: __("Smith", "petitioner"),
            required: true,
            removable: false
          },
          submit: {
            fieldKey: "submit",
            type: "submit",
            fieldName: __("Submit button", "petitioner"),
            label: __("Sign this petition", "petitioner"),
            required: true,
            removable: false
          }
        };
        const ALl_POSSIBLE_FIELDS = [...DRAGGABLE_FIELD_TYPES, ...Object.values(DEFAULT_BUILDER_FIELDS)];
        function FormBuilderContextProvider({
          children
        }) {
          const {
            form_fields = {},
            field_order = []
          } = window.petitionerData;
          const startingFormFields = isNonEmptyObject(form_fields) ? form_fields : DEFAULT_BUILDER_FIELDS;
          const [formBuilderFields, setFormBuilderFields] = reactExports.useState(startingFormFields);
          const [builderEditScreen, setBuilderEditScreen] = reactExports.useState("default");
          const updateFormBuilderFields = reactExports.useCallback((key, value) => {
            setFormBuilderFields(prevState => ({
              ...prevState,
              [key]: value
            }));
          }, []);
          const removeFormBuilderField = key => {
            setFieldOrder(prevOrder => prevOrder.filter(item => item !== key));
            setFormBuilderFields(prevState => {
              const newState = {
                ...prevState
              };
              delete newState[key];
              return newState;
            });
          };
          const addFormBuilderField = reactExports.useCallback((id, field) => {
            setFormBuilderFields(prevState => {
              const newField = {
                ...field
              };
              delete newField["fieldKey"];
              return {
                ...prevState,
                [id]: newField
              };
            });
          }, []);
          const defaultFieldOrder = Array.isArray(field_order) && field_order.length ? field_order : Object.keys(formBuilderFields);
          const [fieldOrder, setFieldOrder] = reactExports.useState(defaultFieldOrder);
          return /* @__PURE__ */jsxRuntimeExports.jsx(FormBuilderContext.Provider, {
            value: {
              formBuilderFields,
              updateFormBuilderFields,
              builderEditScreen,
              setBuilderEditScreen,
              removeFormBuilderField,
              fieldOrder,
              setFieldOrder,
              addFormBuilderField
            },
            children
          });
        }
        function useFormBuilderContext() {
          const context = reactExports.useContext(FormBuilderContext);
          if (!context) {
            throw new Error("useFormBuilderContext must be used within an FormBuilderContextProvider");
          }
          return context;
        }
        const fetchSubmissions = async ({
          currentPage = 1,
          formID,
          perPage = 100,
          order,
          orderby,
          onSuccess = data => {}
        }) => {
          if (!formID) {
            console.error("Submission fetch error: missing the form id");
            return;
          }
          const finalQuery = new URLSearchParams();
          finalQuery.set("action", FETCH_ACTION);
          finalQuery.set("page", String(currentPage));
          finalQuery.set("form_id", String(formID));
          finalQuery.set("per_page", String(perPage));
          if (order && ["asc", "desc"].indexOf(order) !== -1) {
            finalQuery.set("order", order);
          }
          if (orderby) {
            finalQuery.set("orderby", orderby);
          }
          try {
            const request = await fetch(`${ajaxurl}?${finalQuery.toString()}`);
            const response = await request.json();
            if (response.success) {
              onSuccess(response.data);
            } else {
              console.error("Failed to fetch data");
            }
          } catch (error) {
            console.error("Error fetching data:", error);
          }
        };
        const updateSubmissions = async ({
          data,
          onSuccess = () => {},
          onError = msg => {}
        }) => {
          if (!data?.id) {
            console.error("Submission fetch error: missing the submission id");
            return;
          }
          const finalQuery = new URLSearchParams();
          finalQuery.set("action", UPDATE_ACTION);
          const finalData = new FormData();
          Object.entries(data).forEach(([key, value]) => {
            if (value !== void 0 && value !== null) {
              finalData.append(key, String(value));
            }
          });
          try {
            const request = await fetch(`${ajaxurl}?${finalQuery.toString()}`, {
              method: "POST",
              body: finalData
            });
            const response = await request.json();
            if (response.success) {
              onSuccess(response.data);
            } else {
              onError("Failed to fetch data");
            }
          } catch (error) {
            onError("Error fetching data: " + error);
          }
        };
        const deleteSubmissions = async ({
          id,
          onSuccess,
          onError
        }) => {
          if (!id) {
            onError("Submission fetch error: missing the submission id");
            return;
          }
          const finalQuery = new URLSearchParams();
          finalQuery.set("action", DELETE_ACTION);
          const finalData = new FormData();
          finalData.append("id", String(id));
          try {
            const request = await fetch(`${ajaxurl}?${finalQuery.toString()}`, {
              method: "POST",
              body: finalData
            });
            const response = await request.json();
            if (response.success) {
              onSuccess();
            } else {
              onError("Failed to fetch data");
            }
          } catch (error) {
            onError("Error fetching data: " + error);
          }
        };
        const getFieldLabels = () => {
          const fieldMap = {};
          ALl_POSSIBLE_FIELDS.forEach(field => {
            if (field?.fieldKey) {
              fieldMap[field.fieldKey] = field.label;
            }
          });
          return {
            ...fieldMap,
            name: __("First/Last name", "petitioner"),
            consent: __("Consent", "petitioner"),
            submitted_at: __("Submitted at", "petitioner")
          };
        };
        const getHumanValue = (val, type) => {
          if (val.length === 0) {
            return __("(empty)", "petitioner");
          }
          if (type === "checkbox") {
            return val === "1" ? "✅" : "❌";
          }
          if (type === "date") {
            const date = new Date(val);
            if (!isNaN(date.getTime())) {
              const dateString = date.toLocaleDateString(void 0, {
                month: "short",
                day: "numeric"
              });
              const timeString = date.toLocaleTimeString(void 0, {
                hour: "numeric",
                minute: "2-digit",
                hour12: true
              });
              return `${dateString} ${timeString}`;
            }
          }
          return val;
        };
        const getSubmissionValType = label => {
          if (label === "submitted_at") {
            return "date";
          }
          const correctItem = ALl_POSSIBLE_FIELDS.find(item => item.fieldKey === label);
          return correctItem?.type || "text";
        };
        const ExportButtonWrapper = dt.div`
	display: flex;
    flex-direction: column;
    align-items: flex-start;
	justify-content: space-between;
`;
        const COLORS = {
          grey: "var(--ptr-admin-color-grey)",
          light: "var(--ptr-admin-color-light)"
        };
        const SPACINGS = {
          xs: "var(--ptr-admin-spacing-xs)",
          sm: "var(--ptr-admin-spacing-sm)"
        };
        const TRANSITIONS = {
          sm: "0.15s"
        };
        const TableHeading = dt.th`
	${$width => `width: ${$width}`};
	cursor: pointer;
	&,
	&.sorted {
		padding-inline: var(--ptr-admin-spacing-sm) !important;
	}
`;
        const HeadingLabel = dt.div`
	display: inline-flex;
	gap: var(--ptr-admin-spacing-xs);
`;
        const StyledTable = dt.table`
	&.striped > tbody > {
		&:nth-child(odd) {
			background-color: ${COLORS.light};
		}

		${({
          $clickable
        }) => $clickable && lt`
			tr {
				transition: ${TRANSITIONS.sm};
				&:hover {
					cursor: pointer;
					background: ${COLORS.grey} !important;
				}
			}
		`}
	}
`;
        function Table({
          headings,
          rows,
          emptyMessage = "No data available",
          className = "",
          clickable = false,
          onSort = () => {},
          onItemSelect = () => {}
        }) {
          const hasRows = rows.length > 0;
          const [sort, setSort] = reactExports.useState(null);
          const [sortDirection, setSortDirection] = reactExports.useState();
          const handleSortChange = id => {
            setSort(id);
            const newDirection = sort === id ? sortDirection === "desc" ? "asc" : "desc" : "desc";
            setSortDirection(newDirection);
            onSort({
              order: newDirection,
              orderby: id
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(StyledTable, {
            $clickable: clickable,
            className: `wp-list-table widefat fixed striped table-view-list posts ${className}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("thead", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx("tr", {
                children: headings.map(({
                  id,
                  width,
                  label
                }, idx) => /* @__PURE__ */jsxRuntimeExports.jsx(TableHeading, {
                  $width: width,
                  className: sort !== id ? "" : `sorted ${sortDirection}`,
                  onClick: () => {
                    handleSortChange(id);
                  },
                  children: /* @__PURE__ */jsxRuntimeExports.jsxs(HeadingLabel, {
                    children: [label, /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                      className: "sorting-indicators",
                      children: [/* @__PURE__ */jsxRuntimeExports.jsx("span", {
                        className: "sorting-indicator asc",
                        "aria-hidden": "true"
                      }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                        className: "sorting-indicator desc",
                        "aria-hidden": "true"
                      })]
                    })]
                  })
                }, id))
              })
            }), hasRows ? /* @__PURE__ */jsxRuntimeExports.jsx("tbody", {
              children: rows.map(({
                cells,
                id
              }, rowIdx) => /* @__PURE__ */jsxRuntimeExports.jsx("tr", {
                onClick: () => onItemSelect(id),
                children: cells.map((cell, cellIdx) => /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                  children: cell
                }, cellIdx))
              }, id))
            }) : /* @__PURE__ */jsxRuntimeExports.jsx("tbody", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx("tr", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx("td", {
                  colSpan: headings.length,
                  style: {
                    textAlign: "center"
                  },
                  children: emptyMessage
                })
              })
            })]
          });
        }
        dt.div`
	display: flex;
	margin-bottom: ${SPACINGS.sm};
`;
        const FieldItem = dt(CardBody)`
	display: flex;
	align-items: flex-start;
	flex-direction: column;
	gap: ${SPACINGS.xs};
`;
        const InputGroup = dt.div`
	display: flex;
	align-items: center;
	gap: ${SPACINGS.sm};

	.components-base-control__field {
		margin-bottom: 0px;
	}
`;
        const ActionButtonWrapper = dt.div`
	display: flex;
	gap: ${SPACINGS.sm};
`;
        function PTRichText({
          id = "",
          label = "Rich text label",
          value = "",
          height = 300,
          help = "",
          onChange = value2 => {}
        }) {
          const editorRef = reactExports.useRef(null);
          const lastSavedValue = reactExports.useRef(value);
          reactExports.useEffect(() => {
            if (typeof window !== "undefined" && typeof tinymce !== "undefined") {
              tinymce.init({
                selector: `#${id}`,
                menubar: false,
                plugins: "lists link",
                toolbar: "formatselect | bold italic | bullist numlist | link",
                block_formats: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3",
                height,
                setup: editor => {
                  editorRef.current = editor;
                  editor.on("init", () => {
                    if (value) {
                      editor.setContent(value);
                      lastSavedValue.current = value;
                    }
                  });
                  editor.on("blur", () => {
                    const content = editor.getContent();
                    onChange(content);
                  });
                }
              });
            }
            return () => {
              if (editorRef.current) {
                editorRef.current.remove();
                editorRef.current = null;
              }
            };
          }, [id, value]);
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            className: "petitioner-rich-text",
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h4", {
              children: label
            }), help && /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: "help",
              children: help
            }), /* @__PURE__ */jsxRuntimeExports.jsx("textarea", {
              name: id,
              id
            })]
          });
        }
        const EditFormContext = reactExports.createContext(null);
        const normalizePetitionerData = () => {
          const rawData = window.petitionerData || {};
          const defaultData = {
            title: "",
            send_to_representative: false,
            email: "",
            cc_emails: "",
            show_goal: true,
            goal: 0,
            show_country: false,
            subject: "",
            require_approval: false,
            approval_state: "Confirmed",
            letter: "",
            add_legal_text: false,
            legal_text: "",
            add_consent_checkbox: false,
            consent_text: "",
            override_ty_email: false,
            ty_email: "",
            ty_email_subject: "",
            override_success_message: false,
            success_message_title: "",
            success_message: "",
            from_field: "",
            add_honeypot: true,
            form_id: null,
            hide_last_names: true,
            active_tab: "default"
          };
          return {
            ...defaultData,
            ...rawData
          };
        };
        function EditFormContextProvider({
          children
        }) {
          const petitionerData = normalizePetitionerData();
          const [formState, setFormState] = reactExports.useState(petitionerData);
          const updateFormState = reactExports.useCallback((key, value) => {
            setFormState(prevState => ({
              ...prevState,
              [key]: value
            }));
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsx(EditFormContext.Provider, {
            value: {
              formState,
              updateFormState
            },
            children
          });
        }
        function useEditFormContext() {
          const context = reactExports.useContext(EditFormContext);
          if (!context) {
            throw new Error("useEditFormContext must be used within an EditFormContextProvider");
          }
          return context;
        }
        function CheckboxInput(props) {
          const {
            checked,
            name,
            onChange,
            label,
            help
          } = props;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(InputWrapper, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
              checked,
              type: "checkbox",
              name,
              id: name,
              className: "widefat",
              onChange
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("label", {
              htmlFor: name,
              children: [label, help && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsx("small", {
                  children: help
                })]
              })]
            })]
          });
        }
        const normalizeDefaultValues = raw => {
          const DEFAULT_SUBJECT = __("Thank you for signing the {{petition_title}}", "petitioner");
          const DEFAULT_CONTENT = __("Thank you for signing the {{petition_title}}. Your signature has been recorded and will be sent to {{petition_target}}.", "petitioner");
          const defaultValues = {
            from_field: "",
            ty_email_subject: DEFAULT_SUBJECT,
            ty_email: DEFAULT_CONTENT,
            ty_email_subject_confirm: DEFAULT_SUBJECT,
            ty_email_confirm: DEFAULT_CONTENT,
            success_message_title: "",
            success_message: "",
            country_list: []
          };
          if (typeof raw !== "object" || raw === null) {
            return defaultValues;
          }
          const input = raw;
          for (const key of Object.keys(defaultValues)) {
            const value = input[key];
            if (key === "country_list") {
              if (Array.isArray(value)) {
                defaultValues[key] = value;
              }
              continue;
            }
            if (typeof value === "string" && value.trim().length > 0) {
              defaultValues[key] = value;
            }
          }
          return defaultValues;
        };
        function getThankYouDefaults(defaults, approvalState) {
          const isConfirmEmail = approvalState === "Email";
          return {
            subject: isConfirmEmail ? defaults.ty_email_subject_confirm : defaults.ty_email_subject,
            content: isConfirmEmail ? defaults.ty_email_confirm : defaults.ty_email
          };
        }
        function AdvancedSettings() {
          const {
            formState,
            updateFormState
          } = useEditFormContext();
          const defaultValues = normalizeDefaultValues(window.petitionerData?.default_values);
          const defaultFromField = defaultValues?.from_field || "";
          const confirmEmails = formState.approval_state === "Email";
          const {
            subject: defaultTYSubject,
            content: defaultTYEmailContent
          } = getThankYouDefaults(defaultValues, formState.approval_state);
          const defaultSuccessMessageTitle = defaultValues?.success_message_title || "";
          const defaultSuccessMessageContent = defaultValues?.success_message || "";
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(CheckboxInput, {
              checked: !!formState.add_honeypot,
              name: "petitioner_add_honeypot",
              label: __("Add a honeypot field to the form for better spam protection?", "petitioner"),
              onChange: e => updateFormState("add_honeypot", e.target.checked)
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                style: {
                  width: "100%"
                },
                label: __("From field", "petitioner"),
                value: formState.from_field,
                defaultValue: defaultFromField,
                type: "email",
                help: __(`This is the email address that will appear in the 'From' field of the email. If empty will default to ${defaultFromField}.`, "petitioner"),
                name: "petitioner_from_field",
                id: "petitioner_from_field",
                onChange: value => updateFormState("from_field", value)
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxInput, {
              checked: formState.require_approval,
              name: "petitioner_require_approval",
              label: __("Require approval for submissions?", "petitioner"),
              help: __("When enabled, submissions will be saved as drafts and will require approval or an email confirmation before being published.", "petitioner"),
              onChange: e => {
                const isChecked = e.target.checked;
                updateFormState("require_approval", isChecked);
                updateFormState("approval_state", "Email");
                window.petitionerData.require_approval = isChecked;
                const evt = new CustomEvent("onPtrApprovalChange", {
                  detail: {
                    requireApproval: isChecked
                  }
                });
                window.dispatchEvent(evt);
              }
            }), formState.require_approval && /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(SelectControl$1, {
                value: formState.approval_state,
                id: "petitioner_approval_state",
                name: "petitioner_approval_state",
                label: __("Approval behavior", "petitioner"),
                options: [{
                  value: "Email",
                  label: __("Automatic: Confirmed by email", "petitioner")
                }, {
                  value: "Confirmed",
                  label: __("Manual: confirmed by default", "petitioner")
                }, {
                  value: "Declined",
                  label: __("Manual: needs approval by default", "petitioner")
                }],
                onChange: value => {
                  updateFormState("approval_state", value);
                  window.petitionerData.approval_state = value;
                  const evt = new CustomEvent("onPtrApprovalChange", {
                    detail: {
                      approvalState: value
                    }
                  });
                  window.dispatchEvent(evt);
                }
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxInput, {
              checked: formState.override_ty_email,
              name: "petitioner_override_ty_email",
              label: __("Override the confirmation email?", "petitioner"),
              help: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [__("Use this to customize the thank you email sent when submitting a petition.", "petitioner"), confirmEmails && formState.override_ty_email && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsxs("strong", {
                    style: {
                      color: "salmon"
                    },
                    children: [__("Make sure to include the email confirmation variable.", "petitioner"), " ", "{{confirmation_link}}"]
                  })]
                })]
              }),
              onChange: e => updateFormState("override_ty_email", e.target.checked)
            }), formState.override_ty_email && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                  style: {
                    width: "100%"
                  },
                  type: "text",
                  required: true,
                  label: __("Thank you email subject *", "petitioner"),
                  value: String(formState?.ty_email_subject).length > 0 ? formState.ty_email_subject : defaultTYSubject,
                  name: "petitioner_ty_email_subject",
                  id: "petitioner_ty_email_subject",
                  onChange: value => updateFormState("ty_email_subject", value)
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(PTRichText, {
                label: __("Thank you email content", "petitioner"),
                id: "petitioner_ty_email",
                help: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  children: [__("This will be the content of the thank you email sent to the signer. You can use the following dynamic tags:", "petitioner"), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                    className: "ptr-code-snippets",
                    children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                      disabled: true,
                      value: `{{user_name}}`
                    }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                      disabled: true,
                      value: `{{petition_letter}}`
                    }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                      disabled: true,
                      value: `{{petition_goal}}`
                    }), formState.approval_state === "Email" && /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                      disabled: true,
                      style: {
                        minWidth: 140
                      },
                      value: `{{confirmation_link}}`
                    })]
                  })]
                }),
                value: String(formState?.ty_email).length > 0 ? formState.ty_email : defaultTYEmailContent,
                onChange: value => updateFormState("ty_email", value),
                height: 150
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxInput, {
              name: "petitioner_override_success_message",
              label: __("Override success message?", "petitioner"),
              help: __("Use this to customize the success message shown after submitting a petition.", "petitioner"),
              checked: formState.override_success_message,
              onChange: e => updateFormState("override_success_message", e.target.checked)
            }), formState.override_success_message && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                  style: {
                    width: "100%"
                  },
                  type: "text",
                  label: __("Success message title", "petitioner"),
                  value: String(formState?.success_message_title).length > 0 ? formState.success_message_title : defaultSuccessMessageTitle,
                  name: "petitioner_success_message_title",
                  id: "petitioner_success_message_title",
                  onChange: value => updateFormState("success_message_title", value)
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(PTRichText, {
                label: __("Success message content", "petitioner"),
                id: "petitioner_success_message",
                help: __("This will be the content of the success message shown after submitting a petition.", "petitioner"),
                value: String(formState?.success_message).length > 0 ? formState.success_message : defaultSuccessMessageContent,
                onChange: value => updateFormState("success_message", value),
                height: 150
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxInput, {
              name: "petitioner_hide_last_names",
              label: __("Hide signee's last names on the frontend", "petitioner"),
              help: __("This will only show the first letter of their last name on the submission list. For example: John D.", "petitioner"),
              checked: formState.hide_last_names,
              onChange: e => updateFormState("hide_last_names", e.target.checked)
            })]
          });
        }
        function SubmissionEditField({
          label,
          type,
          value,
          onChange
        }) {
          if (type === "checkbox") {
            return /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxControl, {
              checked: value === "1",
              onChange: checked => {
                onChange(checked ? "1" : "0");
              }
            });
          }
          if (label === "country") {
            const defaultValues = normalizeDefaultValues(window.petitionerData.default_values);
            const allCountries = defaultValues.country_list;
            return /* @__PURE__ */jsxRuntimeExports.jsx(SelectControl$1, {
              value,
              onChange,
              children: allCountries.map(item => /* @__PURE__ */jsxRuntimeExports.jsx("option", {
                selected: value === item,
                value: item,
                children: item
              }))
            });
          }
          if (type === "textarea") {
            return /* @__PURE__ */jsxRuntimeExports.jsx(TextareaControl, {
              value,
              onChange
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
            type,
            value,
            onChange
          });
        }
        const SUBMISSION_LABELS$1 = getFieldLabels();
        const isValidFieldKey = key => {
          return key in SUBMISSION_LABELS$1;
        };
        function SubmissionEditModal({
          submission,
          onClose = () => {},
          onSave = upatedItem => {},
          onDelete = id => {}
        }) {
          const [isEdit, setIsEdit] = reactExports.useState(null);
          const [valuesChanged, setValuesChanged] = reactExports.useState(false);
          const [submissionDetails, setSubmissionDetails] = reactExports.useState(submission);
          const updateSubmissionDetails = reactExports.useCallback((key, value) => {
            const oldState = submission?.[key] || "";
            if (oldState != value) {
              setValuesChanged(true);
            }
            setSubmissionDetails(prevState => ({
              ...prevState,
              [key]: value
            }));
          }, []);
          const submissionEntries = Object.entries(submissionDetails);
          const lastRowIndex = submissionEntries.length - 1;
          const SubmissionDetails = submissionEntries.map(([label, value], index) => {
            if (!isValidFieldKey(label)) {
              return;
            }
            const valueString = String(value);
            const finalLabel = SUBMISSION_LABELS$1[label] ?? label;
            const type = getSubmissionValType(label);
            const finalValue = getHumanValue(valueString, type);
            const isEmpty = finalValue == __("(empty)", "petitioner");
            const currentlyEditing = isEdit === label;
            let ValueField = /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
              color: !isEmpty ? "" : "grey",
              size: !isEmpty ? "" : "12",
              children: finalValue
            });
            const actionButtonProps = {
              icon: "edit",
              onClick: () => setIsEdit(label),
              children: /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: "screen-reader-text",
                children: __("Edit", "petitioner")
              })
            };
            if (currentlyEditing) {
              ValueField = /* @__PURE__ */jsxRuntimeExports.jsx(SubmissionEditField, {
                label,
                type,
                value: valueString,
                onChange: val => {
                  updateSubmissionDetails(label, val);
                }
              });
              actionButtonProps.icon = "saved";
              actionButtonProps.onClick = () => setIsEdit(null);
              actionButtonProps.children = /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                className: "screen-reader-text",
                children: __("Done", "petitioner")
              });
            }
            return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(FieldItem, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsxs("strong", {
                  children: [finalLabel, ":"]
                }), /* @__PURE__ */jsxRuntimeExports.jsxs(InputGroup, {
                  children: [ValueField, /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                    size: "small",
                    variant: "tertiary",
                    ...actionButtonProps
                  })]
                })]
              }), index < lastRowIndex && /* @__PURE__ */jsxRuntimeExports.jsx(CardDivider, {})]
            }, label);
          });
          const onRequestClose = reactExports.useCallback(() => {
            if (valuesChanged) {
              if (window.confirm(__("Are you sure you want to close without saving?", "petitioner"))) {
                onClose();
              }
            } else {
              onClose();
            }
          }, [valuesChanged]);
          const handleOnDelete = reactExports.useCallback(() => {
            if (window.confirm(__("Are you sure you want to delete this submission?", "petitioner"))) {
              onDelete(submissionDetails.id);
            }
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsx(Modal, {
            shouldCloseOnClickOutside: !valuesChanged,
            shouldCloseOnEsc: !valuesChanged,
            size: "large",
            title: __("Submission details", "petitioner-theme"),
            onRequestClose,
            headerActions: /* @__PURE__ */jsxRuntimeExports.jsxs(ActionButtonWrapper, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "secondary",
                isDestructive: true,
                onClick: handleOnDelete,
                children: __("Delete", "petitioner")
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "primary",
                onClick: () => onSave(submissionDetails),
                disabled: !valuesChanged,
                children: __("Save", "petitioner")
              })]
            }),
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Card, {
              children: SubmissionDetails
            })
          });
        }
        const SUBMISSION_LABELS = getFieldLabels();
        function Submissions() {
          const {
            form_id = null,
            export_url = ""
          } = window?.petitionerData;
          const requireApproval = window?.petitionerData?.require_approval;
          const approvalState = window.petitionerData.approval_state;
          const [submissions, setSubmissions] = reactExports.useState([]);
          const [total, setTotal] = reactExports.useState(0);
          const [currentPage, setCurrentPage] = reactExports.useState(1);
          const [order, setOrder] = reactExports.useState();
          const [orderby, setOrderBy] = reactExports.useState();
          const [showApproval, setShowApproval] = reactExports.useState(requireApproval);
          const [defaultApprovalState, setDefaultApprovalState] = reactExports.useState(() => {
            return approvalState === "Email" ? "Declined" : approvalState;
          });
          const [activeModal, setActiveModal] = reactExports.useState();
          const hasSubmissions = submissions.length > 0;
          const perPage = 100;
          const fetchData = async () => {
            return fetchSubmissions({
              currentPage,
              formID: form_id,
              perPage,
              order,
              orderby,
              onSuccess: data => {
                setTotal(data.total);
                setSubmissions(data.submissions);
              }
            });
          };
          reactExports.useEffect(() => {
            if (!form_id) return;
            fetchData();
          }, [currentPage, form_id, order, orderby]);
          reactExports.useEffect(() => {
            window.addEventListener("onPtrApprovalChange", () => {
              setShowApproval(requireApproval);
              if (approvalState) {
                setDefaultApprovalState(approvalState);
              }
            });
          }, []);
          const handleStatusChange = async (id, newStatus, changeAction) => {
            const question = `Are you sure you want to ${String(changeAction).toLowerCase()} this submission?`;
            if (window.confirm(question)) {
              const finalAjaxURL = `${ajaxurl}?action=${UPDATE_ACTION}`;
              try {
                const finalData = new FormData();
                finalData.append("id", String(id));
                finalData.append("status", newStatus);
                const response = await fetch(finalAjaxURL, {
                  method: "POST",
                  body: finalData
                });
                const data = await response.json();
                if (data.success) {
                  fetchData();
                } else {
                  console.error("Failed to update submission status");
                }
              } catch (error) {
                console.error("Error updating submission status:", error);
              }
            }
          };
          const handlePaginationClick = page => {
            setCurrentPage(page);
          };
          const totalPages = Math.ceil(total / perPage);
          const buttons = [];
          for (let i = 1; i <= totalPages; i++) {
            buttons.push(/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
              variant: currentPage !== i ? "secondary" : "primary",
              onClick: () => handlePaginationClick(i),
              "data-page": i,
              children: i
            }, i));
          }
          const ExportComponent = () => {
            return /* @__PURE__ */jsxRuntimeExports.jsxs(ExportButtonWrapper, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(ShortcodeElement, {
                clipboardValue: `[petitioner-submissions form_id="${form_id}" style="table" show_pagination="true"]`,
                label: __("Shortcode", "petitioner"),
                help: __("Use this shortcode to display submissions on any page or post.", "petitioner"),
                fieldName: "petitioner_shortcode",
                width: "250px"
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "primary",
                href: export_url,
                children: __("Export entries as CSV", "petitioner")
              })]
            });
          };
          const headingData = [{
            id: "email",
            label: SUBMISSION_LABELS.email,
            width: "20%"
          }, {
            id: "name",
            label: SUBMISSION_LABELS.name
          }, {
            id: "consent",
            label: SUBMISSION_LABELS.consent,
            width: "60px"
          }, {
            id: "submitted_at",
            label: SUBMISSION_LABELS.submitted_at
          }];
          if (showApproval) {
            headingData.push({
              id: "status",
              label: __("Status", "petitioner"),
              width: "200px"
            });
          }
          const tableRows = submissions.map(item => {
            const cells = [item.email, `${item.fname} ${item.lname}`, getHumanValue(String(item.accept_tos), "checkbox"), getHumanValue(item.submitted_at, "date")];
            if (showApproval) {
              cells.push(/* @__PURE__ */jsxRuntimeExports.jsx(ApprovalStatus, {
                item,
                defaultApprovalState,
                onStatusChange: handleStatusChange
              }));
            }
            return {
              id: item.id,
              cells
            };
          });
          const handleSortChange = ({
            order: order2,
            orderby: orderby2
          }) => {
            setOrder(order2);
            setOrderBy(orderby2);
            setCurrentPage(1);
          };
          const selectedSubmission = submissions.find(item => item.id === activeModal);
          const onModalClose = reactExports.useCallback(() => setActiveModal(void 0), []);
          const onModalSave = reactExports.useCallback(async newData => {
            await updateSubmissions({
              data: newData,
              onSuccess: () => {
                alert(__("Submission updated!", "petitioner"));
                onModalClose();
              },
              onError: msg => {
                console.error(msg);
                alert(__("Failed to update submission!", "petitioner"));
                onModalClose();
              }
            });
            fetchData();
          }, [activeModal]);
          const onModalDelete = reactExports.useCallback(id => {
            deleteSubmissions({
              id,
              onSuccess: () => {
                alert("Successfully deleted!");
                onModalClose();
                fetchData();
              },
              onError: msg => {
                console.error(msg);
                alert(__("Failed to delete! Check console for errors", "petitioner"));
                onModalClose();
              }
            });
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            id: "AV_Petitioner_Submissions",
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h3", {
                children: __("Submissions", "petitioner-theme")
              }), hasSubmissions && /* @__PURE__ */jsxRuntimeExports.jsx(ExportComponent, {})]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "petitioner-admin__entries",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs("p", {
                children: [__("Total:", "petitioner-theme"), " ", total]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Table, {
                headings: headingData,
                rows: tableRows,
                onSort: handleSortChange,
                clickable: true,
                onItemSelect: id => setActiveModal(id)
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), hasSubmissions && /* @__PURE__ */jsxRuntimeExports.jsx(ResendAllButton, {}), /* @__PURE__ */jsxRuntimeExports.jsx("br", {}), buttons?.length > 1 && /* @__PURE__ */jsxRuntimeExports.jsx(ButtonGroup, {
              children: buttons
            }), selectedSubmission ? /* @__PURE__ */jsxRuntimeExports.jsx(SubmissionEditModal, {
              submission: selectedSubmission,
              onClose: onModalClose,
              onSave: onModalSave,
              onDelete: onModalDelete
            }) : null]
          });
        }
        function useCombinedRefs() {
          for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
            refs[_key] = arguments[_key];
          }
          return reactExports.useMemo(() => node => {
            refs.forEach(ref => ref(node));
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          refs);
        }

        // https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js
        const canUseDOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
        function isWindow(element) {
          const elementString = Object.prototype.toString.call(element);
          return elementString === '[object Window]' ||
          // In Electron context the Window object serializes to [object global]
          elementString === '[object global]';
        }
        function isNode(node) {
          return 'nodeType' in node;
        }
        function getWindow(target) {
          var _target$ownerDocument, _target$ownerDocument2;
          if (!target) {
            return window;
          }
          if (isWindow(target)) {
            return target;
          }
          if (!isNode(target)) {
            return window;
          }
          return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
        }
        function isDocument(node) {
          const {
            Document
          } = getWindow(node);
          return node instanceof Document;
        }
        function isHTMLElement(node) {
          if (isWindow(node)) {
            return false;
          }
          return node instanceof getWindow(node).HTMLElement;
        }
        function isSVGElement(node) {
          return node instanceof getWindow(node).SVGElement;
        }
        function getOwnerDocument(target) {
          if (!target) {
            return document;
          }
          if (isWindow(target)) {
            return target.document;
          }
          if (!isNode(target)) {
            return document;
          }
          if (isDocument(target)) {
            return target;
          }
          if (isHTMLElement(target) || isSVGElement(target)) {
            return target.ownerDocument;
          }
          return document;
        }

        /**
         * A hook that resolves to useEffect on the server and useLayoutEffect on the client
         * @param callback {function} Callback function that is invoked when the dependencies of the hook change
         */

        const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
        function useEvent(handler) {
          const handlerRef = reactExports.useRef(handler);
          useIsomorphicLayoutEffect(() => {
            handlerRef.current = handler;
          });
          return reactExports.useCallback(function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return handlerRef.current == null ? void 0 : handlerRef.current(...args);
          }, []);
        }
        function useInterval() {
          const intervalRef = reactExports.useRef(null);
          const set = reactExports.useCallback((listener, duration) => {
            intervalRef.current = setInterval(listener, duration);
          }, []);
          const clear = reactExports.useCallback(() => {
            if (intervalRef.current !== null) {
              clearInterval(intervalRef.current);
              intervalRef.current = null;
            }
          }, []);
          return [set, clear];
        }
        function useLatestValue(value, dependencies) {
          if (dependencies === void 0) {
            dependencies = [value];
          }
          const valueRef = reactExports.useRef(value);
          useIsomorphicLayoutEffect(() => {
            if (valueRef.current !== value) {
              valueRef.current = value;
            }
          }, dependencies);
          return valueRef;
        }
        function useLazyMemo(callback, dependencies) {
          const valueRef = reactExports.useRef();
          return reactExports.useMemo(() => {
            const newValue = callback(valueRef.current);
            valueRef.current = newValue;
            return newValue;
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [...dependencies]);
        }
        function useNodeRef(onChange) {
          const onChangeHandler = useEvent(onChange);
          const node = reactExports.useRef(null);
          const setNodeRef = reactExports.useCallback(element => {
            if (element !== node.current) {
              onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
            }
            node.current = element;
          },
          //eslint-disable-next-line
          []);
          return [node, setNodeRef];
        }
        function usePrevious(value) {
          const ref = reactExports.useRef();
          reactExports.useEffect(() => {
            ref.current = value;
          }, [value]);
          return ref.current;
        }
        let ids = {};
        function useUniqueId(prefix, value) {
          return reactExports.useMemo(() => {
            if (value) {
              return value;
            }
            const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
            ids[prefix] = id;
            return prefix + "-" + id;
          }, [prefix, value]);
        }
        function createAdjustmentFn(modifier) {
          return function (object) {
            for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              adjustments[_key - 1] = arguments[_key];
            }
            return adjustments.reduce((accumulator, adjustment) => {
              const entries = Object.entries(adjustment);
              for (const [key, valueAdjustment] of entries) {
                const value = accumulator[key];
                if (value != null) {
                  accumulator[key] = value + modifier * valueAdjustment;
                }
              }
              return accumulator;
            }, {
              ...object
            });
          };
        }
        const add = /*#__PURE__*/createAdjustmentFn(1);
        const subtract = /*#__PURE__*/createAdjustmentFn(-1);
        function hasViewportRelativeCoordinates(event) {
          return 'clientX' in event && 'clientY' in event;
        }
        function isKeyboardEvent(event) {
          if (!event) {
            return false;
          }
          const {
            KeyboardEvent
          } = getWindow(event.target);
          return KeyboardEvent && event instanceof KeyboardEvent;
        }
        function isTouchEvent(event) {
          if (!event) {
            return false;
          }
          const {
            TouchEvent
          } = getWindow(event.target);
          return TouchEvent && event instanceof TouchEvent;
        }

        /**
         * Returns the normalized x and y coordinates for mouse and touch events.
         */

        function getEventCoordinates(event) {
          if (isTouchEvent(event)) {
            if (event.touches && event.touches.length) {
              const {
                clientX: x,
                clientY: y
              } = event.touches[0];
              return {
                x,
                y
              };
            } else if (event.changedTouches && event.changedTouches.length) {
              const {
                clientX: x,
                clientY: y
              } = event.changedTouches[0];
              return {
                x,
                y
              };
            }
          }
          if (hasViewportRelativeCoordinates(event)) {
            return {
              x: event.clientX,
              y: event.clientY
            };
          }
          return null;
        }
        const CSS$1 = /*#__PURE__*/Object.freeze({
          Translate: {
            toString(transform) {
              if (!transform) {
                return;
              }
              const {
                x,
                y
              } = transform;
              return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
            }
          },
          Scale: {
            toString(transform) {
              if (!transform) {
                return;
              }
              const {
                scaleX,
                scaleY
              } = transform;
              return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
            }
          },
          Transform: {
            toString(transform) {
              if (!transform) {
                return;
              }
              return [CSS$1.Translate.toString(transform), CSS$1.Scale.toString(transform)].join(' ');
            }
          },
          Transition: {
            toString(_ref) {
              let {
                property,
                duration,
                easing
              } = _ref;
              return property + " " + duration + "ms " + easing;
            }
          }
        });
        const SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]';
        function findFirstFocusableNode(element) {
          if (element.matches(SELECTOR)) {
            return element;
          }
          return element.querySelector(SELECTOR);
        }
        const hiddenStyles = {
          display: 'none'
        };
        function HiddenText(_ref) {
          let {
            id,
            value
          } = _ref;
          return React$1.createElement("div", {
            id: id,
            style: hiddenStyles
          }, value);
        }
        function LiveRegion(_ref) {
          let {
            id,
            announcement,
            ariaLiveType = "assertive"
          } = _ref;
          // Hide element visually but keep it readable by screen readers
          const visuallyHidden = {
            position: 'fixed',
            top: 0,
            left: 0,
            width: 1,
            height: 1,
            margin: -1,
            border: 0,
            padding: 0,
            overflow: 'hidden',
            clip: 'rect(0 0 0 0)',
            clipPath: 'inset(100%)',
            whiteSpace: 'nowrap'
          };
          return React$1.createElement("div", {
            id: id,
            style: visuallyHidden,
            role: "status",
            "aria-live": ariaLiveType,
            "aria-atomic": true
          }, announcement);
        }
        function useAnnouncement() {
          const [announcement, setAnnouncement] = reactExports.useState('');
          const announce = reactExports.useCallback(value => {
            if (value != null) {
              setAnnouncement(value);
            }
          }, []);
          return {
            announce,
            announcement
          };
        }
        const DndMonitorContext = /*#__PURE__*/reactExports.createContext(null);
        function useDndMonitor(listener) {
          const registerListener = reactExports.useContext(DndMonitorContext);
          reactExports.useEffect(() => {
            if (!registerListener) {
              throw new Error('useDndMonitor must be used within a children of <DndContext>');
            }
            const unsubscribe = registerListener(listener);
            return unsubscribe;
          }, [listener, registerListener]);
        }
        function useDndMonitorProvider() {
          const [listeners] = reactExports.useState(() => new Set());
          const registerListener = reactExports.useCallback(listener => {
            listeners.add(listener);
            return () => listeners.delete(listener);
          }, [listeners]);
          const dispatch = reactExports.useCallback(_ref => {
            let {
              type,
              event
            } = _ref;
            listeners.forEach(listener => {
              var _listener$type;
              return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
            });
          }, [listeners]);
          return [dispatch, registerListener];
        }
        const defaultScreenReaderInstructions = {
          draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
        };
        const defaultAnnouncements = {
          onDragStart(_ref) {
            let {
              active
            } = _ref;
            return "Picked up draggable item " + active.id + ".";
          },
          onDragOver(_ref2) {
            let {
              active,
              over
            } = _ref2;
            if (over) {
              return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
            }
            return "Draggable item " + active.id + " is no longer over a droppable area.";
          },
          onDragEnd(_ref3) {
            let {
              active,
              over
            } = _ref3;
            if (over) {
              return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
            }
            return "Draggable item " + active.id + " was dropped.";
          },
          onDragCancel(_ref4) {
            let {
              active
            } = _ref4;
            return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
          }
        };
        function Accessibility(_ref) {
          let {
            announcements = defaultAnnouncements,
            container,
            hiddenTextDescribedById,
            screenReaderInstructions = defaultScreenReaderInstructions
          } = _ref;
          const {
            announce,
            announcement
          } = useAnnouncement();
          const liveRegionId = useUniqueId("DndLiveRegion");
          const [mounted, setMounted] = reactExports.useState(false);
          reactExports.useEffect(() => {
            setMounted(true);
          }, []);
          useDndMonitor(reactExports.useMemo(() => ({
            onDragStart(_ref2) {
              let {
                active
              } = _ref2;
              announce(announcements.onDragStart({
                active
              }));
            },
            onDragMove(_ref3) {
              let {
                active,
                over
              } = _ref3;
              if (announcements.onDragMove) {
                announce(announcements.onDragMove({
                  active,
                  over
                }));
              }
            },
            onDragOver(_ref4) {
              let {
                active,
                over
              } = _ref4;
              announce(announcements.onDragOver({
                active,
                over
              }));
            },
            onDragEnd(_ref5) {
              let {
                active,
                over
              } = _ref5;
              announce(announcements.onDragEnd({
                active,
                over
              }));
            },
            onDragCancel(_ref6) {
              let {
                active,
                over
              } = _ref6;
              announce(announcements.onDragCancel({
                active,
                over
              }));
            }
          }), [announce, announcements]));
          if (!mounted) {
            return null;
          }
          const markup = React$1.createElement(React$1.Fragment, null, React$1.createElement(HiddenText, {
            id: hiddenTextDescribedById,
            value: screenReaderInstructions.draggable
          }), React$1.createElement(LiveRegion, {
            id: liveRegionId,
            announcement: announcement
          }));
          return container ? reactDomExports.createPortal(markup, container) : markup;
        }
        var Action;
        (function (Action) {
          Action["DragStart"] = "dragStart";
          Action["DragMove"] = "dragMove";
          Action["DragEnd"] = "dragEnd";
          Action["DragCancel"] = "dragCancel";
          Action["DragOver"] = "dragOver";
          Action["RegisterDroppable"] = "registerDroppable";
          Action["SetDroppableDisabled"] = "setDroppableDisabled";
          Action["UnregisterDroppable"] = "unregisterDroppable";
        })(Action || (Action = {}));
        function noop() {}
        function useSensor(sensor, options) {
          return reactExports.useMemo(() => ({
            sensor,
            options: {}
          }),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [sensor, options]);
        }
        function useSensors() {
          for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
            sensors[_key] = arguments[_key];
          }
          return reactExports.useMemo(() => [...sensors].filter(sensor => sensor != null),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [...sensors]);
        }
        const defaultCoordinates = /*#__PURE__*/Object.freeze({
          x: 0,
          y: 0
        });
        /**
         * Sort collisions from greatest to smallest value
         */

        function sortCollisionsDesc(_ref3, _ref4) {
          let {
            data: {
              value: a
            }
          } = _ref3;
          let {
            data: {
              value: b
            }
          } = _ref4;
          return b - a;
        }
        function getFirstCollision(collisions, property) {
          if (!collisions || collisions.length === 0) {
            return null;
          }
          const [firstCollision] = collisions;
          return firstCollision[property];
        }

        /**
         * Returns the intersecting rectangle area between two rectangles
         */

        function getIntersectionRatio(entry, target) {
          const top = Math.max(target.top, entry.top);
          const left = Math.max(target.left, entry.left);
          const right = Math.min(target.left + target.width, entry.left + entry.width);
          const bottom = Math.min(target.top + target.height, entry.top + entry.height);
          const width = right - left;
          const height = bottom - top;
          if (left < right && top < bottom) {
            const targetArea = target.width * target.height;
            const entryArea = entry.width * entry.height;
            const intersectionArea = width * height;
            const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
            return Number(intersectionRatio.toFixed(4));
          } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)

          return 0;
        }
        /**
         * Returns the rectangles that has the greatest intersection area with a given
         * rectangle in an array of rectangles.
         */

        const rectIntersection = _ref => {
          let {
            collisionRect,
            droppableRects,
            droppableContainers
          } = _ref;
          const collisions = [];
          for (const droppableContainer of droppableContainers) {
            const {
              id
            } = droppableContainer;
            const rect = droppableRects.get(id);
            if (rect) {
              const intersectionRatio = getIntersectionRatio(rect, collisionRect);
              if (intersectionRatio > 0) {
                collisions.push({
                  id,
                  data: {
                    droppableContainer,
                    value: intersectionRatio
                  }
                });
              }
            }
          }
          return collisions.sort(sortCollisionsDesc);
        };
        function adjustScale(transform, rect1, rect2) {
          return {
            ...transform,
            scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
            scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
          };
        }
        function getRectDelta(rect1, rect2) {
          return rect1 && rect2 ? {
            x: rect1.left - rect2.left,
            y: rect1.top - rect2.top
          } : defaultCoordinates;
        }
        function createRectAdjustmentFn(modifier) {
          return function adjustClientRect(rect) {
            for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              adjustments[_key - 1] = arguments[_key];
            }
            return adjustments.reduce((acc, adjustment) => ({
              ...acc,
              top: acc.top + modifier * adjustment.y,
              bottom: acc.bottom + modifier * adjustment.y,
              left: acc.left + modifier * adjustment.x,
              right: acc.right + modifier * adjustment.x
            }), {
              ...rect
            });
          };
        }
        const getAdjustedRect = /*#__PURE__*/createRectAdjustmentFn(1);
        function parseTransform(transform) {
          if (transform.startsWith('matrix3d(')) {
            const transformArray = transform.slice(9, -1).split(/, /);
            return {
              x: +transformArray[12],
              y: +transformArray[13],
              scaleX: +transformArray[0],
              scaleY: +transformArray[5]
            };
          } else if (transform.startsWith('matrix(')) {
            const transformArray = transform.slice(7, -1).split(/, /);
            return {
              x: +transformArray[4],
              y: +transformArray[5],
              scaleX: +transformArray[0],
              scaleY: +transformArray[3]
            };
          }
          return null;
        }
        function inverseTransform(rect, transform, transformOrigin) {
          const parsedTransform = parseTransform(transform);
          if (!parsedTransform) {
            return rect;
          }
          const {
            scaleX,
            scaleY,
            x: translateX,
            y: translateY
          } = parsedTransform;
          const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
          const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(' ') + 1));
          const w = scaleX ? rect.width / scaleX : rect.width;
          const h = scaleY ? rect.height / scaleY : rect.height;
          return {
            width: w,
            height: h,
            top: y,
            right: x + w,
            bottom: y + h,
            left: x
          };
        }
        const defaultOptions = {
          ignoreTransform: false
        };
        /**
         * Returns the bounding client rect of an element relative to the viewport.
         */

        function getClientRect(element, options) {
          if (options === void 0) {
            options = defaultOptions;
          }
          let rect = element.getBoundingClientRect();
          if (options.ignoreTransform) {
            const {
              transform,
              transformOrigin
            } = getWindow(element).getComputedStyle(element);
            if (transform) {
              rect = inverseTransform(rect, transform, transformOrigin);
            }
          }
          const {
            top,
            left,
            width,
            height,
            bottom,
            right
          } = rect;
          return {
            top,
            left,
            width,
            height,
            bottom,
            right
          };
        }
        /**
         * Returns the bounding client rect of an element relative to the viewport.
         *
         * @remarks
         * The ClientRect returned by this method does not take into account transforms
         * applied to the element it measures.
         *
         */

        function getTransformAgnosticClientRect(element) {
          return getClientRect(element, {
            ignoreTransform: true
          });
        }
        function getWindowClientRect(element) {
          const width = element.innerWidth;
          const height = element.innerHeight;
          return {
            top: 0,
            left: 0,
            right: width,
            bottom: height,
            width,
            height
          };
        }
        function isFixed(node, computedStyle) {
          if (computedStyle === void 0) {
            computedStyle = getWindow(node).getComputedStyle(node);
          }
          return computedStyle.position === 'fixed';
        }
        function isScrollable(element, computedStyle) {
          if (computedStyle === void 0) {
            computedStyle = getWindow(element).getComputedStyle(element);
          }
          const overflowRegex = /(auto|scroll|overlay)/;
          const properties = ['overflow', 'overflowX', 'overflowY'];
          return properties.some(property => {
            const value = computedStyle[property];
            return typeof value === 'string' ? overflowRegex.test(value) : false;
          });
        }
        function getScrollableAncestors(element, limit) {
          const scrollParents = [];
          function findScrollableAncestors(node) {
            if (limit != null && scrollParents.length >= limit) {
              return scrollParents;
            }
            if (!node) {
              return scrollParents;
            }
            if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
              scrollParents.push(node.scrollingElement);
              return scrollParents;
            }
            if (!isHTMLElement(node) || isSVGElement(node)) {
              return scrollParents;
            }
            if (scrollParents.includes(node)) {
              return scrollParents;
            }
            const computedStyle = getWindow(element).getComputedStyle(node);
            if (node !== element) {
              if (isScrollable(node, computedStyle)) {
                scrollParents.push(node);
              }
            }
            if (isFixed(node, computedStyle)) {
              return scrollParents;
            }
            return findScrollableAncestors(node.parentNode);
          }
          if (!element) {
            return scrollParents;
          }
          return findScrollableAncestors(element);
        }
        function getFirstScrollableAncestor(node) {
          const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
          return firstScrollableAncestor != null ? firstScrollableAncestor : null;
        }
        function getScrollableElement(element) {
          if (!canUseDOM || !element) {
            return null;
          }
          if (isWindow(element)) {
            return element;
          }
          if (!isNode(element)) {
            return null;
          }
          if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
            return window;
          }
          if (isHTMLElement(element)) {
            return element;
          }
          return null;
        }
        function getScrollXCoordinate(element) {
          if (isWindow(element)) {
            return element.scrollX;
          }
          return element.scrollLeft;
        }
        function getScrollYCoordinate(element) {
          if (isWindow(element)) {
            return element.scrollY;
          }
          return element.scrollTop;
        }
        function getScrollCoordinates(element) {
          return {
            x: getScrollXCoordinate(element),
            y: getScrollYCoordinate(element)
          };
        }
        var Direction;
        (function (Direction) {
          Direction[Direction["Forward"] = 1] = "Forward";
          Direction[Direction["Backward"] = -1] = "Backward";
        })(Direction || (Direction = {}));
        function isDocumentScrollingElement(element) {
          if (!canUseDOM || !element) {
            return false;
          }
          return element === document.scrollingElement;
        }
        function getScrollPosition(scrollingContainer) {
          const minScroll = {
            x: 0,
            y: 0
          };
          const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
            height: window.innerHeight,
            width: window.innerWidth
          } : {
            height: scrollingContainer.clientHeight,
            width: scrollingContainer.clientWidth
          };
          const maxScroll = {
            x: scrollingContainer.scrollWidth - dimensions.width,
            y: scrollingContainer.scrollHeight - dimensions.height
          };
          const isTop = scrollingContainer.scrollTop <= minScroll.y;
          const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
          const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
          const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
          return {
            isTop,
            isLeft,
            isBottom,
            isRight,
            maxScroll,
            minScroll
          };
        }
        const defaultThreshold = {
          x: 0.2,
          y: 0.2
        };
        function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
          let {
            top,
            left,
            right,
            bottom
          } = _ref;
          if (acceleration === void 0) {
            acceleration = 10;
          }
          if (thresholdPercentage === void 0) {
            thresholdPercentage = defaultThreshold;
          }
          const {
            isTop,
            isBottom,
            isLeft,
            isRight
          } = getScrollPosition(scrollContainer);
          const direction = {
            x: 0,
            y: 0
          };
          const speed = {
            x: 0,
            y: 0
          };
          const threshold = {
            height: scrollContainerRect.height * thresholdPercentage.y,
            width: scrollContainerRect.width * thresholdPercentage.x
          };
          if (!isTop && top <= scrollContainerRect.top + threshold.height) {
            // Scroll Up
            direction.y = Direction.Backward;
            speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
          } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
            // Scroll Down
            direction.y = Direction.Forward;
            speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
          }
          if (!isRight && right >= scrollContainerRect.right - threshold.width) {
            // Scroll Right
            direction.x = Direction.Forward;
            speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
          } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
            // Scroll Left
            direction.x = Direction.Backward;
            speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
          }
          return {
            direction,
            speed
          };
        }
        function getScrollElementRect(element) {
          if (element === document.scrollingElement) {
            const {
              innerWidth,
              innerHeight
            } = window;
            return {
              top: 0,
              left: 0,
              right: innerWidth,
              bottom: innerHeight,
              width: innerWidth,
              height: innerHeight
            };
          }
          const {
            top,
            left,
            right,
            bottom
          } = element.getBoundingClientRect();
          return {
            top,
            left,
            right,
            bottom,
            width: element.clientWidth,
            height: element.clientHeight
          };
        }
        function getScrollOffsets(scrollableAncestors) {
          return scrollableAncestors.reduce((acc, node) => {
            return add(acc, getScrollCoordinates(node));
          }, defaultCoordinates);
        }
        function getScrollXOffset(scrollableAncestors) {
          return scrollableAncestors.reduce((acc, node) => {
            return acc + getScrollXCoordinate(node);
          }, 0);
        }
        function getScrollYOffset(scrollableAncestors) {
          return scrollableAncestors.reduce((acc, node) => {
            return acc + getScrollYCoordinate(node);
          }, 0);
        }
        function scrollIntoViewIfNeeded(element, measure) {
          if (measure === void 0) {
            measure = getClientRect;
          }
          if (!element) {
            return;
          }
          const {
            top,
            left,
            bottom,
            right
          } = measure(element);
          const firstScrollableAncestor = getFirstScrollableAncestor(element);
          if (!firstScrollableAncestor) {
            return;
          }
          if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
            element.scrollIntoView({
              block: 'center',
              inline: 'center'
            });
          }
        }
        const properties = [['x', ['left', 'right'], getScrollXOffset], ['y', ['top', 'bottom'], getScrollYOffset]];
        class Rect {
          constructor(rect, element) {
            this.rect = void 0;
            this.width = void 0;
            this.height = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.right = void 0;
            this.left = void 0;
            const scrollableAncestors = getScrollableAncestors(element);
            const scrollOffsets = getScrollOffsets(scrollableAncestors);
            this.rect = {
              ...rect
            };
            this.width = rect.width;
            this.height = rect.height;
            for (const [axis, keys, getScrollOffset] of properties) {
              for (const key of keys) {
                Object.defineProperty(this, key, {
                  get: () => {
                    const currentOffsets = getScrollOffset(scrollableAncestors);
                    const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
                    return this.rect[key] + scrollOffsetsDeltla;
                  },
                  enumerable: true
                });
              }
            }
            Object.defineProperty(this, 'rect', {
              enumerable: false
            });
          }
        }
        class Listeners {
          constructor(target) {
            this.target = void 0;
            this.listeners = [];
            this.removeAll = () => {
              this.listeners.forEach(listener => {
                var _this$target;
                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
              });
            };
            this.target = target;
          }
          add(eventName, handler, options) {
            var _this$target2;
            (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
            this.listeners.push([eventName, handler, options]);
          }
        }
        function getEventListenerTarget(target) {
          // If the `event.target` element is removed from the document events will still be targeted
          // at it, and hence won't always bubble up to the window or document anymore.
          // If there is any risk of an element being removed while it is being dragged,
          // the best practice is to attach the event listeners directly to the target.
          // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
          const {
            EventTarget
          } = getWindow(target);
          return target instanceof EventTarget ? target : getOwnerDocument(target);
        }
        function hasExceededDistance(delta, measurement) {
          const dx = Math.abs(delta.x);
          const dy = Math.abs(delta.y);
          if (typeof measurement === 'number') {
            return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
          }
          if ('x' in measurement && 'y' in measurement) {
            return dx > measurement.x && dy > measurement.y;
          }
          if ('x' in measurement) {
            return dx > measurement.x;
          }
          if ('y' in measurement) {
            return dy > measurement.y;
          }
          return false;
        }
        var EventName;
        (function (EventName) {
          EventName["Click"] = "click";
          EventName["DragStart"] = "dragstart";
          EventName["Keydown"] = "keydown";
          EventName["ContextMenu"] = "contextmenu";
          EventName["Resize"] = "resize";
          EventName["SelectionChange"] = "selectionchange";
          EventName["VisibilityChange"] = "visibilitychange";
        })(EventName || (EventName = {}));
        function preventDefault(event) {
          event.preventDefault();
        }
        function stopPropagation(event) {
          event.stopPropagation();
        }
        var KeyboardCode;
        (function (KeyboardCode) {
          KeyboardCode["Space"] = "Space";
          KeyboardCode["Down"] = "ArrowDown";
          KeyboardCode["Right"] = "ArrowRight";
          KeyboardCode["Left"] = "ArrowLeft";
          KeyboardCode["Up"] = "ArrowUp";
          KeyboardCode["Esc"] = "Escape";
          KeyboardCode["Enter"] = "Enter";
          KeyboardCode["Tab"] = "Tab";
        })(KeyboardCode || (KeyboardCode = {}));
        const defaultKeyboardCodes = {
          start: [KeyboardCode.Space, KeyboardCode.Enter],
          cancel: [KeyboardCode.Esc],
          end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
        };
        const defaultKeyboardCoordinateGetter = (event, _ref) => {
          let {
            currentCoordinates
          } = _ref;
          switch (event.code) {
            case KeyboardCode.Right:
              return {
                ...currentCoordinates,
                x: currentCoordinates.x + 25
              };
            case KeyboardCode.Left:
              return {
                ...currentCoordinates,
                x: currentCoordinates.x - 25
              };
            case KeyboardCode.Down:
              return {
                ...currentCoordinates,
                y: currentCoordinates.y + 25
              };
            case KeyboardCode.Up:
              return {
                ...currentCoordinates,
                y: currentCoordinates.y - 25
              };
          }
          return undefined;
        };
        class KeyboardSensor {
          constructor(props) {
            this.props = void 0;
            this.autoScrollEnabled = false;
            this.referenceCoordinates = void 0;
            this.listeners = void 0;
            this.windowListeners = void 0;
            this.props = props;
            const {
              event: {
                target
              }
            } = props;
            this.props = props;
            this.listeners = new Listeners(getOwnerDocument(target));
            this.windowListeners = new Listeners(getWindow(target));
            this.handleKeyDown = this.handleKeyDown.bind(this);
            this.handleCancel = this.handleCancel.bind(this);
            this.attach();
          }
          attach() {
            this.handleStart();
            this.windowListeners.add(EventName.Resize, this.handleCancel);
            this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
            setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
          }
          handleStart() {
            const {
              activeNode,
              onStart
            } = this.props;
            const node = activeNode.node.current;
            if (node) {
              scrollIntoViewIfNeeded(node);
            }
            onStart(defaultCoordinates);
          }
          handleKeyDown(event) {
            if (isKeyboardEvent(event)) {
              const {
                active,
                context,
                options
              } = this.props;
              const {
                keyboardCodes = defaultKeyboardCodes,
                coordinateGetter = defaultKeyboardCoordinateGetter,
                scrollBehavior = 'smooth'
              } = options;
              const {
                code
              } = event;
              if (keyboardCodes.end.includes(code)) {
                this.handleEnd(event);
                return;
              }
              if (keyboardCodes.cancel.includes(code)) {
                this.handleCancel(event);
                return;
              }
              const {
                collisionRect
              } = context.current;
              const currentCoordinates = collisionRect ? {
                x: collisionRect.left,
                y: collisionRect.top
              } : defaultCoordinates;
              if (!this.referenceCoordinates) {
                this.referenceCoordinates = currentCoordinates;
              }
              const newCoordinates = coordinateGetter(event, {
                active,
                context: context.current,
                currentCoordinates
              });
              if (newCoordinates) {
                const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
                const scrollDelta = {
                  x: 0,
                  y: 0
                };
                const {
                  scrollableAncestors
                } = context.current;
                for (const scrollContainer of scrollableAncestors) {
                  const direction = event.code;
                  const {
                    isTop,
                    isRight,
                    isLeft,
                    isBottom,
                    maxScroll,
                    minScroll
                  } = getScrollPosition(scrollContainer);
                  const scrollElementRect = getScrollElementRect(scrollContainer);
                  const clampedCoordinates = {
                    x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
                    y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
                  };
                  const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
                  const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
                  if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
                    const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
                    const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
                    if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                      // We don't need to update coordinates, the scroll adjustment alone will trigger
                      // logic to auto-detect the new container we are over
                      scrollContainer.scrollTo({
                        left: newScrollCoordinates,
                        behavior: scrollBehavior
                      });
                      return;
                    }
                    if (canScrollToNewCoordinates) {
                      scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
                    } else {
                      scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
                    }
                    if (scrollDelta.x) {
                      scrollContainer.scrollBy({
                        left: -scrollDelta.x,
                        behavior: scrollBehavior
                      });
                    }
                    break;
                  } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
                    const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
                    const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
                    if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                      // We don't need to update coordinates, the scroll adjustment alone will trigger
                      // logic to auto-detect the new container we are over
                      scrollContainer.scrollTo({
                        top: newScrollCoordinates,
                        behavior: scrollBehavior
                      });
                      return;
                    }
                    if (canScrollToNewCoordinates) {
                      scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
                    } else {
                      scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
                    }
                    if (scrollDelta.y) {
                      scrollContainer.scrollBy({
                        top: -scrollDelta.y,
                        behavior: scrollBehavior
                      });
                    }
                    break;
                  }
                }
                this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
              }
            }
          }
          handleMove(event, coordinates) {
            const {
              onMove
            } = this.props;
            event.preventDefault();
            onMove(coordinates);
          }
          handleEnd(event) {
            const {
              onEnd
            } = this.props;
            event.preventDefault();
            this.detach();
            onEnd();
          }
          handleCancel(event) {
            const {
              onCancel
            } = this.props;
            event.preventDefault();
            this.detach();
            onCancel();
          }
          detach() {
            this.listeners.removeAll();
            this.windowListeners.removeAll();
          }
        }
        KeyboardSensor.activators = [{
          eventName: 'onKeyDown',
          handler: (event, _ref, _ref2) => {
            let {
              keyboardCodes = defaultKeyboardCodes,
              onActivation
            } = _ref;
            let {
              active
            } = _ref2;
            const {
              code
            } = event.nativeEvent;
            if (keyboardCodes.start.includes(code)) {
              const activator = active.activatorNode.current;
              if (activator && event.target !== activator) {
                return false;
              }
              event.preventDefault();
              onActivation == null ? void 0 : onActivation({
                event: event.nativeEvent
              });
              return true;
            }
            return false;
          }
        }];
        function isDistanceConstraint(constraint) {
          return Boolean(constraint && 'distance' in constraint);
        }
        function isDelayConstraint(constraint) {
          return Boolean(constraint && 'delay' in constraint);
        }
        class AbstractPointerSensor {
          constructor(props, events, listenerTarget) {
            var _getEventCoordinates;
            if (listenerTarget === void 0) {
              listenerTarget = getEventListenerTarget(props.event.target);
            }
            this.props = void 0;
            this.events = void 0;
            this.autoScrollEnabled = true;
            this.document = void 0;
            this.activated = false;
            this.initialCoordinates = void 0;
            this.timeoutId = null;
            this.listeners = void 0;
            this.documentListeners = void 0;
            this.windowListeners = void 0;
            this.props = props;
            this.events = events;
            const {
              event
            } = props;
            const {
              target
            } = event;
            this.props = props;
            this.events = events;
            this.document = getOwnerDocument(target);
            this.documentListeners = new Listeners(this.document);
            this.listeners = new Listeners(listenerTarget);
            this.windowListeners = new Listeners(getWindow(target));
            this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
            this.handleStart = this.handleStart.bind(this);
            this.handleMove = this.handleMove.bind(this);
            this.handleEnd = this.handleEnd.bind(this);
            this.handleCancel = this.handleCancel.bind(this);
            this.handleKeydown = this.handleKeydown.bind(this);
            this.removeTextSelection = this.removeTextSelection.bind(this);
            this.attach();
          }
          attach() {
            const {
              events,
              props: {
                options: {
                  activationConstraint,
                  bypassActivationConstraint
                }
              }
            } = this;
            this.listeners.add(events.move.name, this.handleMove, {
              passive: false
            });
            this.listeners.add(events.end.name, this.handleEnd);
            if (events.cancel) {
              this.listeners.add(events.cancel.name, this.handleCancel);
            }
            this.windowListeners.add(EventName.Resize, this.handleCancel);
            this.windowListeners.add(EventName.DragStart, preventDefault);
            this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
            this.windowListeners.add(EventName.ContextMenu, preventDefault);
            this.documentListeners.add(EventName.Keydown, this.handleKeydown);
            if (activationConstraint) {
              if (bypassActivationConstraint != null && bypassActivationConstraint({
                event: this.props.event,
                activeNode: this.props.activeNode,
                options: this.props.options
              })) {
                return this.handleStart();
              }
              if (isDelayConstraint(activationConstraint)) {
                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
                this.handlePending(activationConstraint);
                return;
              }
              if (isDistanceConstraint(activationConstraint)) {
                this.handlePending(activationConstraint);
                return;
              }
            }
            this.handleStart();
          }
          detach() {
            this.listeners.removeAll();
            this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners
            // This is necessary because we listen for `click` and `selection` events on the document

            setTimeout(this.documentListeners.removeAll, 50);
            if (this.timeoutId !== null) {
              clearTimeout(this.timeoutId);
              this.timeoutId = null;
            }
          }
          handlePending(constraint, offset) {
            const {
              active,
              onPending
            } = this.props;
            onPending(active, constraint, this.initialCoordinates, offset);
          }
          handleStart() {
            const {
              initialCoordinates
            } = this;
            const {
              onStart
            } = this.props;
            if (initialCoordinates) {
              this.activated = true; // Stop propagation of click events once activation constraints are met

              this.documentListeners.add(EventName.Click, stopPropagation, {
                capture: true
              }); // Remove any text selection from the document

              this.removeTextSelection(); // Prevent further text selection while dragging

              this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
              onStart(initialCoordinates);
            }
          }
          handleMove(event) {
            var _getEventCoordinates2;
            const {
              activated,
              initialCoordinates,
              props
            } = this;
            const {
              onMove,
              options: {
                activationConstraint
              }
            } = props;
            if (!initialCoordinates) {
              return;
            }
            const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
            const delta = subtract(initialCoordinates, coordinates); // Constraint validation

            if (!activated && activationConstraint) {
              if (isDistanceConstraint(activationConstraint)) {
                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
                  return this.handleCancel();
                }
                if (hasExceededDistance(delta, activationConstraint.distance)) {
                  return this.handleStart();
                }
              }
              if (isDelayConstraint(activationConstraint)) {
                if (hasExceededDistance(delta, activationConstraint.tolerance)) {
                  return this.handleCancel();
                }
              }
              this.handlePending(activationConstraint, delta);
              return;
            }
            if (event.cancelable) {
              event.preventDefault();
            }
            onMove(coordinates);
          }
          handleEnd() {
            const {
              onAbort,
              onEnd
            } = this.props;
            this.detach();
            if (!this.activated) {
              onAbort(this.props.active);
            }
            onEnd();
          }
          handleCancel() {
            const {
              onAbort,
              onCancel
            } = this.props;
            this.detach();
            if (!this.activated) {
              onAbort(this.props.active);
            }
            onCancel();
          }
          handleKeydown(event) {
            if (event.code === KeyboardCode.Esc) {
              this.handleCancel();
            }
          }
          removeTextSelection() {
            var _this$document$getSel;
            (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
          }
        }
        const events = {
          cancel: {
            name: 'pointercancel'
          },
          move: {
            name: 'pointermove'
          },
          end: {
            name: 'pointerup'
          }
        };
        class PointerSensor extends AbstractPointerSensor {
          constructor(props) {
            const {
              event
            } = props; // Pointer events stop firing if the target is unmounted while dragging
            // Therefore we attach listeners to the owner document instead

            const listenerTarget = getOwnerDocument(event.target);
            super(props, events, listenerTarget);
          }
        }
        PointerSensor.activators = [{
          eventName: 'onPointerDown',
          handler: (_ref, _ref2) => {
            let {
              nativeEvent: event
            } = _ref;
            let {
              onActivation
            } = _ref2;
            if (!event.isPrimary || event.button !== 0) {
              return false;
            }
            onActivation == null ? void 0 : onActivation({
              event
            });
            return true;
          }
        }];
        const events$1 = {
          move: {
            name: 'mousemove'
          },
          end: {
            name: 'mouseup'
          }
        };
        var MouseButton;
        (function (MouseButton) {
          MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
        })(MouseButton || (MouseButton = {}));
        class MouseSensor extends AbstractPointerSensor {
          constructor(props) {
            super(props, events$1, getOwnerDocument(props.event.target));
          }
        }
        MouseSensor.activators = [{
          eventName: 'onMouseDown',
          handler: (_ref, _ref2) => {
            let {
              nativeEvent: event
            } = _ref;
            let {
              onActivation
            } = _ref2;
            if (event.button === MouseButton.RightClick) {
              return false;
            }
            onActivation == null ? void 0 : onActivation({
              event
            });
            return true;
          }
        }];
        const events$2 = {
          cancel: {
            name: 'touchcancel'
          },
          move: {
            name: 'touchmove'
          },
          end: {
            name: 'touchend'
          }
        };
        class TouchSensor extends AbstractPointerSensor {
          constructor(props) {
            super(props, events$2);
          }
          static setup() {
            // Adding a non-capture and non-passive `touchmove` listener in order
            // to force `event.preventDefault()` calls to work in dynamically added
            // touchmove event handlers. This is required for iOS Safari.
            window.addEventListener(events$2.move.name, noop, {
              capture: false,
              passive: false
            });
            return function teardown() {
              window.removeEventListener(events$2.move.name, noop);
            }; // We create a new handler because the teardown function of another sensor
            // could remove our event listener if we use a referentially equal listener.

            function noop() {}
          }
        }
        TouchSensor.activators = [{
          eventName: 'onTouchStart',
          handler: (_ref, _ref2) => {
            let {
              nativeEvent: event
            } = _ref;
            let {
              onActivation
            } = _ref2;
            const {
              touches
            } = event;
            if (touches.length > 1) {
              return false;
            }
            onActivation == null ? void 0 : onActivation({
              event
            });
            return true;
          }
        }];
        var AutoScrollActivator;
        (function (AutoScrollActivator) {
          AutoScrollActivator[AutoScrollActivator["Pointer"] = 0] = "Pointer";
          AutoScrollActivator[AutoScrollActivator["DraggableRect"] = 1] = "DraggableRect";
        })(AutoScrollActivator || (AutoScrollActivator = {}));
        var TraversalOrder;
        (function (TraversalOrder) {
          TraversalOrder[TraversalOrder["TreeOrder"] = 0] = "TreeOrder";
          TraversalOrder[TraversalOrder["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
        })(TraversalOrder || (TraversalOrder = {}));
        function useAutoScroller(_ref) {
          let {
            acceleration,
            activator = AutoScrollActivator.Pointer,
            canScroll,
            draggingRect,
            enabled,
            interval = 5,
            order = TraversalOrder.TreeOrder,
            pointerCoordinates,
            scrollableAncestors,
            scrollableAncestorRects,
            delta,
            threshold
          } = _ref;
          const scrollIntent = useScrollIntent({
            delta,
            disabled: !enabled
          });
          const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
          const scrollSpeed = reactExports.useRef({
            x: 0,
            y: 0
          });
          const scrollDirection = reactExports.useRef({
            x: 0,
            y: 0
          });
          const rect = reactExports.useMemo(() => {
            switch (activator) {
              case AutoScrollActivator.Pointer:
                return pointerCoordinates ? {
                  top: pointerCoordinates.y,
                  bottom: pointerCoordinates.y,
                  left: pointerCoordinates.x,
                  right: pointerCoordinates.x
                } : null;
              case AutoScrollActivator.DraggableRect:
                return draggingRect;
            }
          }, [activator, draggingRect, pointerCoordinates]);
          const scrollContainerRef = reactExports.useRef(null);
          const autoScroll = reactExports.useCallback(() => {
            const scrollContainer = scrollContainerRef.current;
            if (!scrollContainer) {
              return;
            }
            const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
            const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
            scrollContainer.scrollBy(scrollLeft, scrollTop);
          }, []);
          const sortedScrollableAncestors = reactExports.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
          reactExports.useEffect(() => {
            if (!enabled || !scrollableAncestors.length || !rect) {
              clearAutoScrollInterval();
              return;
            }
            for (const scrollContainer of sortedScrollableAncestors) {
              if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
                continue;
              }
              const index = scrollableAncestors.indexOf(scrollContainer);
              const scrollContainerRect = scrollableAncestorRects[index];
              if (!scrollContainerRect) {
                continue;
              }
              const {
                direction,
                speed
              } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
              for (const axis of ['x', 'y']) {
                if (!scrollIntent[axis][direction[axis]]) {
                  speed[axis] = 0;
                  direction[axis] = 0;
                }
              }
              if (speed.x > 0 || speed.y > 0) {
                clearAutoScrollInterval();
                scrollContainerRef.current = scrollContainer;
                setAutoScrollInterval(autoScroll, interval);
                scrollSpeed.current = speed;
                scrollDirection.current = direction;
                return;
              }
            }
            scrollSpeed.current = {
              x: 0,
              y: 0
            };
            scrollDirection.current = {
              x: 0,
              y: 0
            };
            clearAutoScrollInterval();
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [acceleration, autoScroll, canScroll, clearAutoScrollInterval, enabled, interval,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          JSON.stringify(rect),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          JSON.stringify(scrollIntent), setAutoScrollInterval, scrollableAncestors, sortedScrollableAncestors, scrollableAncestorRects,
          // eslint-disable-next-line react-hooks/exhaustive-deps
          JSON.stringify(threshold)]);
        }
        const defaultScrollIntent = {
          x: {
            [Direction.Backward]: false,
            [Direction.Forward]: false
          },
          y: {
            [Direction.Backward]: false,
            [Direction.Forward]: false
          }
        };
        function useScrollIntent(_ref2) {
          let {
            delta,
            disabled
          } = _ref2;
          const previousDelta = usePrevious(delta);
          return useLazyMemo(previousIntent => {
            if (disabled || !previousDelta || !previousIntent) {
              // Reset scroll intent tracking when auto-scrolling is disabled
              return defaultScrollIntent;
            }
            const direction = {
              x: Math.sign(delta.x - previousDelta.x),
              y: Math.sign(delta.y - previousDelta.y)
            }; // Keep track of the user intent to scroll in each direction for both axis

            return {
              x: {
                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
              },
              y: {
                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
              }
            };
          }, [disabled, delta, previousDelta]);
        }
        function useCachedNode(draggableNodes, id) {
          const draggableNode = id != null ? draggableNodes.get(id) : undefined;
          const node = draggableNode ? draggableNode.node.current : null;
          return useLazyMemo(cachedNode => {
            var _ref;
            if (id == null) {
              return null;
            } // In some cases, the draggable node can unmount while dragging
            // This is the case for virtualized lists. In those situations,
            // we fall back to the last known value for that node.

            return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
          }, [node, id]);
        }
        function useCombineActivators(sensors, getSyntheticHandler) {
          return reactExports.useMemo(() => sensors.reduce((accumulator, sensor) => {
            const {
              sensor: Sensor
            } = sensor;
            const sensorActivators = Sensor.activators.map(activator => ({
              eventName: activator.eventName,
              handler: getSyntheticHandler(activator.handler, sensor)
            }));
            return [...accumulator, ...sensorActivators];
          }, []), [sensors, getSyntheticHandler]);
        }
        var MeasuringStrategy;
        (function (MeasuringStrategy) {
          MeasuringStrategy[MeasuringStrategy["Always"] = 0] = "Always";
          MeasuringStrategy[MeasuringStrategy["BeforeDragging"] = 1] = "BeforeDragging";
          MeasuringStrategy[MeasuringStrategy["WhileDragging"] = 2] = "WhileDragging";
        })(MeasuringStrategy || (MeasuringStrategy = {}));
        var MeasuringFrequency;
        (function (MeasuringFrequency) {
          MeasuringFrequency["Optimized"] = "optimized";
        })(MeasuringFrequency || (MeasuringFrequency = {}));
        const defaultValue = /*#__PURE__*/new Map();
        function useDroppableMeasuring(containers, _ref) {
          let {
            dragging,
            dependencies,
            config
          } = _ref;
          const [queue, setQueue] = reactExports.useState(null);
          const {
            frequency,
            measure,
            strategy
          } = config;
          const containersRef = reactExports.useRef(containers);
          const disabled = isDisabled();
          const disabledRef = useLatestValue(disabled);
          const measureDroppableContainers = reactExports.useCallback(function (ids) {
            if (ids === void 0) {
              ids = [];
            }
            if (disabledRef.current) {
              return;
            }
            setQueue(value => {
              if (value === null) {
                return ids;
              }
              return value.concat(ids.filter(id => !value.includes(id)));
            });
          }, [disabledRef]);
          const timeoutId = reactExports.useRef(null);
          const droppableRects = useLazyMemo(previousValue => {
            if (disabled && !dragging) {
              return defaultValue;
            }
            if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
              const map = new Map();
              for (let container of containers) {
                if (!container) {
                  continue;
                }
                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
                  // This container does not need to be re-measured
                  map.set(container.id, container.rect.current);
                  continue;
                }
                const node = container.node.current;
                const rect = node ? new Rect(measure(node), node) : null;
                container.rect.current = rect;
                if (rect) {
                  map.set(container.id, rect);
                }
              }
              return map;
            }
            return previousValue;
          }, [containers, queue, dragging, disabled, measure]);
          reactExports.useEffect(() => {
            containersRef.current = containers;
          }, [containers]);
          reactExports.useEffect(() => {
            if (disabled) {
              return;
            }
            measureDroppableContainers();
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [dragging, disabled]);
          reactExports.useEffect(() => {
            if (queue && queue.length > 0) {
              setQueue(null);
            }
          },
          //eslint-disable-next-line react-hooks/exhaustive-deps
          [JSON.stringify(queue)]);
          reactExports.useEffect(() => {
            if (disabled || typeof frequency !== 'number' || timeoutId.current !== null) {
              return;
            }
            timeoutId.current = setTimeout(() => {
              measureDroppableContainers();
              timeoutId.current = null;
            }, frequency);
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [frequency, disabled, measureDroppableContainers, ...dependencies]);
          return {
            droppableRects,
            measureDroppableContainers,
            measuringScheduled: queue != null
          };
          function isDisabled() {
            switch (strategy) {
              case MeasuringStrategy.Always:
                return false;
              case MeasuringStrategy.BeforeDragging:
                return dragging;
              default:
                return !dragging;
            }
          }
        }
        function useInitialValue(value, computeFn) {
          return useLazyMemo(previousValue => {
            if (!value) {
              return null;
            }
            if (previousValue) {
              return previousValue;
            }
            return typeof computeFn === 'function' ? computeFn(value) : value;
          }, [computeFn, value]);
        }
        function useInitialRect(node, measure) {
          return useInitialValue(node, measure);
        }

        /**
         * Returns a new MutationObserver instance.
         * If `MutationObserver` is undefined in the execution environment, returns `undefined`.
         */

        function useMutationObserver(_ref) {
          let {
            callback,
            disabled
          } = _ref;
          const handleMutations = useEvent(callback);
          const mutationObserver = reactExports.useMemo(() => {
            if (disabled || typeof window === 'undefined' || typeof window.MutationObserver === 'undefined') {
              return undefined;
            }
            const {
              MutationObserver
            } = window;
            return new MutationObserver(handleMutations);
          }, [handleMutations, disabled]);
          reactExports.useEffect(() => {
            return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
          }, [mutationObserver]);
          return mutationObserver;
        }

        /**
         * Returns a new ResizeObserver instance bound to the `onResize` callback.
         * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.
         */

        function useResizeObserver(_ref) {
          let {
            callback,
            disabled
          } = _ref;
          const handleResize = useEvent(callback);
          const resizeObserver = reactExports.useMemo(() => {
            if (disabled || typeof window === 'undefined' || typeof window.ResizeObserver === 'undefined') {
              return undefined;
            }
            const {
              ResizeObserver
            } = window;
            return new ResizeObserver(handleResize);
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [disabled]);
          reactExports.useEffect(() => {
            return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
          }, [resizeObserver]);
          return resizeObserver;
        }
        function defaultMeasure(element) {
          return new Rect(getClientRect(element), element);
        }
        function useRect(element, measure, fallbackRect) {
          if (measure === void 0) {
            measure = defaultMeasure;
          }
          const [rect, setRect] = reactExports.useState(null);
          function measureRect() {
            setRect(currentRect => {
              if (!element) {
                return null;
              }
              if (element.isConnected === false) {
                var _ref;

                // Fall back to last rect we measured if the element is
                // no longer connected to the DOM.
                return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
              }
              const newRect = measure(element);
              if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
                return currentRect;
              }
              return newRect;
            });
          }
          const mutationObserver = useMutationObserver({
            callback(records) {
              if (!element) {
                return;
              }
              for (const record of records) {
                const {
                  type,
                  target
                } = record;
                if (type === 'childList' && target instanceof HTMLElement && target.contains(element)) {
                  measureRect();
                  break;
                }
              }
            }
          });
          const resizeObserver = useResizeObserver({
            callback: measureRect
          });
          useIsomorphicLayoutEffect(() => {
            measureRect();
            if (element) {
              resizeObserver == null ? void 0 : resizeObserver.observe(element);
              mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
                childList: true,
                subtree: true
              });
            } else {
              resizeObserver == null ? void 0 : resizeObserver.disconnect();
              mutationObserver == null ? void 0 : mutationObserver.disconnect();
            }
          }, [element]);
          return rect;
        }
        function useRectDelta(rect) {
          const initialRect = useInitialValue(rect);
          return getRectDelta(rect, initialRect);
        }
        const defaultValue$1 = [];
        function useScrollableAncestors(node) {
          const previousNode = reactExports.useRef(node);
          const ancestors = useLazyMemo(previousValue => {
            if (!node) {
              return defaultValue$1;
            }
            if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
              return previousValue;
            }
            return getScrollableAncestors(node);
          }, [node]);
          reactExports.useEffect(() => {
            previousNode.current = node;
          }, [node]);
          return ancestors;
        }
        function useScrollOffsets(elements) {
          const [scrollCoordinates, setScrollCoordinates] = reactExports.useState(null);
          const prevElements = reactExports.useRef(elements); // To-do: Throttle the handleScroll callback

          const handleScroll = reactExports.useCallback(event => {
            const scrollingElement = getScrollableElement(event.target);
            if (!scrollingElement) {
              return;
            }
            setScrollCoordinates(scrollCoordinates => {
              if (!scrollCoordinates) {
                return null;
              }
              scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));
              return new Map(scrollCoordinates);
            });
          }, []);
          reactExports.useEffect(() => {
            const previousElements = prevElements.current;
            if (elements !== previousElements) {
              cleanup(previousElements);
              const entries = elements.map(element => {
                const scrollableElement = getScrollableElement(element);
                if (scrollableElement) {
                  scrollableElement.addEventListener('scroll', handleScroll, {
                    passive: true
                  });
                  return [scrollableElement, getScrollCoordinates(scrollableElement)];
                }
                return null;
              }).filter(entry => entry != null);
              setScrollCoordinates(entries.length ? new Map(entries) : null);
              prevElements.current = elements;
            }
            return () => {
              cleanup(elements);
              cleanup(previousElements);
            };
            function cleanup(elements) {
              elements.forEach(element => {
                const scrollableElement = getScrollableElement(element);
                scrollableElement == null ? void 0 : scrollableElement.removeEventListener('scroll', handleScroll);
              });
            }
          }, [handleScroll, elements]);
          return reactExports.useMemo(() => {
            if (elements.length) {
              return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
            }
            return defaultCoordinates;
          }, [elements, scrollCoordinates]);
        }
        function useScrollOffsetsDelta(scrollOffsets, dependencies) {
          if (dependencies === void 0) {
            dependencies = [];
          }
          const initialScrollOffsets = reactExports.useRef(null);
          reactExports.useEffect(() => {
            initialScrollOffsets.current = null;
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          dependencies);
          reactExports.useEffect(() => {
            const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
            if (hasScrollOffsets && !initialScrollOffsets.current) {
              initialScrollOffsets.current = scrollOffsets;
            }
            if (!hasScrollOffsets && initialScrollOffsets.current) {
              initialScrollOffsets.current = null;
            }
          }, [scrollOffsets]);
          return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
        }
        function useSensorSetup(sensors) {
          reactExports.useEffect(() => {
            if (!canUseDOM) {
              return;
            }
            const teardownFns = sensors.map(_ref => {
              let {
                sensor
              } = _ref;
              return sensor.setup == null ? void 0 : sensor.setup();
            });
            return () => {
              for (const teardown of teardownFns) {
                teardown == null ? void 0 : teardown();
              }
            };
          },
          // TO-DO: Sensors length could theoretically change which would not be a valid dependency
          // eslint-disable-next-line react-hooks/exhaustive-deps
          sensors.map(_ref2 => {
            let {
              sensor
            } = _ref2;
            return sensor;
          }));
        }
        function useSyntheticListeners(listeners, id) {
          return reactExports.useMemo(() => {
            return listeners.reduce((acc, _ref) => {
              let {
                eventName,
                handler
              } = _ref;
              acc[eventName] = event => {
                handler(event, id);
              };
              return acc;
            }, {});
          }, [listeners, id]);
        }
        function useWindowRect(element) {
          return reactExports.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
        }
        const defaultValue$2 = [];
        function useRects(elements, measure) {
          if (measure === void 0) {
            measure = getClientRect;
          }
          const [firstElement] = elements;
          const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
          const [rects, setRects] = reactExports.useState(defaultValue$2);
          function measureRects() {
            setRects(() => {
              if (!elements.length) {
                return defaultValue$2;
              }
              return elements.map(element => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
            });
          }
          const resizeObserver = useResizeObserver({
            callback: measureRects
          });
          useIsomorphicLayoutEffect(() => {
            resizeObserver == null ? void 0 : resizeObserver.disconnect();
            measureRects();
            elements.forEach(element => resizeObserver == null ? void 0 : resizeObserver.observe(element));
          }, [elements]);
          return rects;
        }
        function getMeasurableNode(node) {
          if (!node) {
            return null;
          }
          if (node.children.length > 1) {
            return node;
          }
          const firstChild = node.children[0];
          return isHTMLElement(firstChild) ? firstChild : node;
        }
        function useDragOverlayMeasuring(_ref) {
          let {
            measure
          } = _ref;
          const [rect, setRect] = reactExports.useState(null);
          const handleResize = reactExports.useCallback(entries => {
            for (const {
              target
            } of entries) {
              if (isHTMLElement(target)) {
                setRect(rect => {
                  const newRect = measure(target);
                  return rect ? {
                    ...rect,
                    width: newRect.width,
                    height: newRect.height
                  } : newRect;
                });
                break;
              }
            }
          }, [measure]);
          const resizeObserver = useResizeObserver({
            callback: handleResize
          });
          const handleNodeChange = reactExports.useCallback(element => {
            const node = getMeasurableNode(element);
            resizeObserver == null ? void 0 : resizeObserver.disconnect();
            if (node) {
              resizeObserver == null ? void 0 : resizeObserver.observe(node);
            }
            setRect(node ? measure(node) : null);
          }, [measure, resizeObserver]);
          const [nodeRef, setRef] = useNodeRef(handleNodeChange);
          return reactExports.useMemo(() => ({
            nodeRef,
            rect,
            setRef
          }), [rect, nodeRef, setRef]);
        }
        const defaultSensors = [{
          sensor: PointerSensor,
          options: {}
        }, {
          sensor: KeyboardSensor,
          options: {}
        }];
        const defaultData = {
          current: {}
        };
        const defaultMeasuringConfiguration = {
          draggable: {
            measure: getTransformAgnosticClientRect
          },
          droppable: {
            measure: getTransformAgnosticClientRect,
            strategy: MeasuringStrategy.WhileDragging,
            frequency: MeasuringFrequency.Optimized
          },
          dragOverlay: {
            measure: getClientRect
          }
        };
        class DroppableContainersMap extends Map {
          get(id) {
            var _super$get;
            return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;
          }
          toArray() {
            return Array.from(this.values());
          }
          getEnabled() {
            return this.toArray().filter(_ref => {
              let {
                disabled
              } = _ref;
              return !disabled;
            });
          }
          getNodeFor(id) {
            var _this$get$node$curren, _this$get;
            return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;
          }
        }
        const defaultPublicContext = {
          activatorEvent: null,
          active: null,
          activeNode: null,
          activeNodeRect: null,
          collisions: null,
          containerNodeRect: null,
          draggableNodes: /*#__PURE__*/new Map(),
          droppableRects: /*#__PURE__*/new Map(),
          droppableContainers: /*#__PURE__*/new DroppableContainersMap(),
          over: null,
          dragOverlay: {
            nodeRef: {
              current: null
            },
            rect: null,
            setRef: noop
          },
          scrollableAncestors: [],
          scrollableAncestorRects: [],
          measuringConfiguration: defaultMeasuringConfiguration,
          measureDroppableContainers: noop,
          windowRect: null,
          measuringScheduled: false
        };
        const defaultInternalContext = {
          activatorEvent: null,
          activators: [],
          active: null,
          activeNodeRect: null,
          ariaDescribedById: {
            draggable: ''
          },
          dispatch: noop,
          draggableNodes: /*#__PURE__*/new Map(),
          over: null,
          measureDroppableContainers: noop
        };
        const InternalContext = /*#__PURE__*/reactExports.createContext(defaultInternalContext);
        const PublicContext = /*#__PURE__*/reactExports.createContext(defaultPublicContext);
        function getInitialState() {
          return {
            draggable: {
              active: null,
              initialCoordinates: {
                x: 0,
                y: 0
              },
              nodes: new Map(),
              translate: {
                x: 0,
                y: 0
              }
            },
            droppable: {
              containers: new DroppableContainersMap()
            }
          };
        }
        function reducer(state, action) {
          switch (action.type) {
            case Action.DragStart:
              return {
                ...state,
                draggable: {
                  ...state.draggable,
                  initialCoordinates: action.initialCoordinates,
                  active: action.active
                }
              };
            case Action.DragMove:
              if (state.draggable.active == null) {
                return state;
              }
              return {
                ...state,
                draggable: {
                  ...state.draggable,
                  translate: {
                    x: action.coordinates.x - state.draggable.initialCoordinates.x,
                    y: action.coordinates.y - state.draggable.initialCoordinates.y
                  }
                }
              };
            case Action.DragEnd:
            case Action.DragCancel:
              return {
                ...state,
                draggable: {
                  ...state.draggable,
                  active: null,
                  initialCoordinates: {
                    x: 0,
                    y: 0
                  },
                  translate: {
                    x: 0,
                    y: 0
                  }
                }
              };
            case Action.RegisterDroppable:
              {
                const {
                  element
                } = action;
                const {
                  id
                } = element;
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.set(id, element);
                return {
                  ...state,
                  droppable: {
                    ...state.droppable,
                    containers
                  }
                };
              }
            case Action.SetDroppableDisabled:
              {
                const {
                  id,
                  key,
                  disabled
                } = action;
                const element = state.droppable.containers.get(id);
                if (!element || key !== element.key) {
                  return state;
                }
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.set(id, {
                  ...element,
                  disabled
                });
                return {
                  ...state,
                  droppable: {
                    ...state.droppable,
                    containers
                  }
                };
              }
            case Action.UnregisterDroppable:
              {
                const {
                  id,
                  key
                } = action;
                const element = state.droppable.containers.get(id);
                if (!element || key !== element.key) {
                  return state;
                }
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.delete(id);
                return {
                  ...state,
                  droppable: {
                    ...state.droppable,
                    containers
                  }
                };
              }
            default:
              {
                return state;
              }
          }
        }
        function RestoreFocus(_ref) {
          let {
            disabled
          } = _ref;
          const {
            active,
            activatorEvent,
            draggableNodes
          } = reactExports.useContext(InternalContext);
          const previousActivatorEvent = usePrevious(activatorEvent);
          const previousActiveId = usePrevious(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node

          reactExports.useEffect(() => {
            if (disabled) {
              return;
            }
            if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
              if (!isKeyboardEvent(previousActivatorEvent)) {
                return;
              }
              if (document.activeElement === previousActivatorEvent.target) {
                // No need to restore focus
                return;
              }
              const draggableNode = draggableNodes.get(previousActiveId);
              if (!draggableNode) {
                return;
              }
              const {
                activatorNode,
                node
              } = draggableNode;
              if (!activatorNode.current && !node.current) {
                return;
              }
              requestAnimationFrame(() => {
                for (const element of [activatorNode.current, node.current]) {
                  if (!element) {
                    continue;
                  }
                  const focusableNode = findFirstFocusableNode(element);
                  if (focusableNode) {
                    focusableNode.focus();
                    break;
                  }
                }
              });
            }
          }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
          return null;
        }
        function applyModifiers(modifiers, _ref) {
          let {
            transform,
            ...args
          } = _ref;
          return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
            return modifier({
              transform: accumulator,
              ...args
            });
          }, transform) : transform;
        }
        function useMeasuringConfiguration(config) {
          return reactExports.useMemo(() => ({
            draggable: {
              ...defaultMeasuringConfiguration.draggable,
              ...(config == null ? void 0 : config.draggable)
            },
            droppable: {
              ...defaultMeasuringConfiguration.droppable,
              ...(config == null ? void 0 : config.droppable)
            },
            dragOverlay: {
              ...defaultMeasuringConfiguration.dragOverlay,
              ...(config == null ? void 0 : config.dragOverlay)
            }
          }),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]);
        }
        function useLayoutShiftScrollCompensation(_ref) {
          let {
            activeNode,
            measure,
            initialRect,
            config = true
          } = _ref;
          const initialized = reactExports.useRef(false);
          const {
            x,
            y
          } = typeof config === 'boolean' ? {
            x: config,
            y: config
          } : config;
          useIsomorphicLayoutEffect(() => {
            const disabled = !x && !y;
            if (disabled || !activeNode) {
              initialized.current = false;
              return;
            }
            if (initialized.current || !initialRect) {
              // Return early if layout shift scroll compensation was already attempted
              // or if there is no initialRect to compare to.
              return;
            } // Get the most up to date node ref for the active draggable

            const node = activeNode == null ? void 0 : activeNode.node.current;
            if (!node || node.isConnected === false) {
              // Return early if there is no attached node ref or if the node is
              // disconnected from the document.
              return;
            }
            const rect = measure(node);
            const rectDelta = getRectDelta(rect, initialRect);
            if (!x) {
              rectDelta.x = 0;
            }
            if (!y) {
              rectDelta.y = 0;
            } // Only perform layout shift scroll compensation once

            initialized.current = true;
            if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
              const firstScrollableAncestor = getFirstScrollableAncestor(node);
              if (firstScrollableAncestor) {
                firstScrollableAncestor.scrollBy({
                  top: rectDelta.y,
                  left: rectDelta.x
                });
              }
            }
          }, [activeNode, x, y, initialRect, measure]);
        }
        const ActiveDraggableContext = /*#__PURE__*/reactExports.createContext({
          ...defaultCoordinates,
          scaleX: 1,
          scaleY: 1
        });
        var Status;
        (function (Status) {
          Status[Status["Uninitialized"] = 0] = "Uninitialized";
          Status[Status["Initializing"] = 1] = "Initializing";
          Status[Status["Initialized"] = 2] = "Initialized";
        })(Status || (Status = {}));
        const DndContext = /*#__PURE__*/reactExports.memo(function DndContext(_ref) {
          var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
          let {
            id,
            accessibility,
            autoScroll = true,
            children,
            sensors = defaultSensors,
            collisionDetection = rectIntersection,
            measuring,
            modifiers,
            ...props
          } = _ref;
          const store = reactExports.useReducer(reducer, undefined, getInitialState);
          const [state, dispatch] = store;
          const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
          const [status, setStatus] = reactExports.useState(Status.Uninitialized);
          const isInitialized = status === Status.Initialized;
          const {
            draggable: {
              active: activeId,
              nodes: draggableNodes,
              translate
            },
            droppable: {
              containers: droppableContainers
            }
          } = state;
          const node = activeId != null ? draggableNodes.get(activeId) : null;
          const activeRects = reactExports.useRef({
            initial: null,
            translated: null
          });
          const active = reactExports.useMemo(() => {
            var _node$data;
            return activeId != null ? {
              id: activeId,
              // It's possible for the active node to unmount while dragging
              data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
              rect: activeRects
            } : null;
          }, [activeId, node]);
          const activeRef = reactExports.useRef(null);
          const [activeSensor, setActiveSensor] = reactExports.useState(null);
          const [activatorEvent, setActivatorEvent] = reactExports.useState(null);
          const latestProps = useLatestValue(props, Object.values(props));
          const draggableDescribedById = useUniqueId("DndDescribedBy", id);
          const enabledDroppableContainers = reactExports.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
          const measuringConfiguration = useMeasuringConfiguration(measuring);
          const {
            droppableRects,
            measureDroppableContainers,
            measuringScheduled
          } = useDroppableMeasuring(enabledDroppableContainers, {
            dragging: isInitialized,
            dependencies: [translate.x, translate.y],
            config: measuringConfiguration.droppable
          });
          const activeNode = useCachedNode(draggableNodes, activeId);
          const activationCoordinates = reactExports.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
          const autoScrollOptions = getAutoScrollerOptions();
          const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
          useLayoutShiftScrollCompensation({
            activeNode: activeId != null ? draggableNodes.get(activeId) : null,
            config: autoScrollOptions.layoutShiftCompensation,
            initialRect: initialActiveNodeRect,
            measure: measuringConfiguration.draggable.measure
          });
          const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
          const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
          const sensorContext = reactExports.useRef({
            activatorEvent: null,
            active: null,
            activeNode,
            collisionRect: null,
            collisions: null,
            droppableRects,
            draggableNodes,
            draggingNode: null,
            draggingNodeRect: null,
            droppableContainers,
            over: null,
            scrollableAncestors: [],
            scrollAdjustedTranslate: null
          });
          const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
          const dragOverlay = useDragOverlayMeasuring({
            measure: measuringConfiguration.dragOverlay.measure
          }); // Use the rect of the drag overlay if it is mounted

          const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
          const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
          const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node
          // is only relevant when there is no drag overlay

          const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node

          const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null); // Get scrollable ancestors of the dragging node

          const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
          const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers

          const modifiedTranslate = applyModifiers(modifiers, {
            transform: {
              x: translate.x - nodeRectDelta.x,
              y: translate.y - nodeRectDelta.y,
              scaleX: 1,
              scaleY: 1
            },
            activatorEvent,
            active,
            activeNodeRect,
            containerNodeRect,
            draggingNodeRect,
            over: sensorContext.current.over,
            overlayNodeRect: dragOverlay.rect,
            scrollableAncestors,
            scrollableAncestorRects,
            windowRect
          });
          const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
          const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated

          const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured

          const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
          const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
          const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
          const collisions = active && collisionRect ? collisionDetection({
            active,
            collisionRect,
            droppableRects,
            droppableContainers: enabledDroppableContainers,
            pointerCoordinates
          }) : null;
          const overId = getFirstCollision(collisions, 'id');
          const [over, setOver] = reactExports.useState(null); // When there is no drag overlay used, we need to account for the
          // window scroll delta

          const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
          const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
          const activeSensorRef = reactExports.useRef(null);
          const instantiateSensor = reactExports.useCallback((event, _ref2) => {
            let {
              sensor: Sensor,
              options
            } = _ref2;
            if (activeRef.current == null) {
              return;
            }
            const activeNode = draggableNodes.get(activeRef.current);
            if (!activeNode) {
              return;
            }
            const activatorEvent = event.nativeEvent;
            const sensorInstance = new Sensor({
              active: activeRef.current,
              activeNode,
              event: activatorEvent,
              options,
              // Sensors need to be instantiated with refs for arguments that change over time
              // otherwise they are frozen in time with the stale arguments
              context: sensorContext,
              onAbort(id) {
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                  return;
                }
                const {
                  onDragAbort
                } = latestProps.current;
                const event = {
                  id
                };
                onDragAbort == null ? void 0 : onDragAbort(event);
                dispatchMonitorEvent({
                  type: 'onDragAbort',
                  event
                });
              },
              onPending(id, constraint, initialCoordinates, offset) {
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                  return;
                }
                const {
                  onDragPending
                } = latestProps.current;
                const event = {
                  id,
                  constraint,
                  initialCoordinates,
                  offset
                };
                onDragPending == null ? void 0 : onDragPending(event);
                dispatchMonitorEvent({
                  type: 'onDragPending',
                  event
                });
              },
              onStart(initialCoordinates) {
                const id = activeRef.current;
                if (id == null) {
                  return;
                }
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                  return;
                }
                const {
                  onDragStart
                } = latestProps.current;
                const event = {
                  activatorEvent,
                  active: {
                    id,
                    data: draggableNode.data,
                    rect: activeRects
                  }
                };
                reactDomExports.unstable_batchedUpdates(() => {
                  onDragStart == null ? void 0 : onDragStart(event);
                  setStatus(Status.Initializing);
                  dispatch({
                    type: Action.DragStart,
                    initialCoordinates,
                    active: id
                  });
                  dispatchMonitorEvent({
                    type: 'onDragStart',
                    event
                  });
                  setActiveSensor(activeSensorRef.current);
                  setActivatorEvent(activatorEvent);
                });
              },
              onMove(coordinates) {
                dispatch({
                  type: Action.DragMove,
                  coordinates
                });
              },
              onEnd: createHandler(Action.DragEnd),
              onCancel: createHandler(Action.DragCancel)
            });
            activeSensorRef.current = sensorInstance;
            function createHandler(type) {
              return async function handler() {
                const {
                  active,
                  collisions,
                  over,
                  scrollAdjustedTranslate
                } = sensorContext.current;
                let event = null;
                if (active && scrollAdjustedTranslate) {
                  const {
                    cancelDrop
                  } = latestProps.current;
                  event = {
                    activatorEvent,
                    active: active,
                    collisions,
                    delta: scrollAdjustedTranslate,
                    over
                  };
                  if (type === Action.DragEnd && typeof cancelDrop === 'function') {
                    const shouldCancel = await Promise.resolve(cancelDrop(event));
                    if (shouldCancel) {
                      type = Action.DragCancel;
                    }
                  }
                }
                activeRef.current = null;
                reactDomExports.unstable_batchedUpdates(() => {
                  dispatch({
                    type
                  });
                  setStatus(Status.Uninitialized);
                  setOver(null);
                  setActiveSensor(null);
                  setActivatorEvent(null);
                  activeSensorRef.current = null;
                  const eventName = type === Action.DragEnd ? 'onDragEnd' : 'onDragCancel';
                  if (event) {
                    const handler = latestProps.current[eventName];
                    handler == null ? void 0 : handler(event);
                    dispatchMonitorEvent({
                      type: eventName,
                      event
                    });
                  }
                });
              };
            }
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [draggableNodes]);
          const bindActivatorToSensorInstantiator = reactExports.useCallback((handler, sensor) => {
            return (event, active) => {
              const nativeEvent = event.nativeEvent;
              const activeDraggableNode = draggableNodes.get(active);
              if (
              // Another sensor is already instantiating
              activeRef.current !== null ||
              // No active draggable
              !activeDraggableNode ||
              // Event has already been captured
              nativeEvent.dndKit || nativeEvent.defaultPrevented) {
                return;
              }
              const activationContext = {
                active: activeDraggableNode
              };
              const shouldActivate = handler(event, sensor.options, activationContext);
              if (shouldActivate === true) {
                nativeEvent.dndKit = {
                  capturedBy: sensor.sensor
                };
                activeRef.current = active;
                instantiateSensor(event, sensor);
              }
            };
          }, [draggableNodes, instantiateSensor]);
          const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
          useSensorSetup(sensors);
          useIsomorphicLayoutEffect(() => {
            if (activeNodeRect && status === Status.Initializing) {
              setStatus(Status.Initialized);
            }
          }, [activeNodeRect, status]);
          reactExports.useEffect(() => {
            const {
              onDragMove
            } = latestProps.current;
            const {
              active,
              activatorEvent,
              collisions,
              over
            } = sensorContext.current;
            if (!active || !activatorEvent) {
              return;
            }
            const event = {
              active,
              activatorEvent,
              collisions,
              delta: {
                x: scrollAdjustedTranslate.x,
                y: scrollAdjustedTranslate.y
              },
              over
            };
            reactDomExports.unstable_batchedUpdates(() => {
              onDragMove == null ? void 0 : onDragMove(event);
              dispatchMonitorEvent({
                type: 'onDragMove',
                event
              });
            });
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
          reactExports.useEffect(() => {
            const {
              active,
              activatorEvent,
              collisions,
              droppableContainers,
              scrollAdjustedTranslate
            } = sensorContext.current;
            if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {
              return;
            }
            const {
              onDragOver
            } = latestProps.current;
            const overContainer = droppableContainers.get(overId);
            const over = overContainer && overContainer.rect.current ? {
              id: overContainer.id,
              rect: overContainer.rect.current,
              data: overContainer.data,
              disabled: overContainer.disabled
            } : null;
            const event = {
              active,
              activatorEvent,
              collisions,
              delta: {
                x: scrollAdjustedTranslate.x,
                y: scrollAdjustedTranslate.y
              },
              over
            };
            reactDomExports.unstable_batchedUpdates(() => {
              setOver(over);
              onDragOver == null ? void 0 : onDragOver(event);
              dispatchMonitorEvent({
                type: 'onDragOver',
                event
              });
            });
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [overId]);
          useIsomorphicLayoutEffect(() => {
            sensorContext.current = {
              activatorEvent,
              active,
              activeNode,
              collisionRect,
              collisions,
              droppableRects,
              draggableNodes,
              draggingNode,
              draggingNodeRect,
              droppableContainers,
              over,
              scrollableAncestors,
              scrollAdjustedTranslate
            };
            activeRects.current = {
              initial: draggingNodeRect,
              translated: collisionRect
            };
          }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
          useAutoScroller({
            ...autoScrollOptions,
            delta: translate,
            draggingRect: collisionRect,
            pointerCoordinates,
            scrollableAncestors,
            scrollableAncestorRects
          });
          const publicContext = reactExports.useMemo(() => {
            const context = {
              active,
              activeNode,
              activeNodeRect,
              activatorEvent,
              collisions,
              containerNodeRect,
              dragOverlay,
              draggableNodes,
              droppableContainers,
              droppableRects,
              over,
              measureDroppableContainers,
              scrollableAncestors,
              scrollableAncestorRects,
              measuringConfiguration,
              measuringScheduled,
              windowRect
            };
            return context;
          }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
          const internalContext = reactExports.useMemo(() => {
            const context = {
              activatorEvent,
              activators,
              active,
              activeNodeRect,
              ariaDescribedById: {
                draggable: draggableDescribedById
              },
              dispatch,
              draggableNodes,
              over,
              measureDroppableContainers
            };
            return context;
          }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
          return React$1.createElement(DndMonitorContext.Provider, {
            value: registerMonitorListener
          }, React$1.createElement(InternalContext.Provider, {
            value: internalContext
          }, React$1.createElement(PublicContext.Provider, {
            value: publicContext
          }, React$1.createElement(ActiveDraggableContext.Provider, {
            value: transform
          }, children)), React$1.createElement(RestoreFocus, {
            disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
          })), React$1.createElement(Accessibility, {
            ...accessibility,
            hiddenTextDescribedById: draggableDescribedById
          }));
          function getAutoScrollerOptions() {
            const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
            const autoScrollGloballyDisabled = typeof autoScroll === 'object' ? autoScroll.enabled === false : autoScroll === false;
            const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
            if (typeof autoScroll === 'object') {
              return {
                ...autoScroll,
                enabled
              };
            }
            return {
              enabled
            };
          }
        });
        const NullContext = /*#__PURE__*/reactExports.createContext(null);
        const defaultRole = 'button';
        const ID_PREFIX$1 = 'Draggable';
        function useDraggable(_ref) {
          let {
            id,
            data,
            disabled = false,
            attributes
          } = _ref;
          const key = useUniqueId(ID_PREFIX$1);
          const {
            activators,
            activatorEvent,
            active,
            activeNodeRect,
            ariaDescribedById,
            draggableNodes,
            over
          } = reactExports.useContext(InternalContext);
          const {
            role = defaultRole,
            roleDescription = 'draggable',
            tabIndex = 0
          } = attributes != null ? attributes : {};
          const isDragging = (active == null ? void 0 : active.id) === id;
          const transform = reactExports.useContext(isDragging ? ActiveDraggableContext : NullContext);
          const [node, setNodeRef] = useNodeRef();
          const [activatorNode, setActivatorNodeRef] = useNodeRef();
          const listeners = useSyntheticListeners(activators, id);
          const dataRef = useLatestValue(data);
          useIsomorphicLayoutEffect(() => {
            draggableNodes.set(id, {
              id,
              key,
              node,
              activatorNode,
              data: dataRef
            });
            return () => {
              const node = draggableNodes.get(id);
              if (node && node.key === key) {
                draggableNodes.delete(id);
              }
            };
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [draggableNodes, id]);
          const memoizedAttributes = reactExports.useMemo(() => ({
            role,
            tabIndex,
            'aria-disabled': disabled,
            'aria-pressed': isDragging && role === defaultRole ? true : undefined,
            'aria-roledescription': roleDescription,
            'aria-describedby': ariaDescribedById.draggable
          }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
          return {
            active,
            activatorEvent,
            activeNodeRect,
            attributes: memoizedAttributes,
            isDragging,
            listeners: disabled ? undefined : listeners,
            node,
            over,
            setNodeRef,
            setActivatorNodeRef,
            transform
          };
        }
        function useDndContext() {
          return reactExports.useContext(PublicContext);
        }
        const ID_PREFIX$1$1 = 'Droppable';
        const defaultResizeObserverConfig = {
          timeout: 25
        };
        function useDroppable(_ref) {
          let {
            data,
            disabled = false,
            id,
            resizeObserverConfig
          } = _ref;
          const key = useUniqueId(ID_PREFIX$1$1);
          const {
            active,
            dispatch,
            over,
            measureDroppableContainers
          } = reactExports.useContext(InternalContext);
          const previous = reactExports.useRef({
            disabled
          });
          const resizeObserverConnected = reactExports.useRef(false);
          const rect = reactExports.useRef(null);
          const callbackId = reactExports.useRef(null);
          const {
            disabled: resizeObserverDisabled,
            updateMeasurementsFor,
            timeout: resizeObserverTimeout
          } = {
            ...defaultResizeObserverConfig,
            ...resizeObserverConfig
          };
          const ids = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
          const handleResize = reactExports.useCallback(() => {
            if (!resizeObserverConnected.current) {
              // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,
              // assuming the element is rendered and displayed.
              resizeObserverConnected.current = true;
              return;
            }
            if (callbackId.current != null) {
              clearTimeout(callbackId.current);
            }
            callbackId.current = setTimeout(() => {
              measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [ids.current]);
              callbackId.current = null;
            }, resizeObserverTimeout);
          },
          //eslint-disable-next-line react-hooks/exhaustive-deps
          [resizeObserverTimeout]);
          const resizeObserver = useResizeObserver({
            callback: handleResize,
            disabled: resizeObserverDisabled || !active
          });
          const handleNodeChange = reactExports.useCallback((newElement, previousElement) => {
            if (!resizeObserver) {
              return;
            }
            if (previousElement) {
              resizeObserver.unobserve(previousElement);
              resizeObserverConnected.current = false;
            }
            if (newElement) {
              resizeObserver.observe(newElement);
            }
          }, [resizeObserver]);
          const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
          const dataRef = useLatestValue(data);
          reactExports.useEffect(() => {
            if (!resizeObserver || !nodeRef.current) {
              return;
            }
            resizeObserver.disconnect();
            resizeObserverConnected.current = false;
            resizeObserver.observe(nodeRef.current);
          }, [nodeRef, resizeObserver]);
          reactExports.useEffect(() => {
            dispatch({
              type: Action.RegisterDroppable,
              element: {
                id,
                key,
                disabled,
                node: nodeRef,
                rect,
                data: dataRef
              }
            });
            return () => dispatch({
              type: Action.UnregisterDroppable,
              key,
              id
            });
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [id]);
          reactExports.useEffect(() => {
            if (disabled !== previous.current.disabled) {
              dispatch({
                type: Action.SetDroppableDisabled,
                id,
                key,
                disabled
              });
              previous.current.disabled = disabled;
            }
          }, [id, key, disabled, dispatch]);
          return {
            active,
            rect,
            isOver: (over == null ? void 0 : over.id) === id,
            node: nodeRef,
            over,
            setNodeRef
          };
        }

        /**
         * Move an array item to a different position. Returns a new array with the item moved to the new position.
         */
        function arrayMove(array, from, to) {
          const newArray = array.slice();
          newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
          return newArray;
        }
        function getSortedRects(items, rects) {
          return items.reduce((accumulator, id, index) => {
            const rect = rects.get(id);
            if (rect) {
              accumulator[index] = rect;
            }
            return accumulator;
          }, Array(items.length));
        }
        function isValidIndex(index) {
          return index !== null && index >= 0;
        }
        function itemsEqual(a, b) {
          if (a === b) {
            return true;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        function normalizeDisabled(disabled) {
          if (typeof disabled === 'boolean') {
            return {
              draggable: disabled,
              droppable: disabled
            };
          }
          return disabled;
        }
        const rectSortingStrategy = _ref => {
          let {
            rects,
            activeIndex,
            overIndex,
            index
          } = _ref;
          const newRects = arrayMove(rects, overIndex, activeIndex);
          const oldRect = rects[index];
          const newRect = newRects[index];
          if (!newRect || !oldRect) {
            return null;
          }
          return {
            x: newRect.left - oldRect.left,
            y: newRect.top - oldRect.top,
            scaleX: newRect.width / oldRect.width,
            scaleY: newRect.height / oldRect.height
          };
        };

        // To-do: We should be calculating scale transformation
        const defaultScale$1 = {
          scaleX: 1,
          scaleY: 1
        };
        const verticalListSortingStrategy = _ref => {
          var _rects$activeIndex;
          let {
            activeIndex,
            activeNodeRect: fallbackActiveRect,
            index,
            rects,
            overIndex
          } = _ref;
          const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
          if (!activeNodeRect) {
            return null;
          }
          if (index === activeIndex) {
            const overIndexRect = rects[overIndex];
            if (!overIndexRect) {
              return null;
            }
            return {
              x: 0,
              y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
              ...defaultScale$1
            };
          }
          const itemGap = getItemGap$1(rects, index, activeIndex);
          if (index > activeIndex && index <= overIndex) {
            return {
              x: 0,
              y: -activeNodeRect.height - itemGap,
              ...defaultScale$1
            };
          }
          if (index < activeIndex && index >= overIndex) {
            return {
              x: 0,
              y: activeNodeRect.height + itemGap,
              ...defaultScale$1
            };
          }
          return {
            x: 0,
            y: 0,
            ...defaultScale$1
          };
        };
        function getItemGap$1(clientRects, index, activeIndex) {
          const currentRect = clientRects[index];
          const previousRect = clientRects[index - 1];
          const nextRect = clientRects[index + 1];
          if (!currentRect) {
            return 0;
          }
          if (activeIndex < index) {
            return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
          }
          return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
        }
        const ID_PREFIX = 'Sortable';
        const Context = /*#__PURE__*/React$1.createContext({
          activeIndex: -1,
          containerId: ID_PREFIX,
          disableTransforms: false,
          items: [],
          overIndex: -1,
          useDragOverlay: false,
          sortedRects: [],
          strategy: rectSortingStrategy,
          disabled: {
            draggable: false,
            droppable: false
          }
        });
        function SortableContext(_ref) {
          let {
            children,
            id,
            items: userDefinedItems,
            strategy = rectSortingStrategy,
            disabled: disabledProp = false
          } = _ref;
          const {
            active,
            dragOverlay,
            droppableRects,
            over,
            measureDroppableContainers
          } = useDndContext();
          const containerId = useUniqueId(ID_PREFIX, id);
          const useDragOverlay = Boolean(dragOverlay.rect !== null);
          const items = reactExports.useMemo(() => userDefinedItems.map(item => typeof item === 'object' && 'id' in item ? item.id : item), [userDefinedItems]);
          const isDragging = active != null;
          const activeIndex = active ? items.indexOf(active.id) : -1;
          const overIndex = over ? items.indexOf(over.id) : -1;
          const previousItemsRef = reactExports.useRef(items);
          const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
          const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
          const disabled = normalizeDisabled(disabledProp);
          useIsomorphicLayoutEffect(() => {
            if (itemsHaveChanged && isDragging) {
              measureDroppableContainers(items);
            }
          }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
          reactExports.useEffect(() => {
            previousItemsRef.current = items;
          }, [items]);
          const contextValue = reactExports.useMemo(() => ({
            activeIndex,
            containerId,
            disabled,
            disableTransforms,
            items,
            overIndex,
            useDragOverlay,
            sortedRects: getSortedRects(items, droppableRects),
            strategy
          }),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);
          return React$1.createElement(Context.Provider, {
            value: contextValue
          }, children);
        }
        const defaultNewIndexGetter = _ref => {
          let {
            id,
            items,
            activeIndex,
            overIndex
          } = _ref;
          return arrayMove(items, activeIndex, overIndex).indexOf(id);
        };
        const defaultAnimateLayoutChanges = _ref2 => {
          let {
            containerId,
            isSorting,
            wasDragging,
            index,
            items,
            newIndex,
            previousItems,
            previousContainerId,
            transition
          } = _ref2;
          if (!transition || !wasDragging) {
            return false;
          }
          if (previousItems !== items && index === newIndex) {
            return false;
          }
          if (isSorting) {
            return true;
          }
          return newIndex !== index && containerId === previousContainerId;
        };
        const defaultTransition = {
          duration: 200,
          easing: 'ease'
        };
        const transitionProperty = 'transform';
        const disabledTransition = /*#__PURE__*/CSS$1.Transition.toString({
          property: transitionProperty,
          duration: 0,
          easing: 'linear'
        });
        const defaultAttributes = {
          roleDescription: 'sortable'
        };

        /*
         * When the index of an item changes while sorting,
         * we need to temporarily disable the transforms
         */

        function useDerivedTransform(_ref) {
          let {
            disabled,
            index,
            node,
            rect
          } = _ref;
          const [derivedTransform, setDerivedtransform] = reactExports.useState(null);
          const previousIndex = reactExports.useRef(index);
          useIsomorphicLayoutEffect(() => {
            if (!disabled && index !== previousIndex.current && node.current) {
              const initial = rect.current;
              if (initial) {
                const current = getClientRect(node.current, {
                  ignoreTransform: true
                });
                const delta = {
                  x: initial.left - current.left,
                  y: initial.top - current.top,
                  scaleX: initial.width / current.width,
                  scaleY: initial.height / current.height
                };
                if (delta.x || delta.y) {
                  setDerivedtransform(delta);
                }
              }
            }
            if (index !== previousIndex.current) {
              previousIndex.current = index;
            }
          }, [disabled, index, node, rect]);
          reactExports.useEffect(() => {
            if (derivedTransform) {
              setDerivedtransform(null);
            }
          }, [derivedTransform]);
          return derivedTransform;
        }
        function useSortable(_ref) {
          let {
            animateLayoutChanges = defaultAnimateLayoutChanges,
            attributes: userDefinedAttributes,
            disabled: localDisabled,
            data: customData,
            getNewIndex = defaultNewIndexGetter,
            id,
            strategy: localStrategy,
            resizeObserverConfig,
            transition = defaultTransition
          } = _ref;
          const {
            items,
            containerId,
            activeIndex,
            disabled: globalDisabled,
            disableTransforms,
            sortedRects,
            overIndex,
            useDragOverlay,
            strategy: globalStrategy
          } = reactExports.useContext(Context);
          const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
          const index = items.indexOf(id);
          const data = reactExports.useMemo(() => ({
            sortable: {
              containerId,
              index,
              items
            },
            ...customData
          }), [containerId, customData, index, items]);
          const itemsAfterCurrentSortable = reactExports.useMemo(() => items.slice(items.indexOf(id)), [items, id]);
          const {
            rect,
            node,
            isOver,
            setNodeRef: setDroppableNodeRef
          } = useDroppable({
            id,
            data,
            disabled: disabled.droppable,
            resizeObserverConfig: {
              updateMeasurementsFor: itemsAfterCurrentSortable,
              ...resizeObserverConfig
            }
          });
          const {
            active,
            activatorEvent,
            activeNodeRect,
            attributes,
            setNodeRef: setDraggableNodeRef,
            listeners,
            isDragging,
            over,
            setActivatorNodeRef,
            transform
          } = useDraggable({
            id,
            data,
            attributes: {
              ...defaultAttributes,
              ...userDefinedAttributes
            },
            disabled: disabled.draggable
          });
          const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
          const isSorting = Boolean(active);
          const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
          const shouldDisplaceDragSource = !useDragOverlay && isDragging;
          const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
          const strategy = localStrategy != null ? localStrategy : globalStrategy;
          const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
            rects: sortedRects,
            activeNodeRect,
            activeIndex,
            overIndex,
            index
          }) : null;
          const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
            id,
            items,
            activeIndex,
            overIndex
          }) : index;
          const activeId = active == null ? void 0 : active.id;
          const previous = reactExports.useRef({
            activeId,
            items,
            newIndex,
            containerId
          });
          const itemsHaveChanged = items !== previous.current.items;
          const shouldAnimateLayoutChanges = animateLayoutChanges({
            active,
            containerId,
            isDragging,
            isSorting,
            id,
            index,
            items,
            newIndex: previous.current.newIndex,
            previousItems: previous.current.items,
            previousContainerId: previous.current.containerId,
            transition,
            wasDragging: previous.current.activeId != null
          });
          const derivedTransform = useDerivedTransform({
            disabled: !shouldAnimateLayoutChanges,
            index,
            node,
            rect
          });
          reactExports.useEffect(() => {
            if (isSorting && previous.current.newIndex !== newIndex) {
              previous.current.newIndex = newIndex;
            }
            if (containerId !== previous.current.containerId) {
              previous.current.containerId = containerId;
            }
            if (items !== previous.current.items) {
              previous.current.items = items;
            }
          }, [isSorting, newIndex, containerId, items]);
          reactExports.useEffect(() => {
            if (activeId === previous.current.activeId) {
              return;
            }
            if (activeId != null && previous.current.activeId == null) {
              previous.current.activeId = activeId;
              return;
            }
            const timeoutId = setTimeout(() => {
              previous.current.activeId = activeId;
            }, 50);
            return () => clearTimeout(timeoutId);
          }, [activeId]);
          return {
            active,
            activeIndex,
            attributes,
            data,
            rect,
            index,
            newIndex,
            items,
            isOver,
            isSorting,
            isDragging,
            listeners,
            node,
            overIndex,
            over,
            setNodeRef,
            setActivatorNodeRef,
            setDroppableNodeRef,
            setDraggableNodeRef,
            transform: derivedTransform != null ? derivedTransform : finalTransform,
            transition: getTransition()
          };
          function getTransition() {
            if (
            // Temporarily disable transitions for a single frame to set up derived transforms
            derivedTransform ||
            // Or to prevent items jumping to back to their "new" position when items change
            itemsHaveChanged && previous.current.newIndex === index) {
              return disabledTransition;
            }
            if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
              return undefined;
            }
            if (isSorting || shouldAnimateLayoutChanges) {
              return CSS$1.Transition.toString({
                ...transition,
                property: transitionProperty
              });
            }
            return undefined;
          }
        }
        function normalizeLocalDisabled(localDisabled, globalDisabled) {
          var _localDisabled$dragga, _localDisabled$droppa;
          if (typeof localDisabled === 'boolean') {
            return {
              draggable: localDisabled,
              // Backwards compatibility
              droppable: false
            };
          }
          return {
            draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
            droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
          };
        }
        [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
        function DndSortableProvider({
          items,
          onReorder,
          onInsert,
          children
        }) {
          const sensors = useSensors(useSensor(PointerSensor));
          const handleDragEnd = event => {
            const {
              active,
              over
            } = event;
            if (!over) {
              return;
            }
            const isFromPalette = active.data.current?.from === "palette";
            if (isFromPalette && onInsert) {
              const insertIndex = items.indexOf(over.id);
              onInsert(active.id, insertIndex >= 0 ? insertIndex : items.length);
            } else if (active.id !== over.id) {
              const oldIndex = items.indexOf(active.id);
              const newIndex = items.indexOf(over.id);
              onReorder(arrayMove(items, oldIndex, newIndex));
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(DndContext, {
            sensors,
            onDragEnd: handleDragEnd,
            children: /* @__PURE__ */jsxRuntimeExports.jsx(SortableContext, {
              items,
              strategy: verticalListSortingStrategy,
              children
            })
          });
        }
        const isInputField = field => {
          return field.type === "text" || field.type === "email" || field.type === "tel" || field.type === "textarea";
        };
        function EditInput() {
          const {
            formBuilderFields,
            updateFormBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          if (!currentField || !isInputField(currentField)) {
            return null;
          }
          const [draftLabelValue, setDraftLabelValue] = reactExports.useState(currentField.label);
          const [draftPlaceholderValue, setDraftPlaceholderValue] = reactExports.useState(currentField.placeholder);
          const onLabelEditComplete = () => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              label: draftLabelValue
            });
          };
          const onPlaceholderEditComplete = () => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              placeholder: draftPlaceholderValue
            });
          };
          const onRequiredEditComplete = value => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              required: Boolean(value)
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                label: "Field label",
                value: draftLabelValue,
                onChange: setDraftLabelValue,
                onBlur: onLabelEditComplete
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                label: "Placeholder",
                value: draftPlaceholderValue,
                onChange: setDraftPlaceholderValue,
                onBlur: onPlaceholderEditComplete
              })
            }), currentField?.type !== "email" && /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxControl, {
                label: "Required",
                checked: currentField.required,
                onChange: onRequiredEditComplete
              })
            })]
          });
        }
        function EditDropdown() {
          const {
            formBuilderFields,
            updateFormBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          if (!currentField) {
            return null;
          }
          const [draftLabelValue, setDraftLabelValue] = reactExports.useState(currentField.label);
          const onLabelEditComplete = () => {
            updateFormBuilderFields(builderEditScreen, {
              ...formBuilderFields[builderEditScreen],
              label: draftLabelValue
            });
          };
          const onRequiredEditComplete = value => {
            updateFormBuilderFields(builderEditScreen, {
              ...formBuilderFields[builderEditScreen],
              required: Boolean(value)
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                label: "Field label",
                value: draftLabelValue,
                onChange: setDraftLabelValue,
                onBlur: onLabelEditComplete
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxControl, {
                label: "Required",
                checked: currentField.required,
                onChange: onRequiredEditComplete
              })
            })]
          });
        }
        function isCheckboxField(field) {
          return field.type === "checkbox";
        }
        function EditCheckbox() {
          const {
            formBuilderFields,
            updateFormBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          if (!currentField || !isCheckboxField(currentField)) {
            return null;
          }
          const [draftLabelValue, setDraftLabelValue] = reactExports.useState(currentField.label);
          const onLabelEditComplete = () => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              label: draftLabelValue
            });
          };
          const onRequiredEditComplete = value => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              required: Boolean(value)
            });
          };
          const onDefaultValueComplete = value => {
            updateFormBuilderFields(builderEditScreen, {
              ...currentField,
              defaultValue: Boolean(value)
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                label: "Field label",
                value: draftLabelValue,
                onChange: setDraftLabelValue,
                onBlur: onLabelEditComplete
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxControl, {
                label: "Default value",
                checked: currentField.defaultValue,
                onChange: onDefaultValueComplete
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(CheckboxControl, {
                label: "Required",
                checked: currentField.required,
                onChange: onRequiredEditComplete
              })
            })]
          });
        }
        const isWysiwygField = field => {
          return field.type === "wysiwyg";
        };
        function EditContent() {
          const {
            formBuilderFields,
            updateFormBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          if (!currentField || !isWysiwygField(currentField)) {
            return null;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(PTRichText, {
              label: "Content",
              id: `petitioner_content_wisiwyg_${builderEditScreen}`,
              value: currentField?.value,
              onChange: value => {
                updateFormBuilderFields(builderEditScreen, {
                  ...currentField,
                  value: purify.sanitize(value)
                });
              },
              height: 200
            })
          });
        }
        const isSubmitField = field => {
          return field.type === "submit";
        };
        function EditSubmit() {
          const {
            formBuilderFields,
            updateFormBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          if (!currentField || !isSubmitField(currentField)) {
            return null;
          }
          const [draftLabelValue, setDraftLabelValue] = reactExports.useState(currentField.label);
          const onLabelEditComplete = () => {
            updateFormBuilderFields(builderEditScreen, {
              ...formBuilderFields[builderEditScreen],
              label: draftLabelValue
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            children: /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                label: "Button text",
                value: draftLabelValue,
                onChange: setDraftLabelValue,
                onBlur: onLabelEditComplete
              })
            })
          });
        }
        const DragHandle = dt.div.attrs(() => ({
          className: "ptr-drag-handle"
        }))`
	cursor: grab;
	padding: 4px;
	font-size: 18px;
	user-select: none;

	&:before {
		content: '⋮⋮';
		font-weight: bold;
		font-size: 18px;
		// content: '≡';
	}
`;
        const FieldPaletteWrapper = dt.div`
	display: flex;
	flex-direction: column;
	gap: 8px;
`;
        const FieldPaletteItem = dt.div`
	padding: 4px 8px;
	border-radius: 4px;
	background: rgba(00, 00, 00, 0.01);
	border: 1px solid rgba(00, 00, 00, 0.1);
	cursor: grab;
	display: flex;
	align-items: center;
	gap: 4px;
`;
        const D_PREFIX = "ptr_insert_";
        const getIDNoPrefix = id => id.replace(D_PREFIX, "");
        function PaletteDraggable({
          id,
          label
        }) {
          const {
            fieldOrder
          } = useFormBuilderContext();
          const {
            attributes,
            listeners,
            setNodeRef,
            transform,
            isDragging
          } = useDraggable({
            id,
            data: {
              from: "palette",
              type: id
            }
          });
          const alreadyExists = fieldOrder.includes(getIDNoPrefix(id));
          const style = {
            transform: CSS$1.Translate.toString(transform),
            opacity: isDragging ? 0.5 : 1,
            zIndex: isDragging ? 1e3 : "auto",
            cursor: isDragging ? "grabbing" : "grab"
          };
          const finalAttributes = !alreadyExists ? {
            ...listeners,
            ...attributes,
            ref: setNodeRef,
            style
          } : {
            style: {
              opacity: 0.5,
              cursor: "not-allowed"
            }
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FieldPaletteItem, {
            ...finalAttributes,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(DragHandle, {}), label]
          });
        }
        function FieldList() {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(FieldPaletteWrapper, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("h3", {
              children: __("Available fields", "petitioner")
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: __("Below is a list of additional fields you can add to your form.", "petitioner")
            }), DRAGGABLE_FIELD_TYPES.map(field => /* @__PURE__ */jsxRuntimeExports.jsx(PaletteDraggable, {
              id: D_PREFIX + field.fieldKey,
              label: field.fieldName
            }, field.fieldKey))]
          });
        }
        const screenKeys = ["email", "tel", "text", "select", "checkbox", "wysiwyg", "submit", "textarea"];
        const BuilderSettingsWrapper = dt.div`
	padding: var(--ptr-admin-spacing-md);
	border-radius: 8px;
	border: 1px solid rgba(00, 00, 00, 0.1);
	background-color: var(--ptr-admin-color-light);
	position: relative;

	h3,
	p {
		margin-top: 0;
		margin-bottom: var(--ptr-admin-spacing-md);
	}

	button {
		margin-bottom: var(--ptr-admin-spacing-md);
	}
`;
        function BuilderSettings() {
          const {
            formBuilderFields,
            builderEditScreen,
            setBuilderEditScreen
          } = useFormBuilderContext();
          const currentField = formBuilderFields[builderEditScreen];
          const currentType = currentField?.type;
          const screens = {
            email: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditInput, {}),
            tel: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditInput, {}),
            text: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditInput, {}),
            textarea: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditInput, {}),
            select: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditDropdown, {}),
            checkbox: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditCheckbox, {}),
            wysiwyg: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditContent, {}),
            submit: () => /* @__PURE__ */jsxRuntimeExports.jsx(EditSubmit, {}),
            default: () => /* @__PURE__ */jsxRuntimeExports.jsx(FieldList, {})
          };
          const ScreenComponent = screenKeys.includes(currentType) ? screens[currentType] : screens.default;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(BuilderSettingsWrapper, {
            "data-testid": "ptr-builder-settings",
            children: [builderEditScreen != "default" && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                variant: "secondary",
                size: "small",
                icon: "arrow-left-alt2",
                onClick: e => {
                  e.preventDefault();
                  setBuilderEditScreen("default");
                },
                children: __("Back", "petitioner")
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("h3", {
                "data-testid": "ptr-builder-settings-title",
                children: [__("Editing: ", "petitioner"), currentField?.fieldName]
              }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: __("Edit the properties of this field below.", "petitioner")
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(ScreenComponent, {})]
          });
        }
        const FakeFieldLabel = dt.p`
	min-height: 18px;
	font-size: 14px;
	color: rgba(var(--ptr-admin-color-dark), 0.6);
	background: #fff;
	margin-bottom: 0;
`;
        const FakeField = dt.div`
	border: 1px solid var(--ptr-admin-color-grey, #ccc);
	width: 100%;
	min-height: 37px;
	padding: var(--ptr-admin-spacing-sm, 4px);
	border-radius: var(--ptr-admin-input-border-radius, 4px);
	box-sizing: border-box;
	font-size: var(--ptr-admin-fs-sm);
	color: rgba(var(--ptr-admin-color-dark, #000), 0.6);
	pointer-events: none;
`;
        const StyledTextarea = dt(FakeField)`
	min-height: 100px;
`;
        function DynamicField({
          name = "",
          inputType = "text",
          label = "Field Label",
          value = "",
          defaultValue = false,
          placeholder = "",
          required = false,
          fieldName = "",
          removable = false
        }) {
          const {
            setBuilderEditScreen,
            builderEditScreen,
            formBuilderFields,
            removeFormBuilderField
          } = useFormBuilderContext();
          const handleFieldEdit = event => {
            event.preventDefault();
            setBuilderEditScreen(name);
          };
          const isActive = builderEditScreen === name;
          const fieldClassName = `ptr-fake-field ptr-fake-field--${inputType} ${!isActive ? "" : "ptr-fake-field--active"}`;
          const FieldActions = () => {
            const currentField = formBuilderFields[name];
            if (!currentField) {
              return null;
            }
            const handleFieldRemoval = event => {
              event.preventDefault();
              if (window.confirm(`Are you sure you want to remove the ${fieldName} field?`)) {
                removeFormBuilderField(name);
                setBuilderEditScreen("default");
              }
            };
            return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-actions",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                showTooltip: true,
                icon: "edit",
                variant: "secondary",
                onClick: handleFieldEdit,
                size: "small",
                label: `Edit the ${fieldName} field`
              }), removable && /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                showTooltip: true,
                icon: "trash",
                isDestructive: true,
                variant: "secondary",
                size: "small",
                label: `Remove the ${fieldName} field`,
                onClick: handleFieldRemoval
              })]
            });
          };
          let FinalField = /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FakeFieldLabel, {
              children: label
            }), /* @__PURE__ */jsxRuntimeExports.jsx(FakeField, {
              children: placeholder
            })]
          });
          if (inputType === "checkbox") {
            FinalField = /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "checkbox",
                id: name,
                name,
                checked: defaultValue === true
              }), /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                htmlFor: name,
                dangerouslySetInnerHTML: {
                  __html: sanitizeField(label)
                }
              })]
            });
          } else if (inputType === "submit") {
            FinalField = /* @__PURE__ */jsxRuntimeExports.jsx("button", {
              dangerouslySetInnerHTML: {
                __html: sanitizeField(label)
              }
            });
          } else if (inputType === "textarea") {
            FinalField = /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(FakeFieldLabel, {
                dangerouslySetInnerHTML: {
                  __html: sanitizeField(label)
                }
              }), /* @__PURE__ */jsxRuntimeExports.jsx(StyledTextarea, {
                children: placeholder
              })]
            });
          } else if (inputType === "wysiwyg") {
            FinalField = /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              dangerouslySetInnerHTML: {
                __html: sanitizeField(value)
              }
            });
          }
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            onClick: e => {
              if (e.target.closest(".ptr-actions")) return;
              handleFieldEdit(e);
            },
            className: fieldClassName,
            "data-testid": `ptr-fake-field-${name}`,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(FieldActions, {}), FinalField]
          });
        }
        const Wrapper = dt.div`
	padding-left: 24px;
	position: relative;
	border-radius: 4px;
	border: 1px solid transparent;

	&.ptr-active,
	&.ptr-active:hover {
		border: 1px solid var(--ptr-admin-color-dark);
	}

	.ptr-drag-handle {
		position: absolute;
		left: 4px;
		top: 50%;
		transform: translateY(-50%);
		opacity: 0;
	}

	&:hover {
		border: 1px dashed rgba(00, 00, 00, 0.3);
	}

	&:hover,
	&.ptr-active {
		.ptr-drag-handle {
			opacity: 1;
		}
	}
`;
        function SortableField({
          id
        }) {
          const {
            formBuilderFields,
            builderEditScreen
          } = useFormBuilderContext();
          const {
            attributes,
            listeners,
            setNodeRef,
            transform,
            isDragging
          } = useSortable({
            id,
            animateLayoutChanges: defaultAnimateLayoutChanges
          });
          const currentField = formBuilderFields[id];
          const ptrProps = {
            name: id,
            inputType: currentField.type,
            label: currentField.label,
            fieldName: currentField.fieldName,
            placeholder: "placeholder" in currentField ? currentField.placeholder : void 0,
            value: "value" in currentField ? currentField.value : void 0,
            required: currentField.required,
            removable: currentField.removable,
            defaultValue: "defaultValue" in currentField ? currentField.defaultValue : void 0
          };
          const adjustedTransform = transform ? {
            x: transform.x,
            y: transform.y,
            scaleX: 1,
            scaleY: 1
          } : null;
          const style = {
            transform: CSS$1.Transform.toString(adjustedTransform),
            transition: "0s",
            opacity: isDragging ? 0.5 : 1,
            zIndex: isDragging ? 1e3 : "auto"
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(Wrapper, {
            className: builderEditScreen === id ? "ptr-active" : "",
            ref: setNodeRef,
            style,
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(DragHandle, {
              ...attributes,
              ...listeners
            }), /* @__PURE__ */jsxRuntimeExports.jsx(DynamicField, {
              ...ptrProps
            })]
          });
        }
        const StyledPanel = dt(Panel)`
	margin-top: var(--ptr-admin-spacing-md, 16px);

	.components-panel__body {
		padding: 0px;
	}

	.ptr-form-builder__form {
		margin-left: var(--ptr-admin-spacing-md);
	}
`;
        function FormBuilderComponent() {
          const {
            fieldOrder,
            setFieldOrder,
            formBuilderFields,
            addFormBuilderField
          } = useFormBuilderContext();
          const handleFieldInsert = (rawID, position) => {
            const id = getIDNoPrefix(rawID);
            const newField = DRAGGABLE_FIELD_TYPES.find(field => field.fieldKey === id);
            const newFieldID = newField?.fieldKey;
            if (!newField || typeof newFieldID !== "string") {
              console.error("Field type not found:", id);
              return;
            }
            addFormBuilderField(newFieldID, newField);
            setFieldOrder(prev => {
              const updated = [...prev];
              updated.splice(position, 0, newFieldID);
              return updated;
            });
          };
          const handleReorder = newOrder => {
            setFieldOrder([...newOrder]);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsx(DndSortableProvider, {
            items: fieldOrder,
            onReorder: handleReorder,
            onInsert: handleFieldInsert,
            children: /* @__PURE__ */jsxRuntimeExports.jsxs(StyledPanel, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: "ptr-form-builder__form-header",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("h3", {
                  children: __("Form builder", "petitioner")
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: __("Drag and drop fields to build your form. Click on each field to edit it's properties", "petitioner")
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(PanelBody, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  type: "hidden",
                  name: "petitioner_form_fields",
                  value: JSON.stringify(formBuilderFields)
                }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                  type: "hidden",
                  name: "petitioner_field_order",
                  value: JSON.stringify(fieldOrder)
                }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                  className: "ptr-form-builder",
                  style: {
                    display: "flex",
                    flexDirection: "row",
                    padding: "24px 16px"
                  },
                  children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: "ptr-form-builder__settings",
                    style: {
                      width: "30%"
                    },
                    children: /* @__PURE__ */jsxRuntimeExports.jsx(BuilderSettings, {})
                  }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                    className: "ptr-form-builder__form",
                    style: {
                      width: "70%"
                    },
                    children: fieldOrder.map(fieldKey => {
                      return /* @__PURE__ */jsxRuntimeExports.jsx(SortableField, {
                        id: fieldKey
                      }, fieldKey);
                    })
                  })]
                })]
              })]
            })
          });
        }
        function FormBuilder() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(FormBuilderContextProvider, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(FormBuilderComponent, {})
          });
        }
        function PetitionDetails() {
          const {
            formState,
            updateFormState
          } = useEditFormContext();
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                style: {
                  width: "100%"
                },
                required: true,
                label: "Petition title *",
                value: formState.title,
                name: "petitioner_title",
                id: "petitioner_title",
                onChange: value => updateFormState("title", value)
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                style: {
                  width: "100%"
                },
                required: true,
                type: "number",
                label: "Signature goal *",
                value: Number(formState.goal),
                name: "petitioner_goal",
                id: "petitioner_goal",
                help: "Select your target submission number. You can disable this in the general settings",
                onChange: value => updateFormState("goal", Number(value))
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                checked: formState.send_to_representative,
                type: "checkbox",
                name: "petitioner_send_to_representative",
                id: "petitioner_send_to_representative",
                className: "widefat",
                onChange: e => updateFormState("send_to_representative", e.target.checked)
              }), /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                htmlFor: "petitioner_send_to_representative",
                children: "Send this email to a representative?"
              })]
            }), formState.send_to_representative && /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                  style: {
                    width: "100%"
                  },
                  required: true,
                  type: "text",
                  label: "Petition target email *",
                  value: formState.email,
                  help: "(can have multiple, separated by commas)",
                  name: "petitioner_email",
                  id: "petitioner_email",
                  onChange: value => updateFormState("email", value)
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                  style: {
                    width: "100%"
                  },
                  type: "text",
                  label: "Petition CC emails",
                  value: formState.cc_emails,
                  help: "(can have multiple, separated by commas)",
                  name: "petitioner_cc_emails",
                  id: "petitioner_cc_emails",
                  onChange: value => updateFormState("cc_emails", value)
                })
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h3", {
              children: "Letter details"
            }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
              children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                style: {
                  width: "100%"
                },
                type: "text",
                required: true,
                label: "Petition subject *",
                value: formState.subject,
                name: "petitioner_subject",
                id: "petitioner_subject",
                onChange: value => updateFormState("subject", value)
              })
            }), /* @__PURE__ */jsxRuntimeExports.jsx(PTRichText, {
              label: "Petition letter",
              id: "petitioner_letter",
              help: "This will be the main content of the email sent to the representative.",
              value: String(formState.letter),
              onChange: value => updateFormState("letter", value)
            })]
          });
        }
        function BottomCallout() {
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsxs("section", {
              className: "petitioner-callout-box",
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs("h2", {
                children: ["Thanks for using", " ", /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                  className: "text-ptr-red",
                  children: "Petitioner!"
                })]
              }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: "Hi! I’m Anton, the creator of this plugin. I truly appreciate you giving it a try and hope it makes your work easier. If you're enjoying it, I’d be super grateful if you left a review!"
              }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: "Have questions or ideas for new features? Check out the documentation or feel free to reach out directly—I’d love to hear from you."
              }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                children: "Cheers!"
              }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                className: "ptr-action-buttons",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  icon: "star-empty",
                  href: "https://wordpress.org/support/plugin/petitioner/reviews/#new-post",
                  variant: "primary",
                  children: "Leave a review"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  icon: "book-alt",
                  href: "https://getpetitioner.com/docs/",
                  variant: "tertiary",
                  children: "Documentation"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  icon: "email",
                  href: "https://getpetitioner.com/contact/",
                  variant: "tertiary",
                  children: "Get in touch"
                })]
              })]
            })]
          });
        }
        function Tabs(props) {
          const {
            tabs,
            onTabSelect = () => {},
            defaultTab = "",
            updateURL = false
          } = props;
          const tabKeys = tabs.map(tab => tab.name);
          const [activeTab, setActiveTab] = reactExports.useState(() => {
            return tabKeys.indexOf(defaultTab) !== -1 ? defaultTab : "";
          });
          const handleTabSelect = reactExports.useCallback(tabName => {
            setActiveTab(tabName);
            onTabSelect(tabName, tabKeys);
            if (updateURL) {
              updateActiveTabURL(tabName, tabKeys);
            }
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(TabPanel, {
              onSelect: handleTabSelect,
              tabs,
              initialTabName: activeTab,
              children: tab => /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
            }), /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: `petitioner-tab-content`,
              children: tabs.map(el => {
                return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                  "data-testid": `ptr-tab-${el.name}`,
                  className: `petitioner-tab petitioner-tab ${activeTab === el.name ? "active" : ""}`,
                  children: el.renderingEl
                }, el.name);
              })
            })]
          });
        }
        const tabs$1 = [{
          name: "petition-details",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "email-alt"
            }), " Petition details"]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(PetitionDetails, {})
        }, {
          name: "form-builder",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "welcome-widgets-menus"
            }), " Form builder"]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(FormBuilder, {})
        }, {
          name: "advanced-settings",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "admin-settings"
            }), " Advanced settings"]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(AdvancedSettings, {})
        }, {
          name: "submissions",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "editor-ul"
            }), " Submissions"]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(Submissions, {})
        }];
        function EditFieldsComponent() {
          const {
            formState
          } = useEditFormContext();
          const {
            active_tab
          } = formState;
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Tabs, {
              tabs: tabs$1,
              defaultTab: active_tab,
              updateURL: true
            }), /* @__PURE__ */jsxRuntimeExports.jsx(BottomCallout, {})]
          });
        }
        function EditFields() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(EditFormContextProvider, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(EditFieldsComponent, {})
          });
        }
        function CodeEditor({
          title = "",
          help = "",
          code = ""
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("h3", {
                children: title
              }), /* @__PURE__ */jsxRuntimeExports.jsx("span", {
                children: help
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("textarea", {
              name: "petitioner_custom_css",
              id: "petitionerCode",
              rows: 10,
              cols: 50,
              className: "large-text code petitioner-code-editor",
              children: code
            })]
          });
        }
        const PtrColorPicker = dt.div`
	position: relative;
	display: inline-block;
`;
        const ColorPickerButton = dt(Button)`
	--wp-components-color-accent: #333;
	--wp-components-color-accent-hover: #333;
	display: flex;
	gap: 8px;
`;
        const Palette = dt.div.attrs({
          className: "ptr-color-picker__palette"
        })`
	padding: 4px;
	border-radius: 4px;
	background: white;
	position: absolute;
	display: ${({
          $isOpen
        }) => $isOpen ? "block" : "none"};
	top: 0;
	right: 0;
	z-index: 9;
	transform: translate(calc(100% + 36px), calc(-100% + 36px))
		${({
          $topValue
        }) => $topValue ? `translateY(${$topValue})` : ""};
`;
        function ColorField({
          color = "#fff",
          onColorChange = color2 => {},
          defaultColor = "#fff",
          label = "Select Color",
          id = "petitioner_color"
        }) {
          const [isPickerOpen, setIsPickerOpen] = reactExports.useState(false);
          const [pickerTopValue, setPickerTopValue] = reactExports.useState("0");
          const buttonRef = reactExports.useRef(null);
          const PickerOverlay = () => {
            if (!isPickerOpen) {
              return null;
            }
            const handleOverlayClick = e => {
              e.stopPropagation();
              if (e.target instanceof Element && e.target.closest(".ptr-color-picker__palette")) {
                return;
              }
              setIsPickerOpen(false);
            };
            return reactDomExports.createPortal(/* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: "ptr-color-picker__overlay",
              onClick: handleOverlayClick
            }), document.body);
          };
          reactExports.useEffect(() => {
            const handleEscapeKey = e => {
              if (isPickerOpen && e.key === "Escape") {
                e.preventDefault();
                setIsPickerOpen(false);
                setPickerTopValue("0");
              }
            };
            document.addEventListener("keydown", handleEscapeKey);
            return () => {
              document.removeEventListener("keydown", handleEscapeKey);
            };
          }, [isPickerOpen]);
          const updateTopValue = () => {
            const button = buttonRef.current;
            if (!button) return;
            const buttonRect = button.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const margin = 16;
            const paletteHeight = 396;
            const wouldBeTop = buttonRect.top - paletteHeight;
            const wouldBeBottom = wouldBeTop + paletteHeight;
            let adjustmentTop = 0;
            if (wouldBeTop < margin) {
              adjustmentTop = margin - wouldBeTop;
            } else if (wouldBeBottom > viewportHeight - margin) {
              const overlap = wouldBeBottom - (viewportHeight - margin);
              adjustmentTop = -overlap;
            }
            setPickerTopValue(adjustmentTop !== 0 ? `${adjustmentTop}px` : "0");
          };
          const handlePickerOpen = () => {
            setIsPickerOpen(prevState => {
              const newState = !prevState;
              if (newState) {
                updateTopValue();
              }
              return newState;
            });
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(PtrColorPicker, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsxs(ColorPickerButton, {
                ref: buttonRef,
                onClick: handlePickerOpen,
                variant: "secondary",
                className: "color-picker__button",
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ColorIndicator, {
                  colorValue: color || defaultColor
                }), label]
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Palette, {
                $topValue: pickerTopValue,
                $isOpen: isPickerOpen,
                children: /* @__PURE__ */jsxRuntimeExports.jsx(LegacyAdapter, {
                  color: color || defaultColor,
                  onChange: newColor => {
                    onColorChange(newColor);
                  },
                  enableAlpha: true,
                  defaultValue: defaultColor
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                "data-testid": "hidden_color_input",
                type: "hidden",
                name: id,
                value: color || defaultColor
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(PickerOverlay, {})]
          });
        }
        const SettingsFormContext = reactExports.createContext(null);
        const normalizeSettingsData = raw => ({
          show_letter: raw?.show_letter ?? true,
          show_title: raw?.show_title ?? true,
          show_goal: raw?.show_goal ?? true,
          custom_css: raw?.custom_css ?? "",
          primary_color: raw?.primary_color ?? "",
          dark_color: raw?.dark_color ?? "",
          grey_color: raw?.grey_color ?? "",
          enable_recaptcha: raw?.enable_recaptcha ?? false,
          recaptcha_site_key: raw?.recaptcha_site_key ?? "",
          recaptcha_secret_key: raw?.recaptcha_secret_key ?? "",
          enable_hcaptcha: raw?.enable_hcaptcha ?? false,
          hcaptcha_site_key: raw?.hcaptcha_site_key ?? "",
          hcaptcha_secret_key: raw?.hcaptcha_secret_key ?? "",
          enable_turnstile: raw?.enable_turnstile ?? false,
          turnstile_site_key: raw?.turnstile_site_key ?? "",
          turnstile_secret_key: raw?.turnstile_secret_key ?? "",
          enable_akismet: raw?.enable_akismet ?? true,
          label_overrides: raw?.label_overrides ?? {},
          default_values: raw?.default_values ?? {
            colors: {
              primary: "",
              dark: "",
              grey: ""
            },
            labels: {}
          },
          active_tab: raw?.active_tab ?? ""
        });
        const SettingsFormContextProvider = ({
          children
        }) => {
          const windowPetitionerData = normalizeSettingsData(window.petitionerData);
          const [formState, setFormState] = reactExports.useState(windowPetitionerData);
          const updateFormState = reactExports.useCallback((key, value) => {
            setFormState(prevState => ({
              ...prevState,
              [key]: value
            }));
          }, []);
          return /* @__PURE__ */jsxRuntimeExports.jsx(SettingsFormContext.Provider, {
            value: {
              formState,
              updateFormState,
              windowPetitionerData
            },
            children
          });
        };
        function useSettingsFormContext() {
          const context = reactExports.useContext(SettingsFormContext);
          if (!context) {
            throw new Error("useSettingsFormContext must be used within an FormBuilderContextProvider");
          }
          return context;
        }
        function VisualSettings() {
          const {
            formState,
            updateFormState,
            windowPetitionerData
          } = useSettingsFormContext();
          const defaultColors = windowPetitionerData.default_values.colors || {
            primary: "#000",
            dark: "#000",
            grey: "#000"
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                checked: formState.show_letter,
                type: "checkbox",
                name: "petitioner_show_letter",
                id: "petitioner_show_letter",
                className: "widefat",
                onChange: e => {
                  updateFormState("show_letter", e.target.checked);
                }
              }), /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                htmlFor: "petitioner_show_letter",
                children: "Show letter on the frontend?"
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                checked: formState.show_title,
                type: "checkbox",
                name: "petitioner_show_title",
                id: "petitioner_show_title",
                className: "widefat",
                onChange: e => {
                  updateFormState("show_title", e.target.checked);
                }
              }), /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                htmlFor: "petitioner_show_title",
                children: "Show petition title?"
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("p", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                checked: formState.show_goal,
                type: "checkbox",
                name: "petitioner_show_goal",
                id: "petitioner_show_goal",
                className: "widefat",
                onChange: e => {
                  updateFormState("show_goal", e.target.checked);
                }
              }), /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                htmlFor: "petitioner_show_goal",
                children: "Show petition goal?"
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx("hr", {}), /* @__PURE__ */jsxRuntimeExports.jsx("h3", {
              style: {
                marginBottom: "0"
              },
              children: "Colors"
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-field-panel",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                  children: "Primary color"
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorField, {
                id: "petitioner_primary_color",
                color: formState?.primary_color,
                defaultColor: defaultColors?.primary,
                onColorChange: newColor => updateFormState("primary_color", newColor)
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-field-panel",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                  children: "Dark color"
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorField, {
                id: "petitioner_dark_color",
                color: formState?.dark_color,
                defaultColor: defaultColors?.dark,
                onColorChange: newColor => updateFormState("dark_color", newColor)
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-field-panel",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx("label", {
                  children: "Grey color"
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(ColorField, {
                id: "petitioner_grey_color",
                color: formState?.grey_color,
                defaultColor: defaultColors?.grey,
                onColorChange: newColor => updateFormState("grey_color", newColor)
              })]
            }), /* @__PURE__ */jsxRuntimeExports.jsx(CodeEditor, {
              code: formState?.custom_css || "",
              title: "Custom CSS",
              help: "Add your custom CSS here."
            })]
          });
        }
        function IntegrationBox({
          title = "reCAPTCHA",
          description = "Google reCAPTCHA integration",
          enabled = false,
          integrationFields = null
        }) {
          const [isOpen, setOpen] = reactExports.useState(false);
          const openModal = () => setOpen(true);
          const closeModal = () => setOpen(false);
          return /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsxs(Card, {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(CardHeader, {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Heading, {
                  level: 4,
                  children: title
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsx(CardBody, {
                style: {
                  "min-height": "80px"
                },
                children: /* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  children: description
                })
              }), /* @__PURE__ */jsxRuntimeExports.jsxs(CardFooter, {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                  as: "p",
                  weight: "bold",
                  size: "subheadline",
                  color: enabled ? "green" : "neutral",
                  children: enabled ? "Active" : "Inactive"
                }), /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                  onClick: openModal,
                  variant: "primary",
                  children: "Configure"
                })]
              })]
            }), isOpen && /* @__PURE__ */jsxRuntimeExports.jsxs(Modal, {
              size: "large",
              title,
              onRequestClose: closeModal,
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(Text, {
                children: description
              }), /* @__PURE__ */jsxRuntimeExports.jsx(Divider, {
                margin: 5
              }), integrationFields, /* @__PURE__ */jsxRuntimeExports.jsx(Button, {
                style: {
                  marginTop: 16
                },
                variant: "secondary",
                onClick: closeModal,
                "data-testid": "petitioner_modal_close",
                children: "Close"
              })]
            })]
          });
        }
        function Integrations() {
          const {
            formState,
            updateFormState
          } = useSettingsFormContext();
          const integrations = [{
            name: "recaptcha",
            title: __("Google reCAPTCHA v3", "petitioner"),
            description: __("Google reCAPTCHA integration. Use this to protect your forms from spam.", "petitioner"),
            enabled: formState.enable_recaptcha,
            integrationFields: /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ToggleControl, {
                  label: "Enable reCAPTCHA v3",
                  checked: formState.enable_recaptcha,
                  onChange: checked => updateFormState("enable_recaptcha", checked)
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Site Key",
                    value: formState.recaptcha_site_key,
                    onChange: value => updateFormState("recaptcha_site_key", value),
                    placeholder: "Enter your reCAPTCHA site key"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Secret Key",
                    value: formState.recaptcha_secret_key,
                    onChange: value => updateFormState("recaptcha_secret_key", value),
                    placeholder: "Enter your reCAPTCHA secret key"
                  })
                })]
              })
            }),
            hiddenFields: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-hidden-fields",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "checkbox",
                name: "petitioner_enable_recaptcha",
                checked: formState.enable_recaptcha
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_recaptcha_site_key",
                value: formState.recaptcha_site_key
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_recaptcha_secret_key",
                value: formState.recaptcha_secret_key
              })]
            })
          }, {
            name: "hcaptcha",
            title: __("hCaptcha", "petitioner"),
            description: __("hCaptcha integration. Use this to protect your forms from spam.", "petitioner"),
            enabled: formState.enable_hcaptcha,
            integrationFields: /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ToggleControl, {
                  label: "Enable hCaptcha",
                  checked: formState.enable_hcaptcha,
                  onChange: checked => updateFormState("enable_hcaptcha", checked)
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Site Key",
                    value: formState.hcaptcha_site_key,
                    onChange: value => updateFormState("hcaptcha_site_key", value),
                    placeholder: "Enter your hcaptcha site key"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Secret Key",
                    value: formState.hcaptcha_secret_key,
                    onChange: value => updateFormState("hcaptcha_secret_key", value),
                    placeholder: "Enter your hcaptcha secret key"
                  })
                })]
              })
            }),
            hiddenFields: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-hidden-fields",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "checkbox",
                name: "petitioner_enable_hcaptcha",
                checked: formState.enable_hcaptcha
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_hcaptcha_site_key",
                value: formState.hcaptcha_site_key
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_hcaptcha_secret_key",
                value: formState.hcaptcha_secret_key
              })]
            })
          }, {
            name: "turnstile",
            title: "Cloudflare Turnstile",
            description: "Cloudflare Turnstile integration. A captcha alternative that is privacy-friendly.",
            enabled: formState.enable_turnstile,
            integrationFields: /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
                children: [/* @__PURE__ */jsxRuntimeExports.jsx(ToggleControl, {
                  label: "Enable Turnstile",
                  checked: formState.enable_turnstile,
                  onChange: checked => updateFormState("enable_turnstile", checked)
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Site Key",
                    value: formState.turnstile_site_key,
                    onChange: value => updateFormState("turnstile_site_key", value),
                    placeholder: "Enter your Turnstile site key"
                  })
                }), /* @__PURE__ */jsxRuntimeExports.jsx("p", {
                  children: /* @__PURE__ */jsxRuntimeExports.jsx(TextControl, {
                    label: "Secret Key",
                    value: formState.turnstile_secret_key,
                    onChange: value => updateFormState("turnstile_secret_key", value),
                    placeholder: "Enter your Turnstile secret key"
                  })
                })]
              })
            }),
            hiddenFields: /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              className: "ptr-hidden-fields",
              children: [/* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "checkbox",
                name: "petitioner_enable_turnstile",
                checked: formState.enable_turnstile
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_turnstile_site_key",
                value: formState.turnstile_site_key
              }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "hidden",
                name: "petitioner_turnstile_secret_key",
                value: formState.turnstile_secret_key
              })]
            })
          }, {
            name: "akismet",
            title: "Akismet",
            description: "Akismet integration.",
            enabled: formState.enable_akismet,
            integrationFields: /* @__PURE__ */jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
                children: /* @__PURE__ */jsxRuntimeExports.jsx(ToggleControl, {
                  label: "Enable Akismet",
                  checked: formState.enable_akismet,
                  onChange: checked => updateFormState("enable_akismet", checked)
                })
              })
            }),
            hiddenFields: /* @__PURE__ */jsxRuntimeExports.jsx("div", {
              className: "ptr-hidden-fields",
              children: /* @__PURE__ */jsxRuntimeExports.jsx("input", {
                type: "checkbox",
                name: "petitioner_enable_akismet",
                checked: formState.enable_akismet
              })
            })
          }];
          return /* @__PURE__ */jsxRuntimeExports.jsx(Grid, {
            alignment: "bottom",
            columns: 3,
            gap: 3,
            children: integrations.map(integration => /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(IntegrationBox, {
                ...integration
              }), integration.hiddenFields]
            }, integration.name))
          });
        }
        const StyledHeading = dt(Heading)`
	margin-bottom: var(--ptr-admin-spacing-sm) !important;
`;
        const StyledText = dt(Text)`
    padding-bottom: var(--ptr-admin-spacing-sm) !important;
    margin-bottom: var(--ptr-admin-spacing-sm) !important;
    border-bottom: 1px solid var(--ptr-admin-color-grey);
`;
        const StyledTextControl = dt(TextControl)`
	width: 100%;
`;
        function TextInput({
          id,
          label,
          value,
          onChange,
          placeholder = "",
          type = "text",
          required = false,
          help = "",
          ...rest
        }) {
          return /* @__PURE__ */jsxRuntimeExports.jsx(InputWrapper, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(StyledTextControl, {
              label,
              value,
              defaultValue: value,
              type,
              help,
              name: id,
              id,
              placeholder,
              onChange,
              required,
              ...rest
            })
          });
        }
        function TextLabel({
          label,
          initialValue,
          defaultValue,
          onChange
        }) {
          const [value, setValue] = reactExports.useState(initialValue || "");
          return /* @__PURE__ */jsxRuntimeExports.jsx(TextInput, {
            id: label,
            label,
            value,
            placeholder: defaultValue,
            onChange: setValue,
            onBlur: () => onChange(label, value)
          });
        }
        function Labels() {
          const {
            windowPetitionerData,
            formState
          } = useSettingsFormContext();
          const {
            label_overrides
          } = formState;
          const defaultLabels = windowPetitionerData.default_values?.labels || {};
          const labelKeys = Object.keys(defaultLabels);
          const [overrides, setOverrides] = reactExports.useState(label_overrides || {});
          const updateOverrides = (key, value) => {
            const newOverrides = {
              ...overrides,
              [key]: value
            };
            if (!value || value == defaultLabels?.[key]) {
              delete newOverrides[key];
            }
            setOverrides(newOverrides);
          };
          return /* @__PURE__ */jsxRuntimeExports.jsxs("section", {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(StyledHeading, {
              level: 3,
              children: __("Editable labels", "petitioner")
            }), /* @__PURE__ */jsxRuntimeExports.jsx(StyledText, {
              as: "p",
              size: "small",
              children: __("This section allows you to override all of the labels available in the plugin.", "petitioner")
            }), labelKeys.map(key => {
              const overrideValue = overrides[key] ?? "";
              return /* @__PURE__ */jsxRuntimeExports.jsx(TextLabel, {
                label: key,
                initialValue: overrideValue,
                defaultValue: defaultLabels?.[key],
                onChange: (key2, val) => updateOverrides(key2, val)
              });
            }), /* @__PURE__ */jsxRuntimeExports.jsx("input", {
              "data-testid": "petitioner_label_overrides",
              type: "hidden",
              name: "petitioner_label_overrides",
              value: JSON.stringify(overrides)
            })]
          });
        }
        const tabs = [{
          name: "visual",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "visibility"
            }), " ", __("Visual Settings", "petitioner")]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(VisualSettings, {})
        }, {
          name: "integrations",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "admin-generic"
            }), " ", __("Integrations", "petitioner")]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(Integrations, {})
        }, {
          name: "labels",
          title: /* @__PURE__ */jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */jsxRuntimeExports.jsx(Dashicon, {
              icon: "editor-paste-text"
            }), " ", __("Labels", "petitioner")]
          }),
          className: "petition-tablink",
          renderingEl: /* @__PURE__ */jsxRuntimeExports.jsx(Labels, {})
        }];
        function SettingsFieldsComponent() {
          const {
            formState
          } = useSettingsFormContext();
          const {
            active_tab
          } = formState;
          return /* @__PURE__ */jsxRuntimeExports.jsx("div", {
            className: "petitioner-settings-box",
            children: /* @__PURE__ */jsxRuntimeExports.jsx(Tabs, {
              tabs,
              updateURL: true,
              defaultTab: active_tab
            })
          });
        }
        function SettingsFields() {
          return /* @__PURE__ */jsxRuntimeExports.jsx(SettingsFormContextProvider, {
            children: /* @__PURE__ */jsxRuntimeExports.jsx(SettingsFieldsComponent, {})
          });
        }
        function ShortCodeArea() {
          const formID = window?.petitionerData?.form_id;
          if (!formID) {
            return null;
          }
          return /* @__PURE__ */jsxRuntimeExports.jsx(ShortcodeElement, {
            clipboardValue: `[petitioner-form id="${formID}"]`,
            label: __("Your Petitioner shortcode", "petitioner"),
            help: __("Use this shortcode on the frontend of your website to show the petition form", "petitioner"),
            fieldName: "petitioner_shortcode"
          });
        }
        const jsonContainer = document.getElementById("petitioner-json-data");
        const rawJson = jsonContainer?.textContent || "{}";
        window.petitionerData = jsonContainer ? safelyParseJSON(rawJson) : {};
        function EditUI() {
          function FormArea() {
            return /* @__PURE__ */jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */jsxRuntimeExports.jsx(ShortCodeArea, {}), /* @__PURE__ */jsxRuntimeExports.jsx(EditFields, {})]
            });
          }
          const editorContainer = document.getElementById("petitioner-admin-form");
          if (editorContainer) {
            const editorRoot = createRoot(editorContainer);
            editorRoot.render(/* @__PURE__ */jsxRuntimeExports.jsx(FormArea, {}));
          }
        }
        function SettingsUI() {
          const settingsContainer = document.getElementById("petitioner-settings-admin-form");
          if (settingsContainer) {
            const submissionsRoot = createRoot(settingsContainer);
            submissionsRoot.render(/* @__PURE__ */jsxRuntimeExports.jsx(SettingsFields, {}));
          }
        }
        function removeLoading() {
          const loadingElement = document.querySelector(".ptr-is-loading");
          if (loadingElement) {
            loadingElement.classList.remove("ptr-is-loading");
          }
        }
        EditUI();
        SettingsUI();
        removeLoading();
      }
    };
  });
})();
